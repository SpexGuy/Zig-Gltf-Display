//
// Copyright (c) 2015-2020 The Khronos Group Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//
// This header is generated from the Khronos Vulkan XML API Registry.
//
//

const assert = @import("std").debug.assert;
pub const CString = [*]const u8;

pub const VERSION_1_0 = 1;
pub fn MAKE_VERSION(major: u32, minor: u32, patch: u32) u32 { return @shlExact(major, 22) | @shlExact(minor, 12) | patch; }

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//pub const API_VERSION = MAKE_VERSION(1, 0, 0); // Patch version should always be set to 0

// Vulkan 1.0 version number
pub const API_VERSION_1_0 = MAKE_VERSION(1, 0, 0);// Patch version should always be set to 0

pub fn VERSION_MAJOR(version: u32) u32 { return version >> 22; }
pub fn VERSION_MINOR(version: u32) u32 { return (version >> 12) & 0x3ff; }
pub fn VERSION_PATCH(version: u32) u32 { return version & 0xfff; }

// Version of this file
pub const HEADER_VERSION = 132;

pub const Flags = u32;
pub const Bool32 = u32;
pub const DeviceSize = u64;
pub const SampleMask = u32;

pub const Instance = *@OpaqueType();
pub const PhysicalDevice = *@OpaqueType();
pub const Device = *@OpaqueType();
pub const Queue = *@OpaqueType();
pub const Semaphore = *@OpaqueType();
pub const CommandBuffer = *@OpaqueType();
pub const Fence = *@OpaqueType();
pub const DeviceMemory = *@OpaqueType();
pub const Buffer = *@OpaqueType();
pub const Image = *@OpaqueType();
pub const Event = *@OpaqueType();
pub const QueryPool = *@OpaqueType();
pub const BufferView = *@OpaqueType();
pub const ImageView = *@OpaqueType();
pub const ShaderModule = *@OpaqueType();
pub const PipelineCache = *@OpaqueType();
pub const PipelineLayout = *@OpaqueType();
pub const RenderPass = *@OpaqueType();
pub const Pipeline = *@OpaqueType();
pub const DescriptorSetLayout = *@OpaqueType();
pub const Sampler = *@OpaqueType();
pub const DescriptorPool = *@OpaqueType();
pub const DescriptorSet = *@OpaqueType();
pub const Framebuffer = *@OpaqueType();
pub const CommandPool = *@OpaqueType();

pub const LOD_CLAMP_NONE = f32(1000.0);
pub const REMAINING_MIP_LEVELS = (~u32(0));
pub const REMAINING_ARRAY_LAYERS = (~u32(0));
pub const WHOLE_SIZE = (~u64(0));
pub const ATTACHMENT_UNUSED = (~u32(0));
pub const TRUE = 1;
pub const FALSE = 0;
pub const QUEUE_FAMILY_IGNORED = (~u32(0));
pub const SUBPASS_EXTERNAL = (~u32(0));
pub const MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
pub const UUID_SIZE = 16;
pub const MAX_MEMORY_TYPES = 32;
pub const MAX_MEMORY_HEAPS = 16;
pub const MAX_EXTENSION_NAME_SIZE = 256;
pub const MAX_DESCRIPTION_SIZE = 256;

pub const PipelineCacheHeaderVersion = extern enum {
    ONE = 1,
};

pub const Result = extern enum {
    SUCCESS = 0,
    NOT_READY = 1,
    TIMEOUT = 2,
    EVENT_SET = 3,
    EVENT_RESET = 4,
    INCOMPLETE = 5,
    ERROR_OUT_OF_HOST_MEMORY = -1,
    ERROR_OUT_OF_DEVICE_MEMORY = -2,
    ERROR_INITIALIZATION_FAILED = -3,
    ERROR_DEVICE_LOST = -4,
    ERROR_MEMORY_MAP_FAILED = -5,
    ERROR_LAYER_NOT_PRESENT = -6,
    ERROR_EXTENSION_NOT_PRESENT = -7,
    ERROR_FEATURE_NOT_PRESENT = -8,
    ERROR_INCOMPATIBLE_DRIVER = -9,
    ERROR_TOO_MANY_OBJECTS = -10,
    ERROR_FORMAT_NOT_SUPPORTED = -11,
    ERROR_FRAGMENTED_POOL = -12,
    ERROR_UNKNOWN = -13,
    ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    ERROR_FRAGMENTATION = -1000161000,
    ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    ERROR_SURFACE_LOST_KHR = -1000000000,
    ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    SUBOPTIMAL_KHR = 1000001003,
    ERROR_OUT_OF_DATE_KHR = -1000001004,
    ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    ERROR_VALIDATION_FAILED_EXT = -1000011001,
    ERROR_INVALID_SHADER_NV = -1000012000,
    ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    ERROR_NOT_PERMITTED_EXT = -1000174001,
    ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,

    const Self = @This();
    pub const ERROR_OUT_OF_POOL_MEMORY_KHR = Self.ERROR_OUT_OF_POOL_MEMORY;
    pub const ERROR_INVALID_EXTERNAL_HANDLE_KHR = Self.ERROR_INVALID_EXTERNAL_HANDLE;
    pub const ERROR_FRAGMENTATION_EXT = Self.ERROR_FRAGMENTATION;
    pub const ERROR_INVALID_DEVICE_ADDRESS_EXT = Self.ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
    pub const ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = Self.ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
};

pub const StructureType = extern enum {
    APPLICATION_INFO = 0,
    INSTANCE_CREATE_INFO = 1,
    DEVICE_QUEUE_CREATE_INFO = 2,
    DEVICE_CREATE_INFO = 3,
    SUBMIT_INFO = 4,
    MEMORY_ALLOCATE_INFO = 5,
    MAPPED_MEMORY_RANGE = 6,
    BIND_SPARSE_INFO = 7,
    FENCE_CREATE_INFO = 8,
    SEMAPHORE_CREATE_INFO = 9,
    EVENT_CREATE_INFO = 10,
    QUERY_POOL_CREATE_INFO = 11,
    BUFFER_CREATE_INFO = 12,
    BUFFER_VIEW_CREATE_INFO = 13,
    IMAGE_CREATE_INFO = 14,
    IMAGE_VIEW_CREATE_INFO = 15,
    SHADER_MODULE_CREATE_INFO = 16,
    PIPELINE_CACHE_CREATE_INFO = 17,
    PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    GRAPHICS_PIPELINE_CREATE_INFO = 28,
    COMPUTE_PIPELINE_CREATE_INFO = 29,
    PIPELINE_LAYOUT_CREATE_INFO = 30,
    SAMPLER_CREATE_INFO = 31,
    DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    DESCRIPTOR_POOL_CREATE_INFO = 33,
    DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    WRITE_DESCRIPTOR_SET = 35,
    COPY_DESCRIPTOR_SET = 36,
    FRAMEBUFFER_CREATE_INFO = 37,
    RENDER_PASS_CREATE_INFO = 38,
    COMMAND_POOL_CREATE_INFO = 39,
    COMMAND_BUFFER_ALLOCATE_INFO = 40,
    COMMAND_BUFFER_INHERITANCE_INFO = 41,
    COMMAND_BUFFER_BEGIN_INFO = 42,
    RENDER_PASS_BEGIN_INFO = 43,
    BUFFER_MEMORY_BARRIER = 44,
    IMAGE_MEMORY_BARRIER = 45,
    MEMORY_BARRIER = 46,
    LOADER_INSTANCE_CREATE_INFO = 47,
    LOADER_DEVICE_CREATE_INFO = 48,
    PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    BIND_BUFFER_MEMORY_INFO = 1000157000,
    BIND_IMAGE_MEMORY_INFO = 1000157001,
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    MEMORY_REQUIREMENTS_2 = 1000146003,
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    FORMAT_PROPERTIES_2 = 1000059002,
    IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    PROTECTED_SUBMIT_INFO = 1000145000,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    DEVICE_QUEUE_INFO_2 = 1000145003,
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    EXTERNAL_FENCE_PROPERTIES = 1000112001,
    EXPORT_FENCE_CREATE_INFO = 1000113000,
    EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
    PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
    PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
    PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
    IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
    ATTACHMENT_DESCRIPTION_2 = 1000109000,
    ATTACHMENT_REFERENCE_2 = 1000109001,
    SUBPASS_DESCRIPTION_2 = 1000109002,
    SUBPASS_DEPENDENCY_2 = 1000109003,
    RENDER_PASS_CREATE_INFO_2 = 1000109004,
    SUBPASS_BEGIN_INFO = 1000109005,
    SUBPASS_END_INFO = 1000109006,
    PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
    PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
    PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
    PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
    PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
    DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
    PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
    SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
    PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
    IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
    PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
    SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
    PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
    PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
    FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
    FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
    RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
    PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
    PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
    PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
    ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
    ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
    PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
    PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
    SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
    TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
    SEMAPHORE_WAIT_INFO = 1000207004,
    SEMAPHORE_SIGNAL_INFO = 1000207005,
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
    BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
    BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
    MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
    DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
    SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    PRESENT_INFO_KHR = 1000001001,
    DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    DISPLAY_PRESENT_INFO_KHR = 1000003000,
    XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VALIDATION_FLAGS_EXT = 1000061000,
    VI_SURFACE_CREATE_INFO_NN = 1000062000,
    PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
    IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    MEMORY_FD_PROPERTIES_KHR = 1000074001,
    MEMORY_GET_FD_INFO_KHR = 1000074002,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    PRESENT_REGIONS_KHR = 1000084000,
    OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    SURFACE_CAPABILITIES_2_EXT = 1000090000,
    DISPLAY_POWER_INFO_EXT = 1000091000,
    DEVICE_EVENT_INFO_EXT = 1000091001,
    DISPLAY_EVENT_INFO_EXT = 1000091002,
    SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    HDR_METADATA_EXT = 1000105000,
    SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    FENCE_GET_FD_INFO_KHR = 1000115001,
    PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
    PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
    QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
    PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
    ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
    PERFORMANCE_COUNTER_KHR = 1000116005,
    PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
    PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    SURFACE_CAPABILITIES_2_KHR = 1000119001,
    SURFACE_FORMAT_2_KHR = 1000119002,
    DISPLAY_PROPERTIES_2_KHR = 1000121000,
    DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    DEBUG_UTILS_LABEL_EXT = 1000128002,
    DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    EXTERNAL_FORMAT_ANDROID = 1000129005,
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
    PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
    WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
    DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
    SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
    PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
    DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
    PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    GEOMETRY_NV = 1000165003,
    GEOMETRY_TRIANGLES_NV = 1000165004,
    GEOMETRY_AABB_NV = 1000165005,
    BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
    PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
    CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
    PRESENT_FRAME_TOKEN_GGP = 1000191000,
    PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
    PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
    PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
    PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    CHECKPOINT_DATA_NV = 1000206000,
    QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
    QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
    INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
    PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
    PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
    PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
    PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
    PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
    PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
    PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
    PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
    PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000,
    VALIDATION_FEATURES_EXT = 1000247000,
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
    PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
    FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
    PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
    PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
    PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
    PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
    PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    PIPELINE_INFO_KHR = 1000269001,
    PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,

    const Self = @This();
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = Self.PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    pub const PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = Self.PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    pub const DEBUG_REPORT_CREATE_INFO_EXT = Self.DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    pub const RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = Self.RENDER_PASS_MULTIVIEW_CREATE_INFO;
    pub const PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = Self.PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    pub const PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    pub const PHYSICAL_DEVICE_FEATURES_2_KHR = Self.PHYSICAL_DEVICE_FEATURES_2;
    pub const PHYSICAL_DEVICE_PROPERTIES_2_KHR = Self.PHYSICAL_DEVICE_PROPERTIES_2;
    pub const FORMAT_PROPERTIES_2_KHR = Self.FORMAT_PROPERTIES_2;
    pub const IMAGE_FORMAT_PROPERTIES_2_KHR = Self.IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = Self.PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    pub const QUEUE_FAMILY_PROPERTIES_2_KHR = Self.QUEUE_FAMILY_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = Self.PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    pub const SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = Self.SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    pub const PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = Self.PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    pub const MEMORY_ALLOCATE_FLAGS_INFO_KHR = Self.MEMORY_ALLOCATE_FLAGS_INFO;
    pub const DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = Self.DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    pub const DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = Self.DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    pub const DEVICE_GROUP_SUBMIT_INFO_KHR = Self.DEVICE_GROUP_SUBMIT_INFO;
    pub const DEVICE_GROUP_BIND_SPARSE_INFO_KHR = Self.DEVICE_GROUP_BIND_SPARSE_INFO;
    pub const BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = Self.BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    pub const BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = Self.BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    pub const PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_GROUP_PROPERTIES;
    pub const DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = Self.DEVICE_GROUP_DEVICE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = Self.PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    pub const EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = Self.EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    pub const PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = Self.PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    pub const EXTERNAL_BUFFER_PROPERTIES_KHR = Self.EXTERNAL_BUFFER_PROPERTIES;
    pub const PHYSICAL_DEVICE_ID_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_ID_PROPERTIES;
    pub const EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = Self.EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    pub const EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = Self.EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    pub const EXPORT_MEMORY_ALLOCATE_INFO_KHR = Self.EXPORT_MEMORY_ALLOCATE_INFO;
    pub const PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = Self.PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    pub const EXTERNAL_SEMAPHORE_PROPERTIES_KHR = Self.EXTERNAL_SEMAPHORE_PROPERTIES;
    pub const EXPORT_SEMAPHORE_CREATE_INFO_KHR = Self.EXPORT_SEMAPHORE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = Self.PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = Self.PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    pub const PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = Self.PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    pub const DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = Self.DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    pub const SURFACE_CAPABILITIES2_EXT = Self.SURFACE_CAPABILITIES_2_EXT;
    pub const PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = Self.PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    pub const FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = Self.FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    pub const FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = Self.FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    pub const RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = Self.RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    pub const ATTACHMENT_DESCRIPTION_2_KHR = Self.ATTACHMENT_DESCRIPTION_2;
    pub const ATTACHMENT_REFERENCE_2_KHR = Self.ATTACHMENT_REFERENCE_2;
    pub const SUBPASS_DESCRIPTION_2_KHR = Self.SUBPASS_DESCRIPTION_2;
    pub const SUBPASS_DEPENDENCY_2_KHR = Self.SUBPASS_DEPENDENCY_2;
    pub const RENDER_PASS_CREATE_INFO_2_KHR = Self.RENDER_PASS_CREATE_INFO_2;
    pub const SUBPASS_BEGIN_INFO_KHR = Self.SUBPASS_BEGIN_INFO;
    pub const SUBPASS_END_INFO_KHR = Self.SUBPASS_END_INFO;
    pub const PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = Self.PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    pub const EXTERNAL_FENCE_PROPERTIES_KHR = Self.EXTERNAL_FENCE_PROPERTIES;
    pub const EXPORT_FENCE_CREATE_INFO_KHR = Self.EXPORT_FENCE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    pub const RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = Self.RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    pub const IMAGE_VIEW_USAGE_CREATE_INFO_KHR = Self.IMAGE_VIEW_USAGE_CREATE_INFO;
    pub const PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = Self.PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = Self.PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
    pub const PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = Self.PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
    pub const MEMORY_DEDICATED_REQUIREMENTS_KHR = Self.MEMORY_DEDICATED_REQUIREMENTS;
    pub const MEMORY_DEDICATED_ALLOCATE_INFO_KHR = Self.MEMORY_DEDICATED_ALLOCATE_INFO;
    pub const PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = Self.PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    pub const SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = Self.SAMPLER_REDUCTION_MODE_CREATE_INFO;
    pub const BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = Self.BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = Self.IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    pub const IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = Self.IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    pub const MEMORY_REQUIREMENTS_2_KHR = Self.MEMORY_REQUIREMENTS_2;
    pub const SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = Self.SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    pub const IMAGE_FORMAT_LIST_CREATE_INFO_KHR = Self.IMAGE_FORMAT_LIST_CREATE_INFO;
    pub const SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = Self.SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    pub const SAMPLER_YCBCR_CONVERSION_INFO_KHR = Self.SAMPLER_YCBCR_CONVERSION_INFO;
    pub const BIND_IMAGE_PLANE_MEMORY_INFO_KHR = Self.BIND_IMAGE_PLANE_MEMORY_INFO;
    pub const IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = Self.IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    pub const PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = Self.PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    pub const SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = Self.SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    pub const BIND_BUFFER_MEMORY_INFO_KHR = Self.BIND_BUFFER_MEMORY_INFO;
    pub const BIND_IMAGE_MEMORY_INFO_KHR = Self.BIND_IMAGE_MEMORY_INFO;
    pub const DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = Self.DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = Self.PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    pub const PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = Self.PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = Self.DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    pub const DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = Self.DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    pub const PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    pub const DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = Self.DESCRIPTOR_SET_LAYOUT_SUPPORT;
    pub const PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = Self.PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    pub const PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = Self.PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
    pub const PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = Self.PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    pub const PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    pub const PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    pub const PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    pub const SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = Self.SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = Self.PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    pub const PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = Self.PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    pub const SEMAPHORE_TYPE_CREATE_INFO_KHR = Self.SEMAPHORE_TYPE_CREATE_INFO;
    pub const TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = Self.TIMELINE_SEMAPHORE_SUBMIT_INFO;
    pub const SEMAPHORE_WAIT_INFO_KHR = Self.SEMAPHORE_WAIT_INFO;
    pub const SEMAPHORE_SIGNAL_INFO_KHR = Self.SEMAPHORE_SIGNAL_INFO;
    pub const PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = Self.PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    pub const PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = Self.PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    pub const PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = Self.PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    pub const ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = Self.ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    pub const ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = Self.ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    pub const PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = Self.PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    pub const BUFFER_DEVICE_ADDRESS_INFO_EXT = Self.BUFFER_DEVICE_ADDRESS_INFO;
    pub const IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = Self.IMAGE_STENCIL_USAGE_CREATE_INFO;
    pub const PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = Self.PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    pub const PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = Self.PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    pub const BUFFER_DEVICE_ADDRESS_INFO_KHR = Self.BUFFER_DEVICE_ADDRESS_INFO;
    pub const BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = Self.BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    pub const MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = Self.MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    pub const DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = Self.DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    pub const PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = Self.PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
};

pub const SystemAllocationScope = extern enum {
    COMMAND = 0,
    OBJECT = 1,
    CACHE = 2,
    DEVICE = 3,
    INSTANCE = 4,
};

pub const InternalAllocationType = extern enum {
    EXECUTABLE = 0,
};

pub const Format = extern enum {
    UNDEFINED = 0,
    R4G4_UNORM_PACK8 = 1,
    R4G4B4A4_UNORM_PACK16 = 2,
    B4G4R4A4_UNORM_PACK16 = 3,
    R5G6B5_UNORM_PACK16 = 4,
    B5G6R5_UNORM_PACK16 = 5,
    R5G5B5A1_UNORM_PACK16 = 6,
    B5G5R5A1_UNORM_PACK16 = 7,
    A1R5G5B5_UNORM_PACK16 = 8,
    R8_UNORM = 9,
    R8_SNORM = 10,
    R8_USCALED = 11,
    R8_SSCALED = 12,
    R8_UINT = 13,
    R8_SINT = 14,
    R8_SRGB = 15,
    R8G8_UNORM = 16,
    R8G8_SNORM = 17,
    R8G8_USCALED = 18,
    R8G8_SSCALED = 19,
    R8G8_UINT = 20,
    R8G8_SINT = 21,
    R8G8_SRGB = 22,
    R8G8B8_UNORM = 23,
    R8G8B8_SNORM = 24,
    R8G8B8_USCALED = 25,
    R8G8B8_SSCALED = 26,
    R8G8B8_UINT = 27,
    R8G8B8_SINT = 28,
    R8G8B8_SRGB = 29,
    B8G8R8_UNORM = 30,
    B8G8R8_SNORM = 31,
    B8G8R8_USCALED = 32,
    B8G8R8_SSCALED = 33,
    B8G8R8_UINT = 34,
    B8G8R8_SINT = 35,
    B8G8R8_SRGB = 36,
    R8G8B8A8_UNORM = 37,
    R8G8B8A8_SNORM = 38,
    R8G8B8A8_USCALED = 39,
    R8G8B8A8_SSCALED = 40,
    R8G8B8A8_UINT = 41,
    R8G8B8A8_SINT = 42,
    R8G8B8A8_SRGB = 43,
    B8G8R8A8_UNORM = 44,
    B8G8R8A8_SNORM = 45,
    B8G8R8A8_USCALED = 46,
    B8G8R8A8_SSCALED = 47,
    B8G8R8A8_UINT = 48,
    B8G8R8A8_SINT = 49,
    B8G8R8A8_SRGB = 50,
    A8B8G8R8_UNORM_PACK32 = 51,
    A8B8G8R8_SNORM_PACK32 = 52,
    A8B8G8R8_USCALED_PACK32 = 53,
    A8B8G8R8_SSCALED_PACK32 = 54,
    A8B8G8R8_UINT_PACK32 = 55,
    A8B8G8R8_SINT_PACK32 = 56,
    A8B8G8R8_SRGB_PACK32 = 57,
    A2R10G10B10_UNORM_PACK32 = 58,
    A2R10G10B10_SNORM_PACK32 = 59,
    A2R10G10B10_USCALED_PACK32 = 60,
    A2R10G10B10_SSCALED_PACK32 = 61,
    A2R10G10B10_UINT_PACK32 = 62,
    A2R10G10B10_SINT_PACK32 = 63,
    A2B10G10R10_UNORM_PACK32 = 64,
    A2B10G10R10_SNORM_PACK32 = 65,
    A2B10G10R10_USCALED_PACK32 = 66,
    A2B10G10R10_SSCALED_PACK32 = 67,
    A2B10G10R10_UINT_PACK32 = 68,
    A2B10G10R10_SINT_PACK32 = 69,
    R16_UNORM = 70,
    R16_SNORM = 71,
    R16_USCALED = 72,
    R16_SSCALED = 73,
    R16_UINT = 74,
    R16_SINT = 75,
    R16_SFLOAT = 76,
    R16G16_UNORM = 77,
    R16G16_SNORM = 78,
    R16G16_USCALED = 79,
    R16G16_SSCALED = 80,
    R16G16_UINT = 81,
    R16G16_SINT = 82,
    R16G16_SFLOAT = 83,
    R16G16B16_UNORM = 84,
    R16G16B16_SNORM = 85,
    R16G16B16_USCALED = 86,
    R16G16B16_SSCALED = 87,
    R16G16B16_UINT = 88,
    R16G16B16_SINT = 89,
    R16G16B16_SFLOAT = 90,
    R16G16B16A16_UNORM = 91,
    R16G16B16A16_SNORM = 92,
    R16G16B16A16_USCALED = 93,
    R16G16B16A16_SSCALED = 94,
    R16G16B16A16_UINT = 95,
    R16G16B16A16_SINT = 96,
    R16G16B16A16_SFLOAT = 97,
    R32_UINT = 98,
    R32_SINT = 99,
    R32_SFLOAT = 100,
    R32G32_UINT = 101,
    R32G32_SINT = 102,
    R32G32_SFLOAT = 103,
    R32G32B32_UINT = 104,
    R32G32B32_SINT = 105,
    R32G32B32_SFLOAT = 106,
    R32G32B32A32_UINT = 107,
    R32G32B32A32_SINT = 108,
    R32G32B32A32_SFLOAT = 109,
    R64_UINT = 110,
    R64_SINT = 111,
    R64_SFLOAT = 112,
    R64G64_UINT = 113,
    R64G64_SINT = 114,
    R64G64_SFLOAT = 115,
    R64G64B64_UINT = 116,
    R64G64B64_SINT = 117,
    R64G64B64_SFLOAT = 118,
    R64G64B64A64_UINT = 119,
    R64G64B64A64_SINT = 120,
    R64G64B64A64_SFLOAT = 121,
    B10G11R11_UFLOAT_PACK32 = 122,
    E5B9G9R9_UFLOAT_PACK32 = 123,
    D16_UNORM = 124,
    X8_D24_UNORM_PACK32 = 125,
    D32_SFLOAT = 126,
    S8_UINT = 127,
    D16_UNORM_S8_UINT = 128,
    D24_UNORM_S8_UINT = 129,
    D32_SFLOAT_S8_UINT = 130,
    BC1_RGB_UNORM_BLOCK = 131,
    BC1_RGB_SRGB_BLOCK = 132,
    BC1_RGBA_UNORM_BLOCK = 133,
    BC1_RGBA_SRGB_BLOCK = 134,
    BC2_UNORM_BLOCK = 135,
    BC2_SRGB_BLOCK = 136,
    BC3_UNORM_BLOCK = 137,
    BC3_SRGB_BLOCK = 138,
    BC4_UNORM_BLOCK = 139,
    BC4_SNORM_BLOCK = 140,
    BC5_UNORM_BLOCK = 141,
    BC5_SNORM_BLOCK = 142,
    BC6H_UFLOAT_BLOCK = 143,
    BC6H_SFLOAT_BLOCK = 144,
    BC7_UNORM_BLOCK = 145,
    BC7_SRGB_BLOCK = 146,
    ETC2_R8G8B8_UNORM_BLOCK = 147,
    ETC2_R8G8B8_SRGB_BLOCK = 148,
    ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    EAC_R11_UNORM_BLOCK = 153,
    EAC_R11_SNORM_BLOCK = 154,
    EAC_R11G11_UNORM_BLOCK = 155,
    EAC_R11G11_SNORM_BLOCK = 156,
    ASTC_4x4_UNORM_BLOCK = 157,
    ASTC_4x4_SRGB_BLOCK = 158,
    ASTC_5x4_UNORM_BLOCK = 159,
    ASTC_5x4_SRGB_BLOCK = 160,
    ASTC_5x5_UNORM_BLOCK = 161,
    ASTC_5x5_SRGB_BLOCK = 162,
    ASTC_6x5_UNORM_BLOCK = 163,
    ASTC_6x5_SRGB_BLOCK = 164,
    ASTC_6x6_UNORM_BLOCK = 165,
    ASTC_6x6_SRGB_BLOCK = 166,
    ASTC_8x5_UNORM_BLOCK = 167,
    ASTC_8x5_SRGB_BLOCK = 168,
    ASTC_8x6_UNORM_BLOCK = 169,
    ASTC_8x6_SRGB_BLOCK = 170,
    ASTC_8x8_UNORM_BLOCK = 171,
    ASTC_8x8_SRGB_BLOCK = 172,
    ASTC_10x5_UNORM_BLOCK = 173,
    ASTC_10x5_SRGB_BLOCK = 174,
    ASTC_10x6_UNORM_BLOCK = 175,
    ASTC_10x6_SRGB_BLOCK = 176,
    ASTC_10x8_UNORM_BLOCK = 177,
    ASTC_10x8_SRGB_BLOCK = 178,
    ASTC_10x10_UNORM_BLOCK = 179,
    ASTC_10x10_SRGB_BLOCK = 180,
    ASTC_12x10_UNORM_BLOCK = 181,
    ASTC_12x10_SRGB_BLOCK = 182,
    ASTC_12x12_UNORM_BLOCK = 183,
    ASTC_12x12_SRGB_BLOCK = 184,
    G8B8G8R8_422_UNORM = 1000156000,
    B8G8R8G8_422_UNORM = 1000156001,
    G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    G8_B8R8_2PLANE_420_UNORM = 1000156003,
    G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    G8_B8R8_2PLANE_422_UNORM = 1000156005,
    G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    R10X6_UNORM_PACK16 = 1000156007,
    R10X6G10X6_UNORM_2PACK16 = 1000156008,
    R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    R12X4_UNORM_PACK16 = 1000156017,
    R12X4G12X4_UNORM_2PACK16 = 1000156018,
    R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    G16B16G16R16_422_UNORM = 1000156027,
    B16G16R16G16_422_UNORM = 1000156028,
    G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    G16_B16R16_2PLANE_420_UNORM = 1000156030,
    G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    G16_B16R16_2PLANE_422_UNORM = 1000156032,
    G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,

    const Self = @This();
    pub const G8B8G8R8_422_UNORM_KHR = Self.G8B8G8R8_422_UNORM;
    pub const B8G8R8G8_422_UNORM_KHR = Self.B8G8R8G8_422_UNORM;
    pub const G8_B8_R8_3PLANE_420_UNORM_KHR = Self.G8_B8_R8_3PLANE_420_UNORM;
    pub const G8_B8R8_2PLANE_420_UNORM_KHR = Self.G8_B8R8_2PLANE_420_UNORM;
    pub const G8_B8_R8_3PLANE_422_UNORM_KHR = Self.G8_B8_R8_3PLANE_422_UNORM;
    pub const G8_B8R8_2PLANE_422_UNORM_KHR = Self.G8_B8R8_2PLANE_422_UNORM;
    pub const G8_B8_R8_3PLANE_444_UNORM_KHR = Self.G8_B8_R8_3PLANE_444_UNORM;
    pub const R10X6_UNORM_PACK16_KHR = Self.R10X6_UNORM_PACK16;
    pub const R10X6G10X6_UNORM_2PACK16_KHR = Self.R10X6G10X6_UNORM_2PACK16;
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = Self.R10X6G10X6B10X6A10X6_UNORM_4PACK16;
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = Self.G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = Self.B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = Self.G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = Self.G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = Self.G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = Self.G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = Self.G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
    pub const R12X4_UNORM_PACK16_KHR = Self.R12X4_UNORM_PACK16;
    pub const R12X4G12X4_UNORM_2PACK16_KHR = Self.R12X4G12X4_UNORM_2PACK16;
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = Self.R12X4G12X4B12X4A12X4_UNORM_4PACK16;
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = Self.G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = Self.B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = Self.G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = Self.G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = Self.G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = Self.G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = Self.G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
    pub const G16B16G16R16_422_UNORM_KHR = Self.G16B16G16R16_422_UNORM;
    pub const B16G16R16G16_422_UNORM_KHR = Self.B16G16R16G16_422_UNORM;
    pub const G16_B16_R16_3PLANE_420_UNORM_KHR = Self.G16_B16_R16_3PLANE_420_UNORM;
    pub const G16_B16R16_2PLANE_420_UNORM_KHR = Self.G16_B16R16_2PLANE_420_UNORM;
    pub const G16_B16_R16_3PLANE_422_UNORM_KHR = Self.G16_B16_R16_3PLANE_422_UNORM;
    pub const G16_B16R16_2PLANE_422_UNORM_KHR = Self.G16_B16R16_2PLANE_422_UNORM;
    pub const G16_B16_R16_3PLANE_444_UNORM_KHR = Self.G16_B16_R16_3PLANE_444_UNORM;
};

pub const ImageType = extern enum {
    T_1D = 0,
    T_2D = 1,
    T_3D = 2,
};

pub const ImageTiling = extern enum {
    OPTIMAL = 0,
    LINEAR = 1,
    DRM_FORMAT_MODIFIER_EXT = 1000158000,
};

pub const PhysicalDeviceType = extern enum {
    OTHER = 0,
    INTEGRATED_GPU = 1,
    DISCRETE_GPU = 2,
    VIRTUAL_GPU = 3,
    CPU = 4,
};

pub const QueryType = extern enum {
    OCCLUSION = 0,
    PIPELINE_STATISTICS = 1,
    TIMESTAMP = 2,
    TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    PERFORMANCE_QUERY_KHR = 1000116000,
    ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    PERFORMANCE_QUERY_INTEL = 1000210000,
};

pub const SharingMode = extern enum {
    EXCLUSIVE = 0,
    CONCURRENT = 1,
};

pub const ImageLayout = extern enum {
    UNDEFINED = 0,
    GENERAL = 1,
    COLOR_ATTACHMENT_OPTIMAL = 2,
    DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    SHADER_READ_ONLY_OPTIMAL = 5,
    TRANSFER_SRC_OPTIMAL = 6,
    TRANSFER_DST_OPTIMAL = 7,
    PREINITIALIZED = 8,
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
    DEPTH_READ_ONLY_OPTIMAL = 1000241001,
    STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
    STENCIL_READ_ONLY_OPTIMAL = 1000241003,
    PRESENT_SRC_KHR = 1000001002,
    SHARED_PRESENT_KHR = 1000111000,
    SHADING_RATE_OPTIMAL_NV = 1000164003,
    FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,

    const Self = @This();
    pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = Self.DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = Self.DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    pub const DEPTH_ATTACHMENT_OPTIMAL_KHR = Self.DEPTH_ATTACHMENT_OPTIMAL;
    pub const DEPTH_READ_ONLY_OPTIMAL_KHR = Self.DEPTH_READ_ONLY_OPTIMAL;
    pub const STENCIL_ATTACHMENT_OPTIMAL_KHR = Self.STENCIL_ATTACHMENT_OPTIMAL;
    pub const STENCIL_READ_ONLY_OPTIMAL_KHR = Self.STENCIL_READ_ONLY_OPTIMAL;
};

pub const ImageViewType = extern enum {
    T_1D = 0,
    T_2D = 1,
    T_3D = 2,
    CUBE = 3,
    T_1D_ARRAY = 4,
    T_2D_ARRAY = 5,
    CUBE_ARRAY = 6,
};

pub const ComponentSwizzle = extern enum {
    IDENTITY = 0,
    ZERO = 1,
    ONE = 2,
    R = 3,
    G = 4,
    B = 5,
    A = 6,
};

pub const VertexInputRate = extern enum {
    VERTEX = 0,
    INSTANCE = 1,
};

pub const PrimitiveTopology = extern enum {
    POINT_LIST = 0,
    LINE_LIST = 1,
    LINE_STRIP = 2,
    TRIANGLE_LIST = 3,
    TRIANGLE_STRIP = 4,
    TRIANGLE_FAN = 5,
    LINE_LIST_WITH_ADJACENCY = 6,
    LINE_STRIP_WITH_ADJACENCY = 7,
    TRIANGLE_LIST_WITH_ADJACENCY = 8,
    TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    PATCH_LIST = 10,
};

pub const PolygonMode = extern enum {
    FILL = 0,
    LINE = 1,
    POINT = 2,
    FILL_RECTANGLE_NV = 1000153000,
};

pub const FrontFace = extern enum {
    COUNTER_CLOCKWISE = 0,
    CLOCKWISE = 1,
};

pub const CompareOp = extern enum {
    NEVER = 0,
    LESS = 1,
    EQUAL = 2,
    LESS_OR_EQUAL = 3,
    GREATER = 4,
    NOT_EQUAL = 5,
    GREATER_OR_EQUAL = 6,
    ALWAYS = 7,
};

pub const StencilOp = extern enum {
    KEEP = 0,
    ZERO = 1,
    REPLACE = 2,
    INCREMENT_AND_CLAMP = 3,
    DECREMENT_AND_CLAMP = 4,
    INVERT = 5,
    INCREMENT_AND_WRAP = 6,
    DECREMENT_AND_WRAP = 7,
};

pub const LogicOp = extern enum {
    CLEAR = 0,
    AND = 1,
    AND_REVERSE = 2,
    COPY = 3,
    AND_INVERTED = 4,
    NO_OP = 5,
    XOR = 6,
    OR = 7,
    NOR = 8,
    EQUIVALENT = 9,
    INVERT = 10,
    OR_REVERSE = 11,
    COPY_INVERTED = 12,
    OR_INVERTED = 13,
    NAND = 14,
    SET = 15,
};

pub const BlendFactor = extern enum {
    ZERO = 0,
    ONE = 1,
    SRC_COLOR = 2,
    ONE_MINUS_SRC_COLOR = 3,
    DST_COLOR = 4,
    ONE_MINUS_DST_COLOR = 5,
    SRC_ALPHA = 6,
    ONE_MINUS_SRC_ALPHA = 7,
    DST_ALPHA = 8,
    ONE_MINUS_DST_ALPHA = 9,
    CONSTANT_COLOR = 10,
    ONE_MINUS_CONSTANT_COLOR = 11,
    CONSTANT_ALPHA = 12,
    ONE_MINUS_CONSTANT_ALPHA = 13,
    SRC_ALPHA_SATURATE = 14,
    SRC1_COLOR = 15,
    ONE_MINUS_SRC1_COLOR = 16,
    SRC1_ALPHA = 17,
    ONE_MINUS_SRC1_ALPHA = 18,
};

pub const BlendOp = extern enum {
    ADD = 0,
    SUBTRACT = 1,
    REVERSE_SUBTRACT = 2,
    MIN = 3,
    MAX = 4,
    ZERO_EXT = 1000148000,
    SRC_EXT = 1000148001,
    DST_EXT = 1000148002,
    SRC_OVER_EXT = 1000148003,
    DST_OVER_EXT = 1000148004,
    SRC_IN_EXT = 1000148005,
    DST_IN_EXT = 1000148006,
    SRC_OUT_EXT = 1000148007,
    DST_OUT_EXT = 1000148008,
    SRC_ATOP_EXT = 1000148009,
    DST_ATOP_EXT = 1000148010,
    XOR_EXT = 1000148011,
    MULTIPLY_EXT = 1000148012,
    SCREEN_EXT = 1000148013,
    OVERLAY_EXT = 1000148014,
    DARKEN_EXT = 1000148015,
    LIGHTEN_EXT = 1000148016,
    COLORDODGE_EXT = 1000148017,
    COLORBURN_EXT = 1000148018,
    HARDLIGHT_EXT = 1000148019,
    SOFTLIGHT_EXT = 1000148020,
    DIFFERENCE_EXT = 1000148021,
    EXCLUSION_EXT = 1000148022,
    INVERT_EXT = 1000148023,
    INVERT_RGB_EXT = 1000148024,
    LINEARDODGE_EXT = 1000148025,
    LINEARBURN_EXT = 1000148026,
    VIVIDLIGHT_EXT = 1000148027,
    LINEARLIGHT_EXT = 1000148028,
    PINLIGHT_EXT = 1000148029,
    HARDMIX_EXT = 1000148030,
    HSL_HUE_EXT = 1000148031,
    HSL_SATURATION_EXT = 1000148032,
    HSL_COLOR_EXT = 1000148033,
    HSL_LUMINOSITY_EXT = 1000148034,
    PLUS_EXT = 1000148035,
    PLUS_CLAMPED_EXT = 1000148036,
    PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    PLUS_DARKER_EXT = 1000148038,
    MINUS_EXT = 1000148039,
    MINUS_CLAMPED_EXT = 1000148040,
    CONTRAST_EXT = 1000148041,
    INVERT_OVG_EXT = 1000148042,
    RED_EXT = 1000148043,
    GREEN_EXT = 1000148044,
    BLUE_EXT = 1000148045,
};

pub const DynamicState = extern enum {
    VIEWPORT = 0,
    SCISSOR = 1,
    LINE_WIDTH = 2,
    DEPTH_BIAS = 3,
    BLEND_CONSTANTS = 4,
    DEPTH_BOUNDS = 5,
    STENCIL_COMPARE_MASK = 6,
    STENCIL_WRITE_MASK = 7,
    STENCIL_REFERENCE = 8,
    VIEWPORT_W_SCALING_NV = 1000087000,
    DISCARD_RECTANGLE_EXT = 1000099000,
    SAMPLE_LOCATIONS_EXT = 1000143000,
    VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    EXCLUSIVE_SCISSOR_NV = 1000205001,
    LINE_STIPPLE_EXT = 1000259000,
};

pub const Filter = extern enum {
    NEAREST = 0,
    LINEAR = 1,
    CUBIC_IMG = 1000015000,

    const Self = @This();
    pub const CUBIC_EXT = Self.CUBIC_IMG;
};

pub const SamplerMipmapMode = extern enum {
    NEAREST = 0,
    LINEAR = 1,
};

pub const SamplerAddressMode = extern enum {
    REPEAT = 0,
    MIRRORED_REPEAT = 1,
    CLAMP_TO_EDGE = 2,
    CLAMP_TO_BORDER = 3,
    MIRROR_CLAMP_TO_EDGE = 4,

    const Self = @This();
    pub const MIRROR_CLAMP_TO_EDGE_KHR = Self.MIRROR_CLAMP_TO_EDGE;
};

pub const BorderColor = extern enum {
    FLOAT_TRANSPARENT_BLACK = 0,
    INT_TRANSPARENT_BLACK = 1,
    FLOAT_OPAQUE_BLACK = 2,
    INT_OPAQUE_BLACK = 3,
    FLOAT_OPAQUE_WHITE = 4,
    INT_OPAQUE_WHITE = 5,
};

pub const DescriptorType = extern enum {
    SAMPLER = 0,
    COMBINED_IMAGE_SAMPLER = 1,
    SAMPLED_IMAGE = 2,
    STORAGE_IMAGE = 3,
    UNIFORM_TEXEL_BUFFER = 4,
    STORAGE_TEXEL_BUFFER = 5,
    UNIFORM_BUFFER = 6,
    STORAGE_BUFFER = 7,
    UNIFORM_BUFFER_DYNAMIC = 8,
    STORAGE_BUFFER_DYNAMIC = 9,
    INPUT_ATTACHMENT = 10,
    INLINE_UNIFORM_BLOCK_EXT = 1000138000,
    ACCELERATION_STRUCTURE_NV = 1000165000,
};

pub const AttachmentLoadOp = extern enum {
    LOAD = 0,
    CLEAR = 1,
    DONT_CARE = 2,
};

pub const AttachmentStoreOp = extern enum {
    STORE = 0,
    DONT_CARE = 1,
};

pub const PipelineBindPoint = extern enum {
    GRAPHICS = 0,
    COMPUTE = 1,
    RAY_TRACING_NV = 1000165000,
};

pub const CommandBufferLevel = extern enum {
    PRIMARY = 0,
    SECONDARY = 1,
};

pub const IndexType = extern enum {
    UINT16 = 0,
    UINT32 = 1,
    NONE_NV = 1000165000,
    UINT8_EXT = 1000265000,
};

pub const SubpassContents = extern enum {
    INLINE = 0,
    SECONDARY_COMMAND_BUFFERS = 1,
};

pub const ObjectType = extern enum {
    UNKNOWN = 0,
    INSTANCE = 1,
    PHYSICAL_DEVICE = 2,
    DEVICE = 3,
    QUEUE = 4,
    SEMAPHORE = 5,
    COMMAND_BUFFER = 6,
    FENCE = 7,
    DEVICE_MEMORY = 8,
    BUFFER = 9,
    IMAGE = 10,
    EVENT = 11,
    QUERY_POOL = 12,
    BUFFER_VIEW = 13,
    IMAGE_VIEW = 14,
    SHADER_MODULE = 15,
    PIPELINE_CACHE = 16,
    PIPELINE_LAYOUT = 17,
    RENDER_PASS = 18,
    PIPELINE = 19,
    DESCRIPTOR_SET_LAYOUT = 20,
    SAMPLER = 21,
    DESCRIPTOR_POOL = 22,
    DESCRIPTOR_SET = 23,
    FRAMEBUFFER = 24,
    COMMAND_POOL = 25,
    SAMPLER_YCBCR_CONVERSION = 1000156000,
    DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    SURFACE_KHR = 1000000000,
    SWAPCHAIN_KHR = 1000001000,
    DISPLAY_KHR = 1000002000,
    DISPLAY_MODE_KHR = 1000002001,
    DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    OBJECT_TABLE_NVX = 1000086000,
    INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VALIDATION_CACHE_EXT = 1000160000,
    ACCELERATION_STRUCTURE_NV = 1000165000,
    PERFORMANCE_CONFIGURATION_INTEL = 1000210000,

    const Self = @This();
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR = Self.DESCRIPTOR_UPDATE_TEMPLATE;
    pub const SAMPLER_YCBCR_CONVERSION_KHR = Self.SAMPLER_YCBCR_CONVERSION;
};

pub const VendorId = extern enum {
    VIV = 0x10001,
    VSI = 0x10002,
    KAZAN = 0x10003,
};

pub const InstanceCreateFlags = Flags;

pub const FormatFeatureFlags = Flags;
pub const FormatFeatureFlagBits = struct {
    pub const SAMPLED_IMAGE_BIT: FormatFeatureFlags = 0x00000001;
    pub const STORAGE_IMAGE_BIT: FormatFeatureFlags = 0x00000002;
    pub const STORAGE_IMAGE_ATOMIC_BIT: FormatFeatureFlags = 0x00000004;
    pub const UNIFORM_TEXEL_BUFFER_BIT: FormatFeatureFlags = 0x00000008;
    pub const STORAGE_TEXEL_BUFFER_BIT: FormatFeatureFlags = 0x00000010;
    pub const STORAGE_TEXEL_BUFFER_ATOMIC_BIT: FormatFeatureFlags = 0x00000020;
    pub const VERTEX_BUFFER_BIT: FormatFeatureFlags = 0x00000040;
    pub const COLOR_ATTACHMENT_BIT: FormatFeatureFlags = 0x00000080;
    pub const COLOR_ATTACHMENT_BLEND_BIT: FormatFeatureFlags = 0x00000100;
    pub const DEPTH_STENCIL_ATTACHMENT_BIT: FormatFeatureFlags = 0x00000200;
    pub const BLIT_SRC_BIT: FormatFeatureFlags = 0x00000400;
    pub const BLIT_DST_BIT: FormatFeatureFlags = 0x00000800;
    pub const SAMPLED_IMAGE_FILTER_LINEAR_BIT: FormatFeatureFlags = 0x00001000;
    pub const TRANSFER_SRC_BIT: FormatFeatureFlags = 0x00004000;
    pub const TRANSFER_DST_BIT: FormatFeatureFlags = 0x00008000;
    pub const MIDPOINT_CHROMA_SAMPLES_BIT: FormatFeatureFlags = 0x00020000;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: FormatFeatureFlags = 0x00040000;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: FormatFeatureFlags = 0x00080000;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: FormatFeatureFlags = 0x00100000;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: FormatFeatureFlags = 0x00200000;
    pub const DISJOINT_BIT: FormatFeatureFlags = 0x00400000;
    pub const COSITED_CHROMA_SAMPLES_BIT: FormatFeatureFlags = 0x00800000;
    pub const SAMPLED_IMAGE_FILTER_MINMAX_BIT: FormatFeatureFlags = 0x00010000;
    pub const SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: FormatFeatureFlags = 0x00002000;
    pub const RESERVED_27_BIT_KHR: FormatFeatureFlags = 0x08000000;
    pub const RESERVED_28_BIT_KHR: FormatFeatureFlags = 0x10000000;
    pub const RESERVED_25_BIT_KHR: FormatFeatureFlags = 0x02000000;
    pub const RESERVED_26_BIT_KHR: FormatFeatureFlags = 0x04000000;
    pub const RESERVED_29_BIT_NV: FormatFeatureFlags = 0x20000000;
    pub const FRAGMENT_DENSITY_MAP_BIT_EXT: FormatFeatureFlags = 0x01000000;

    pub const TRANSFER_SRC_BIT_KHR = TRANSFER_SRC_BIT;
    pub const TRANSFER_DST_BIT_KHR = TRANSFER_DST_BIT;
    pub const SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = SAMPLED_IMAGE_FILTER_MINMAX_BIT;
    pub const MIDPOINT_CHROMA_SAMPLES_BIT_KHR = MIDPOINT_CHROMA_SAMPLES_BIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
    pub const DISJOINT_BIT_KHR = DISJOINT_BIT;
    pub const COSITED_CHROMA_SAMPLES_BIT_KHR = COSITED_CHROMA_SAMPLES_BIT;
    pub const SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
};

pub const ImageUsageFlags = Flags;
pub const ImageUsageFlagBits = struct {
    pub const TRANSFER_SRC_BIT: ImageUsageFlags = 0x00000001;
    pub const TRANSFER_DST_BIT: ImageUsageFlags = 0x00000002;
    pub const SAMPLED_BIT: ImageUsageFlags = 0x00000004;
    pub const STORAGE_BIT: ImageUsageFlags = 0x00000008;
    pub const COLOR_ATTACHMENT_BIT: ImageUsageFlags = 0x00000010;
    pub const DEPTH_STENCIL_ATTACHMENT_BIT: ImageUsageFlags = 0x00000020;
    pub const TRANSIENT_ATTACHMENT_BIT: ImageUsageFlags = 0x00000040;
    pub const INPUT_ATTACHMENT_BIT: ImageUsageFlags = 0x00000080;
    pub const RESERVED_13_BIT_KHR: ImageUsageFlags = 0x00002000;
    pub const RESERVED_14_BIT_KHR: ImageUsageFlags = 0x00004000;
    pub const RESERVED_15_BIT_KHR: ImageUsageFlags = 0x00008000;
    pub const RESERVED_10_BIT_KHR: ImageUsageFlags = 0x00000400;
    pub const RESERVED_11_BIT_KHR: ImageUsageFlags = 0x00000800;
    pub const RESERVED_12_BIT_KHR: ImageUsageFlags = 0x00001000;
    pub const SHADING_RATE_IMAGE_BIT_NV: ImageUsageFlags = 0x00000100;
    pub const RESERVED_16_BIT_QCOM: ImageUsageFlags = 0x00010000;
    pub const RESERVED_17_BIT_QCOM: ImageUsageFlags = 0x00020000;
    pub const FRAGMENT_DENSITY_MAP_BIT_EXT: ImageUsageFlags = 0x00000200;
};

pub const ImageCreateFlags = Flags;
pub const ImageCreateFlagBits = struct {
    pub const SPARSE_BINDING_BIT: ImageCreateFlags = 0x00000001;
    pub const SPARSE_RESIDENCY_BIT: ImageCreateFlags = 0x00000002;
    pub const SPARSE_ALIASED_BIT: ImageCreateFlags = 0x00000004;
    pub const MUTABLE_FORMAT_BIT: ImageCreateFlags = 0x00000008;
    pub const CUBE_COMPATIBLE_BIT: ImageCreateFlags = 0x00000010;
    pub const ALIAS_BIT: ImageCreateFlags = 0x00000400;
    pub const SPLIT_INSTANCE_BIND_REGIONS_BIT: ImageCreateFlags = 0x00000040;
    pub const T_2D_ARRAY_COMPATIBLE_BIT: ImageCreateFlags = 0x00000020;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: ImageCreateFlags = 0x00000080;
    pub const EXTENDED_USAGE_BIT: ImageCreateFlags = 0x00000100;
    pub const PROTECTED_BIT: ImageCreateFlags = 0x00000800;
    pub const DISJOINT_BIT: ImageCreateFlags = 0x00000200;
    pub const CORNER_SAMPLED_BIT_NV: ImageCreateFlags = 0x00002000;
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: ImageCreateFlags = 0x00001000;
    pub const SUBSAMPLED_BIT_EXT: ImageCreateFlags = 0x00004000;

    pub const SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = SPLIT_INSTANCE_BIND_REGIONS_BIT;
    pub const T_2D_ARRAY_COMPATIBLE_BIT_KHR = T_2D_ARRAY_COMPATIBLE_BIT;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
    pub const EXTENDED_USAGE_BIT_KHR = EXTENDED_USAGE_BIT;
    pub const DISJOINT_BIT_KHR = DISJOINT_BIT;
    pub const ALIAS_BIT_KHR = ALIAS_BIT;
};

pub const SampleCountFlags = Flags;
pub const SampleCountFlagBits = struct {
    pub const T_1_BIT: SampleCountFlags = 0x00000001;
    pub const T_2_BIT: SampleCountFlags = 0x00000002;
    pub const T_4_BIT: SampleCountFlags = 0x00000004;
    pub const T_8_BIT: SampleCountFlags = 0x00000008;
    pub const T_16_BIT: SampleCountFlags = 0x00000010;
    pub const T_32_BIT: SampleCountFlags = 0x00000020;
    pub const T_64_BIT: SampleCountFlags = 0x00000040;
};

pub const QueueFlags = Flags;
pub const QueueFlagBits = struct {
    pub const GRAPHICS_BIT: QueueFlags = 0x00000001;
    pub const COMPUTE_BIT: QueueFlags = 0x00000002;
    pub const TRANSFER_BIT: QueueFlags = 0x00000004;
    pub const SPARSE_BINDING_BIT: QueueFlags = 0x00000008;
    pub const PROTECTED_BIT: QueueFlags = 0x00000010;
    pub const RESERVED_6_BIT_KHR: QueueFlags = 0x00000040;
    pub const RESERVED_5_BIT_KHR: QueueFlags = 0x00000020;
};

pub const MemoryPropertyFlags = Flags;
pub const MemoryPropertyFlagBits = struct {
    pub const DEVICE_LOCAL_BIT: MemoryPropertyFlags = 0x00000001;
    pub const HOST_VISIBLE_BIT: MemoryPropertyFlags = 0x00000002;
    pub const HOST_COHERENT_BIT: MemoryPropertyFlags = 0x00000004;
    pub const HOST_CACHED_BIT: MemoryPropertyFlags = 0x00000008;
    pub const LAZILY_ALLOCATED_BIT: MemoryPropertyFlags = 0x00000010;
    pub const PROTECTED_BIT: MemoryPropertyFlags = 0x00000020;
    pub const DEVICE_COHERENT_BIT_AMD: MemoryPropertyFlags = 0x00000040;
    pub const DEVICE_UNCACHED_BIT_AMD: MemoryPropertyFlags = 0x00000080;
};

pub const MemoryHeapFlags = Flags;
pub const MemoryHeapFlagBits = struct {
    pub const DEVICE_LOCAL_BIT: MemoryHeapFlags = 0x00000001;
    pub const MULTI_INSTANCE_BIT: MemoryHeapFlags = 0x00000002;
    pub const RESERVED_2_BIT_KHR: MemoryHeapFlags = 0x00000004;

    pub const MULTI_INSTANCE_BIT_KHR = MULTI_INSTANCE_BIT;
};

pub const DeviceCreateFlags = Flags;

pub const DeviceQueueCreateFlags = Flags;
pub const DeviceQueueCreateFlagBits = struct {
    pub const PROTECTED_BIT: DeviceQueueCreateFlags = 0x00000001;
};

pub const PipelineStageFlags = Flags;
pub const PipelineStageFlagBits = struct {
    pub const TOP_OF_PIPE_BIT: PipelineStageFlags = 0x00000001;
    pub const DRAW_INDIRECT_BIT: PipelineStageFlags = 0x00000002;
    pub const VERTEX_INPUT_BIT: PipelineStageFlags = 0x00000004;
    pub const VERTEX_SHADER_BIT: PipelineStageFlags = 0x00000008;
    pub const TESSELLATION_CONTROL_SHADER_BIT: PipelineStageFlags = 0x00000010;
    pub const TESSELLATION_EVALUATION_SHADER_BIT: PipelineStageFlags = 0x00000020;
    pub const GEOMETRY_SHADER_BIT: PipelineStageFlags = 0x00000040;
    pub const FRAGMENT_SHADER_BIT: PipelineStageFlags = 0x00000080;
    pub const EARLY_FRAGMENT_TESTS_BIT: PipelineStageFlags = 0x00000100;
    pub const LATE_FRAGMENT_TESTS_BIT: PipelineStageFlags = 0x00000200;
    pub const COLOR_ATTACHMENT_OUTPUT_BIT: PipelineStageFlags = 0x00000400;
    pub const COMPUTE_SHADER_BIT: PipelineStageFlags = 0x00000800;
    pub const TRANSFER_BIT: PipelineStageFlags = 0x00001000;
    pub const BOTTOM_OF_PIPE_BIT: PipelineStageFlags = 0x00002000;
    pub const HOST_BIT: PipelineStageFlags = 0x00004000;
    pub const ALL_GRAPHICS_BIT: PipelineStageFlags = 0x00008000;
    pub const ALL_COMMANDS_BIT: PipelineStageFlags = 0x00010000;
    pub const RESERVED_27_BIT_KHR: PipelineStageFlags = 0x08000000;
    pub const RESERVED_26_BIT_KHR: PipelineStageFlags = 0x04000000;
    pub const TRANSFORM_FEEDBACK_BIT_EXT: PipelineStageFlags = 0x01000000;
    pub const CONDITIONAL_RENDERING_BIT_EXT: PipelineStageFlags = 0x00040000;
    pub const COMMAND_PROCESS_BIT_NVX: PipelineStageFlags = 0x00020000;
    pub const SHADING_RATE_IMAGE_BIT_NV: PipelineStageFlags = 0x00400000;
    pub const RAY_TRACING_SHADER_BIT_NV: PipelineStageFlags = 0x00200000;
    pub const ACCELERATION_STRUCTURE_BUILD_BIT_NV: PipelineStageFlags = 0x02000000;
    pub const TASK_SHADER_BIT_NV: PipelineStageFlags = 0x00080000;
    pub const MESH_SHADER_BIT_NV: PipelineStageFlags = 0x00100000;
    pub const FRAGMENT_DENSITY_PROCESS_BIT_EXT: PipelineStageFlags = 0x00800000;
};

pub const MemoryMapFlags = Flags;

pub const ImageAspectFlags = Flags;
pub const ImageAspectFlagBits = struct {
    pub const COLOR_BIT: ImageAspectFlags = 0x00000001;
    pub const DEPTH_BIT: ImageAspectFlags = 0x00000002;
    pub const STENCIL_BIT: ImageAspectFlags = 0x00000004;
    pub const METADATA_BIT: ImageAspectFlags = 0x00000008;
    pub const PLANE_0_BIT: ImageAspectFlags = 0x00000010;
    pub const PLANE_1_BIT: ImageAspectFlags = 0x00000020;
    pub const PLANE_2_BIT: ImageAspectFlags = 0x00000040;
    pub const MEMORY_PLANE_0_BIT_EXT: ImageAspectFlags = 0x00000080;
    pub const MEMORY_PLANE_1_BIT_EXT: ImageAspectFlags = 0x00000100;
    pub const MEMORY_PLANE_2_BIT_EXT: ImageAspectFlags = 0x00000200;
    pub const MEMORY_PLANE_3_BIT_EXT: ImageAspectFlags = 0x00000400;

    pub const PLANE_0_BIT_KHR = PLANE_0_BIT;
    pub const PLANE_1_BIT_KHR = PLANE_1_BIT;
    pub const PLANE_2_BIT_KHR = PLANE_2_BIT;
};

pub const SparseImageFormatFlags = Flags;
pub const SparseImageFormatFlagBits = struct {
    pub const SINGLE_MIPTAIL_BIT: SparseImageFormatFlags = 0x00000001;
    pub const ALIGNED_MIP_SIZE_BIT: SparseImageFormatFlags = 0x00000002;
    pub const NONSTANDARD_BLOCK_SIZE_BIT: SparseImageFormatFlags = 0x00000004;
};

pub const SparseMemoryBindFlags = Flags;
pub const SparseMemoryBindFlagBits = struct {
    pub const METADATA_BIT: SparseMemoryBindFlags = 0x00000001;
};

pub const FenceCreateFlags = Flags;
pub const FenceCreateFlagBits = struct {
    pub const SIGNALED_BIT: FenceCreateFlags = 0x00000001;
};

pub const SemaphoreCreateFlags = Flags;
pub const EventCreateFlags = Flags;
pub const QueryPoolCreateFlags = Flags;

pub const QueryPipelineStatisticFlags = Flags;
pub const QueryPipelineStatisticFlagBits = struct {
    pub const INPUT_ASSEMBLY_VERTICES_BIT: QueryPipelineStatisticFlags = 0x00000001;
    pub const INPUT_ASSEMBLY_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 0x00000002;
    pub const VERTEX_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000004;
    pub const GEOMETRY_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000008;
    pub const GEOMETRY_SHADER_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 0x00000010;
    pub const CLIPPING_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000020;
    pub const CLIPPING_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 0x00000040;
    pub const FRAGMENT_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000080;
    pub const TESSELLATION_CONTROL_SHADER_PATCHES_BIT: QueryPipelineStatisticFlags = 0x00000100;
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000200;
    pub const COMPUTE_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 0x00000400;
};

pub const QueryResultFlags = Flags;
pub const QueryResultFlagBits = struct {
    pub const T_64_BIT: QueryResultFlags = 0x00000001;
    pub const WAIT_BIT: QueryResultFlags = 0x00000002;
    pub const WITH_AVAILABILITY_BIT: QueryResultFlags = 0x00000004;
    pub const PARTIAL_BIT: QueryResultFlags = 0x00000008;
};

pub const BufferCreateFlags = Flags;
pub const BufferCreateFlagBits = struct {
    pub const SPARSE_BINDING_BIT: BufferCreateFlags = 0x00000001;
    pub const SPARSE_RESIDENCY_BIT: BufferCreateFlags = 0x00000002;
    pub const SPARSE_ALIASED_BIT: BufferCreateFlags = 0x00000004;
    pub const PROTECTED_BIT: BufferCreateFlags = 0x00000008;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: BufferCreateFlags = 0x00000010;

    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
};

pub const BufferUsageFlags = Flags;
pub const BufferUsageFlagBits = struct {
    pub const TRANSFER_SRC_BIT: BufferUsageFlags = 0x00000001;
    pub const TRANSFER_DST_BIT: BufferUsageFlags = 0x00000002;
    pub const UNIFORM_TEXEL_BUFFER_BIT: BufferUsageFlags = 0x00000004;
    pub const STORAGE_TEXEL_BUFFER_BIT: BufferUsageFlags = 0x00000008;
    pub const UNIFORM_BUFFER_BIT: BufferUsageFlags = 0x00000010;
    pub const STORAGE_BUFFER_BIT: BufferUsageFlags = 0x00000020;
    pub const INDEX_BUFFER_BIT: BufferUsageFlags = 0x00000040;
    pub const VERTEX_BUFFER_BIT: BufferUsageFlags = 0x00000080;
    pub const INDIRECT_BUFFER_BIT: BufferUsageFlags = 0x00000100;
    pub const SHADER_DEVICE_ADDRESS_BIT: BufferUsageFlags = 0x00020000;
    pub const RESERVED_15_BIT_KHR: BufferUsageFlags = 0x00008000;
    pub const RESERVED_16_BIT_KHR: BufferUsageFlags = 0x00010000;
    pub const RESERVED_13_BIT_KHR: BufferUsageFlags = 0x00002000;
    pub const RESERVED_14_BIT_KHR: BufferUsageFlags = 0x00004000;
    pub const TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: BufferUsageFlags = 0x00000800;
    pub const TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: BufferUsageFlags = 0x00001000;
    pub const CONDITIONAL_RENDERING_BIT_EXT: BufferUsageFlags = 0x00000200;
    pub const RAY_TRACING_BIT_NV: BufferUsageFlags = 0x00000400;
    pub const RESERVED_18_BIT_QCOM: BufferUsageFlags = 0x00040000;

    pub const SHADER_DEVICE_ADDRESS_BIT_EXT = SHADER_DEVICE_ADDRESS_BIT;
    pub const SHADER_DEVICE_ADDRESS_BIT_KHR = SHADER_DEVICE_ADDRESS_BIT;
};

pub const BufferViewCreateFlags = Flags;

pub const ImageViewCreateFlags = Flags;
pub const ImageViewCreateFlagBits = struct {
    pub const FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: ImageViewCreateFlags = 0x00000001;
};

pub const ShaderModuleCreateFlags = Flags;
pub const ShaderModuleCreateFlagBits = struct {
    pub const RESERVED_0_BIT_NV: ShaderModuleCreateFlags = 0x00000001;
};

pub const PipelineCacheCreateFlags = Flags;

pub const PipelineCreateFlags = Flags;
pub const PipelineCreateFlagBits = struct {
    pub const DISABLE_OPTIMIZATION_BIT: PipelineCreateFlags = 0x00000001;
    pub const ALLOW_DERIVATIVES_BIT: PipelineCreateFlags = 0x00000002;
    pub const DERIVATIVE_BIT: PipelineCreateFlags = 0x00000004;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_BIT: PipelineCreateFlags = 0x00000008;
    pub const DISPATCH_BASE_BIT: PipelineCreateFlags = 0x00000010;
    pub const EXTENSION_151_BIT0_NV: PipelineCreateFlags = 0x00000800;
    pub const EXTENSION_151_BIT1_NV: PipelineCreateFlags = 0x00004000;
    pub const EXTENSION_151_BIT2_NV: PipelineCreateFlags = 0x00008000;
    pub const EXTENSION_151_BIT3_NV: PipelineCreateFlags = 0x00010000;
    pub const EXTENSION_151_BIT4_NV: PipelineCreateFlags = 0x00020000;
    pub const DEFER_COMPILE_BIT_NV: PipelineCreateFlags = 0x00000020;
    pub const CAPTURE_STATISTICS_BIT_KHR: PipelineCreateFlags = 0x00000040;
    pub const CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: PipelineCreateFlags = 0x00000080;
    pub const EXTENSION_291_BIT0_NV: PipelineCreateFlags = 0x00001000;
    pub const EXTENSION_291_BIT1_NV: PipelineCreateFlags = 0x00002000;
    pub const RESERVED_8_BIT_EXT: PipelineCreateFlags = 0x00000100;
    pub const RESERVED_9_BIT_EXT: PipelineCreateFlags = 0x00000200;
    pub const RESERVED_10_BIT_EXT: PipelineCreateFlags = 0x00000400;

    pub const DISPATCH_BASE = DISPATCH_BASE_BIT;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
    pub const DISPATCH_BASE_KHR = DISPATCH_BASE;
};

pub const PipelineShaderStageCreateFlags = Flags;
pub const PipelineShaderStageCreateFlagBits = struct {
    pub const RESERVED_2_BIT_NV: PipelineShaderStageCreateFlags = 0x00000004;
    pub const ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: PipelineShaderStageCreateFlags = 0x00000001;
    pub const REQUIRE_FULL_SUBGROUPS_BIT_EXT: PipelineShaderStageCreateFlags = 0x00000002;
    pub const RESERVED_3_BIT_KHR: PipelineShaderStageCreateFlags = 0x00000008;
};

pub const ShaderStageFlags = Flags;
pub const ShaderStageFlagBits = struct {
    pub const VERTEX_BIT: ShaderStageFlags = 0x00000001;
    pub const TESSELLATION_CONTROL_BIT: ShaderStageFlags = 0x00000002;
    pub const TESSELLATION_EVALUATION_BIT: ShaderStageFlags = 0x00000004;
    pub const GEOMETRY_BIT: ShaderStageFlags = 0x00000008;
    pub const FRAGMENT_BIT: ShaderStageFlags = 0x00000010;
    pub const COMPUTE_BIT: ShaderStageFlags = 0x00000020;
    pub const ALL_GRAPHICS: ShaderStageFlags = 0x0000001F;
    pub const ALL: ShaderStageFlags = 0x7FFFFFFF;
    pub const RAYGEN_BIT_NV: ShaderStageFlags = 0x00000100;
    pub const ANY_HIT_BIT_NV: ShaderStageFlags = 0x00000200;
    pub const CLOSEST_HIT_BIT_NV: ShaderStageFlags = 0x00000400;
    pub const MISS_BIT_NV: ShaderStageFlags = 0x00000800;
    pub const INTERSECTION_BIT_NV: ShaderStageFlags = 0x00001000;
    pub const CALLABLE_BIT_NV: ShaderStageFlags = 0x00002000;
    pub const TASK_BIT_NV: ShaderStageFlags = 0x00000040;
    pub const MESH_BIT_NV: ShaderStageFlags = 0x00000080;
};

pub const PipelineVertexInputStateCreateFlags = Flags;
pub const PipelineInputAssemblyStateCreateFlags = Flags;
pub const PipelineTessellationStateCreateFlags = Flags;
pub const PipelineViewportStateCreateFlags = Flags;
pub const PipelineRasterizationStateCreateFlags = Flags;

pub const CullModeFlags = Flags;
pub const CullModeFlagBits = struct {
    pub const NONE: CullModeFlags = 0;
    pub const FRONT_BIT: CullModeFlags = 0x00000001;
    pub const BACK_BIT: CullModeFlags = 0x00000002;
    pub const FRONT_AND_BACK: CullModeFlags = 0x00000003;
};

pub const PipelineMultisampleStateCreateFlags = Flags;
pub const PipelineDepthStencilStateCreateFlags = Flags;
pub const PipelineColorBlendStateCreateFlags = Flags;

pub const ColorComponentFlags = Flags;
pub const ColorComponentFlagBits = struct {
    pub const R_BIT: ColorComponentFlags = 0x00000001;
    pub const G_BIT: ColorComponentFlags = 0x00000002;
    pub const B_BIT: ColorComponentFlags = 0x00000004;
    pub const A_BIT: ColorComponentFlags = 0x00000008;
};

pub const PipelineDynamicStateCreateFlags = Flags;
pub const PipelineLayoutCreateFlags = Flags;

pub const SamplerCreateFlags = Flags;
pub const SamplerCreateFlagBits = struct {
    pub const SUBSAMPLED_BIT_EXT: SamplerCreateFlags = 0x00000001;
    pub const SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: SamplerCreateFlags = 0x00000002;
};

pub const DescriptorSetLayoutCreateFlags = Flags;
pub const DescriptorSetLayoutCreateFlagBits = struct {
    pub const UPDATE_AFTER_BIND_POOL_BIT: DescriptorSetLayoutCreateFlags = 0x00000002;
    pub const PUSH_DESCRIPTOR_BIT_KHR: DescriptorSetLayoutCreateFlags = 0x00000001;

    pub const UPDATE_AFTER_BIND_POOL_BIT_EXT = UPDATE_AFTER_BIND_POOL_BIT;
};

pub const DescriptorPoolCreateFlags = Flags;
pub const DescriptorPoolCreateFlagBits = struct {
    pub const FREE_DESCRIPTOR_SET_BIT: DescriptorPoolCreateFlags = 0x00000001;
    pub const UPDATE_AFTER_BIND_BIT: DescriptorPoolCreateFlags = 0x00000002;

    pub const UPDATE_AFTER_BIND_BIT_EXT = UPDATE_AFTER_BIND_BIT;
};

pub const DescriptorPoolResetFlags = Flags;

pub const FramebufferCreateFlags = Flags;
pub const FramebufferCreateFlagBits = struct {
    pub const IMAGELESS_BIT: FramebufferCreateFlags = 0x00000001;

    pub const IMAGELESS_BIT_KHR = IMAGELESS_BIT;
};

pub const RenderPassCreateFlags = Flags;
pub const RenderPassCreateFlagBits = struct {
    pub const RESERVED_0_BIT_KHR: RenderPassCreateFlags = 0x00000001;
    pub const RENDER_PASS_RESERVED_BIT_1_QCOM: RenderPassCreateFlags = 0x00000002;
};

pub const AttachmentDescriptionFlags = Flags;
pub const AttachmentDescriptionFlagBits = struct {
    pub const MAY_ALIAS_BIT: AttachmentDescriptionFlags = 0x00000001;
};

pub const SubpassDescriptionFlags = Flags;
pub const SubpassDescriptionFlagBits = struct {
    pub const PER_VIEW_ATTRIBUTES_BIT_NVX: SubpassDescriptionFlags = 0x00000001;
    pub const PER_VIEW_POSITION_X_ONLY_BIT_NVX: SubpassDescriptionFlags = 0x00000002;
    pub const RESERVED_2_BIT_QCOM: SubpassDescriptionFlags = 0x00000004;
    pub const RESERVED_3_BIT_QCOM: SubpassDescriptionFlags = 0x00000008;
};

pub const AccessFlags = Flags;
pub const AccessFlagBits = struct {
    pub const INDIRECT_COMMAND_READ_BIT: AccessFlags = 0x00000001;
    pub const INDEX_READ_BIT: AccessFlags = 0x00000002;
    pub const VERTEX_ATTRIBUTE_READ_BIT: AccessFlags = 0x00000004;
    pub const UNIFORM_READ_BIT: AccessFlags = 0x00000008;
    pub const INPUT_ATTACHMENT_READ_BIT: AccessFlags = 0x00000010;
    pub const SHADER_READ_BIT: AccessFlags = 0x00000020;
    pub const SHADER_WRITE_BIT: AccessFlags = 0x00000040;
    pub const COLOR_ATTACHMENT_READ_BIT: AccessFlags = 0x00000080;
    pub const COLOR_ATTACHMENT_WRITE_BIT: AccessFlags = 0x00000100;
    pub const DEPTH_STENCIL_ATTACHMENT_READ_BIT: AccessFlags = 0x00000200;
    pub const DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: AccessFlags = 0x00000400;
    pub const TRANSFER_READ_BIT: AccessFlags = 0x00000800;
    pub const TRANSFER_WRITE_BIT: AccessFlags = 0x00001000;
    pub const HOST_READ_BIT: AccessFlags = 0x00002000;
    pub const HOST_WRITE_BIT: AccessFlags = 0x00004000;
    pub const MEMORY_READ_BIT: AccessFlags = 0x00008000;
    pub const MEMORY_WRITE_BIT: AccessFlags = 0x00010000;
    pub const RESERVED_30_BIT_KHR: AccessFlags = 0x40000000;
    pub const RESERVED_31_BIT_KHR: AccessFlags = 0x80000000;
    pub const RESERVED_28_BIT_KHR: AccessFlags = 0x10000000;
    pub const RESERVED_29_BIT_KHR: AccessFlags = 0x20000000;
    pub const TRANSFORM_FEEDBACK_WRITE_BIT_EXT: AccessFlags = 0x02000000;
    pub const TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: AccessFlags = 0x04000000;
    pub const TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: AccessFlags = 0x08000000;
    pub const CONDITIONAL_RENDERING_READ_BIT_EXT: AccessFlags = 0x00100000;
    pub const COMMAND_PROCESS_READ_BIT_NVX: AccessFlags = 0x00020000;
    pub const COMMAND_PROCESS_WRITE_BIT_NVX: AccessFlags = 0x00040000;
    pub const COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: AccessFlags = 0x00080000;
    pub const SHADING_RATE_IMAGE_READ_BIT_NV: AccessFlags = 0x00800000;
    pub const ACCELERATION_STRUCTURE_READ_BIT_NV: AccessFlags = 0x00200000;
    pub const ACCELERATION_STRUCTURE_WRITE_BIT_NV: AccessFlags = 0x00400000;
    pub const FRAGMENT_DENSITY_MAP_READ_BIT_EXT: AccessFlags = 0x01000000;
};

pub const DependencyFlags = Flags;
pub const DependencyFlagBits = struct {
    pub const BY_REGION_BIT: DependencyFlags = 0x00000001;
    pub const DEVICE_GROUP_BIT: DependencyFlags = 0x00000004;
    pub const VIEW_LOCAL_BIT: DependencyFlags = 0x00000002;

    pub const VIEW_LOCAL_BIT_KHR = VIEW_LOCAL_BIT;
    pub const DEVICE_GROUP_BIT_KHR = DEVICE_GROUP_BIT;
};

pub const CommandPoolCreateFlags = Flags;
pub const CommandPoolCreateFlagBits = struct {
    pub const TRANSIENT_BIT: CommandPoolCreateFlags = 0x00000001;
    pub const RESET_COMMAND_BUFFER_BIT: CommandPoolCreateFlags = 0x00000002;
    pub const PROTECTED_BIT: CommandPoolCreateFlags = 0x00000004;
};

pub const CommandPoolResetFlags = Flags;
pub const CommandPoolResetFlagBits = struct {
    pub const RELEASE_RESOURCES_BIT: CommandPoolResetFlags = 0x00000001;
};

pub const CommandBufferUsageFlags = Flags;
pub const CommandBufferUsageFlagBits = struct {
    pub const ONE_TIME_SUBMIT_BIT: CommandBufferUsageFlags = 0x00000001;
    pub const RENDER_PASS_CONTINUE_BIT: CommandBufferUsageFlags = 0x00000002;
    pub const SIMULTANEOUS_USE_BIT: CommandBufferUsageFlags = 0x00000004;
};

pub const QueryControlFlags = Flags;
pub const QueryControlFlagBits = struct {
    pub const PRECISE_BIT: QueryControlFlags = 0x00000001;
};

pub const CommandBufferResetFlags = Flags;
pub const CommandBufferResetFlagBits = struct {
    pub const RELEASE_RESOURCES_BIT: CommandBufferResetFlags = 0x00000001;
};

pub const StencilFaceFlags = Flags;
pub const StencilFaceFlagBits = struct {
    pub const FRONT_BIT: StencilFaceFlags = 0x00000001;
    pub const BACK_BIT: StencilFaceFlags = 0x00000002;
    pub const FRONT_AND_BACK: StencilFaceFlags = 0x00000003;

    pub const STENCIL_FRONT_AND_BACK = FRONT_AND_BACK;
};

pub const ApplicationInfo = extern struct {
    sType: StructureType = .APPLICATION_INFO,
    pNext: ?*const c_void = null,
    pApplicationName: ?CString = null,
    applicationVersion: u32,
    pEngineName: ?CString = null,
    engineVersion: u32,
    apiVersion: u32,
};

pub const InstanceCreateInfo = extern struct {
    sType: StructureType = .INSTANCE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: InstanceCreateFlags = 0,
    pApplicationInfo: ?*const ApplicationInfo = null,
    enabledLayerCount: u32 = 0,
    ppEnabledLayerNames: [*]const CString = undefined,
    enabledExtensionCount: u32 = 0,
    ppEnabledExtensionNames: [*]const CString = undefined,
};

pub const PFN_AllocationFunction = extern fn (
    ?*c_void,
    usize,
    usize,
    SystemAllocationScope,
) ?*c_void;

pub const PFN_ReallocationFunction = extern fn (
    ?*c_void,
    ?*c_void,
    usize,
    usize,
    SystemAllocationScope,
) ?*c_void;

pub const PFN_FreeFunction = extern fn (
    ?*c_void,
    ?*c_void,
) void;

pub const PFN_InternalAllocationNotification = extern fn (
    ?*c_void,
    usize,
    InternalAllocationType,
    SystemAllocationScope,
) void;

pub const PFN_InternalFreeNotification = extern fn (
    ?*c_void,
    usize,
    InternalAllocationType,
    SystemAllocationScope,
) void;

pub const AllocationCallbacks = extern struct {
    pUserData: ?*c_void = null,
    pfnAllocation: PFN_AllocationFunction,
    pfnReallocation: PFN_ReallocationFunction,
    pfnFree: PFN_FreeFunction,
    pfnInternalAllocation: ?PFN_InternalAllocationNotification = null,
    pfnInternalFree: ?PFN_InternalFreeNotification = null,
};

pub const PhysicalDeviceFeatures = extern struct {
    robustBufferAccess: Bool32,
    fullDrawIndexUint32: Bool32,
    imageCubeArray: Bool32,
    independentBlend: Bool32,
    geometryShader: Bool32,
    tessellationShader: Bool32,
    sampleRateShading: Bool32,
    dualSrcBlend: Bool32,
    logicOp: Bool32,
    multiDrawIndirect: Bool32,
    drawIndirectFirstInstance: Bool32,
    depthClamp: Bool32,
    depthBiasClamp: Bool32,
    fillModeNonSolid: Bool32,
    depthBounds: Bool32,
    wideLines: Bool32,
    largePoints: Bool32,
    alphaToOne: Bool32,
    multiViewport: Bool32,
    samplerAnisotropy: Bool32,
    textureCompressionETC2: Bool32,
    textureCompressionASTC_LDR: Bool32,
    textureCompressionBC: Bool32,
    occlusionQueryPrecise: Bool32,
    pipelineStatisticsQuery: Bool32,
    vertexPipelineStoresAndAtomics: Bool32,
    fragmentStoresAndAtomics: Bool32,
    shaderTessellationAndGeometryPointSize: Bool32,
    shaderImageGatherExtended: Bool32,
    shaderStorageImageExtendedFormats: Bool32,
    shaderStorageImageMultisample: Bool32,
    shaderStorageImageReadWithoutFormat: Bool32,
    shaderStorageImageWriteWithoutFormat: Bool32,
    shaderUniformBufferArrayDynamicIndexing: Bool32,
    shaderSampledImageArrayDynamicIndexing: Bool32,
    shaderStorageBufferArrayDynamicIndexing: Bool32,
    shaderStorageImageArrayDynamicIndexing: Bool32,
    shaderClipDistance: Bool32,
    shaderCullDistance: Bool32,
    shaderFloat64: Bool32,
    shaderInt64: Bool32,
    shaderInt16: Bool32,
    shaderResourceResidency: Bool32,
    shaderResourceMinLod: Bool32,
    sparseBinding: Bool32,
    sparseResidencyBuffer: Bool32,
    sparseResidencyImage2D: Bool32,
    sparseResidencyImage3D: Bool32,
    sparseResidency2Samples: Bool32,
    sparseResidency4Samples: Bool32,
    sparseResidency8Samples: Bool32,
    sparseResidency16Samples: Bool32,
    sparseResidencyAliased: Bool32,
    variableMultisampleRate: Bool32,
    inheritedQueries: Bool32,
};

pub const FormatProperties = extern struct {
    linearTilingFeatures: FormatFeatureFlags = 0,
    optimalTilingFeatures: FormatFeatureFlags = 0,
    bufferFeatures: FormatFeatureFlags = 0,
};

pub const Extent3D = extern struct {
    width: u32,
    height: u32,
    depth: u32,
};

pub const ImageFormatProperties = extern struct {
    maxExtent: Extent3D,
    maxMipLevels: u32,
    maxArrayLayers: u32,
    sampleCounts: SampleCountFlags = 0,
    maxResourceSize: DeviceSize,
};

pub const PhysicalDeviceLimits = extern struct {
    maxImageDimension1D: u32,
    maxImageDimension2D: u32,
    maxImageDimension3D: u32,
    maxImageDimensionCube: u32,
    maxImageArrayLayers: u32,
    maxTexelBufferElements: u32,
    maxUniformBufferRange: u32,
    maxStorageBufferRange: u32,
    maxPushConstantsSize: u32,
    maxMemoryAllocationCount: u32,
    maxSamplerAllocationCount: u32,
    bufferImageGranularity: DeviceSize,
    sparseAddressSpaceSize: DeviceSize,
    maxBoundDescriptorSets: u32,
    maxPerStageDescriptorSamplers: u32,
    maxPerStageDescriptorUniformBuffers: u32,
    maxPerStageDescriptorStorageBuffers: u32,
    maxPerStageDescriptorSampledImages: u32,
    maxPerStageDescriptorStorageImages: u32,
    maxPerStageDescriptorInputAttachments: u32,
    maxPerStageResources: u32,
    maxDescriptorSetSamplers: u32,
    maxDescriptorSetUniformBuffers: u32,
    maxDescriptorSetUniformBuffersDynamic: u32,
    maxDescriptorSetStorageBuffers: u32,
    maxDescriptorSetStorageBuffersDynamic: u32,
    maxDescriptorSetSampledImages: u32,
    maxDescriptorSetStorageImages: u32,
    maxDescriptorSetInputAttachments: u32,
    maxVertexInputAttributes: u32,
    maxVertexInputBindings: u32,
    maxVertexInputAttributeOffset: u32,
    maxVertexInputBindingStride: u32,
    maxVertexOutputComponents: u32,
    maxTessellationGenerationLevel: u32,
    maxTessellationPatchSize: u32,
    maxTessellationControlPerVertexInputComponents: u32,
    maxTessellationControlPerVertexOutputComponents: u32,
    maxTessellationControlPerPatchOutputComponents: u32,
    maxTessellationControlTotalOutputComponents: u32,
    maxTessellationEvaluationInputComponents: u32,
    maxTessellationEvaluationOutputComponents: u32,
    maxGeometryShaderInvocations: u32,
    maxGeometryInputComponents: u32,
    maxGeometryOutputComponents: u32,
    maxGeometryOutputVertices: u32,
    maxGeometryTotalOutputComponents: u32,
    maxFragmentInputComponents: u32,
    maxFragmentOutputAttachments: u32,
    maxFragmentDualSrcAttachments: u32,
    maxFragmentCombinedOutputResources: u32,
    maxComputeSharedMemorySize: u32,
    maxComputeWorkGroupCount: [3]u32,
    maxComputeWorkGroupInvocations: u32,
    maxComputeWorkGroupSize: [3]u32,
    subPixelPrecisionBits: u32,
    subTexelPrecisionBits: u32,
    mipmapPrecisionBits: u32,
    maxDrawIndexedIndexValue: u32,
    maxDrawIndirectCount: u32,
    maxSamplerLodBias: f32,
    maxSamplerAnisotropy: f32,
    maxViewports: u32,
    maxViewportDimensions: [2]u32,
    viewportBoundsRange: [2]f32,
    viewportSubPixelBits: u32,
    minMemoryMapAlignment: usize,
    minTexelBufferOffsetAlignment: DeviceSize,
    minUniformBufferOffsetAlignment: DeviceSize,
    minStorageBufferOffsetAlignment: DeviceSize,
    minTexelOffset: i32,
    maxTexelOffset: u32,
    minTexelGatherOffset: i32,
    maxTexelGatherOffset: u32,
    minInterpolationOffset: f32,
    maxInterpolationOffset: f32,
    subPixelInterpolationOffsetBits: u32,
    maxFramebufferWidth: u32,
    maxFramebufferHeight: u32,
    maxFramebufferLayers: u32,
    framebufferColorSampleCounts: SampleCountFlags = 0,
    framebufferDepthSampleCounts: SampleCountFlags = 0,
    framebufferStencilSampleCounts: SampleCountFlags = 0,
    framebufferNoAttachmentsSampleCounts: SampleCountFlags = 0,
    maxColorAttachments: u32,
    sampledImageColorSampleCounts: SampleCountFlags = 0,
    sampledImageIntegerSampleCounts: SampleCountFlags = 0,
    sampledImageDepthSampleCounts: SampleCountFlags = 0,
    sampledImageStencilSampleCounts: SampleCountFlags = 0,
    storageImageSampleCounts: SampleCountFlags = 0,
    maxSampleMaskWords: u32,
    timestampComputeAndGraphics: Bool32,
    timestampPeriod: f32,
    maxClipDistances: u32,
    maxCullDistances: u32,
    maxCombinedClipAndCullDistances: u32,
    discreteQueuePriorities: u32,
    pointSizeRange: [2]f32,
    lineWidthRange: [2]f32,
    pointSizeGranularity: f32,
    lineWidthGranularity: f32,
    strictLines: Bool32,
    standardSampleLocations: Bool32,
    optimalBufferCopyOffsetAlignment: DeviceSize,
    optimalBufferCopyRowPitchAlignment: DeviceSize,
    nonCoherentAtomSize: DeviceSize,
};

pub const PhysicalDeviceSparseProperties = extern struct {
    residencyStandard2DBlockShape: Bool32,
    residencyStandard2DMultisampleBlockShape: Bool32,
    residencyStandard3DBlockShape: Bool32,
    residencyAlignedMipSize: Bool32,
    residencyNonResidentStrict: Bool32,
};

pub const PhysicalDeviceProperties = extern struct {
    apiVersion: u32,
    driverVersion: u32,
    vendorID: u32,
    deviceID: u32,
    deviceType: PhysicalDeviceType,
    deviceName: [MAX_PHYSICAL_DEVICE_NAME_SIZE]u8,
    pipelineCacheUUID: [UUID_SIZE]u8,
    limits: PhysicalDeviceLimits,
    sparseProperties: PhysicalDeviceSparseProperties,
};

pub const QueueFamilyProperties = extern struct {
    queueFlags: QueueFlags = 0,
    queueCount: u32,
    timestampValidBits: u32,
    minImageTransferGranularity: Extent3D,
};

pub const MemoryType = extern struct {
    propertyFlags: MemoryPropertyFlags = 0,
    heapIndex: u32,
};

pub const MemoryHeap = extern struct {
    size: DeviceSize,
    flags: MemoryHeapFlags = 0,
};

pub const PhysicalDeviceMemoryProperties = extern struct {
    memoryTypeCount: u32,
    memoryTypes: [MAX_MEMORY_TYPES]MemoryType,
    memoryHeapCount: u32,
    memoryHeaps: [MAX_MEMORY_HEAPS]MemoryHeap,
};

pub const PFN_VoidFunction = extern fn () void;

pub const DeviceQueueCreateInfo = extern struct {
    sType: StructureType = .DEVICE_QUEUE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DeviceQueueCreateFlags = 0,
    queueFamilyIndex: u32,
    queueCount: u32,
    pQueuePriorities: [*]const f32,
};

pub const DeviceCreateInfo = extern struct {
    sType: StructureType = .DEVICE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DeviceCreateFlags = 0,
    queueCreateInfoCount: u32,
    pQueueCreateInfos: [*]const DeviceQueueCreateInfo,
    enabledLayerCount: u32 = 0,
    ppEnabledLayerNames: [*]const CString = undefined,
    enabledExtensionCount: u32 = 0,
    ppEnabledExtensionNames: [*]const CString = undefined,
    pEnabledFeatures: ?*const PhysicalDeviceFeatures = null,
};

pub const ExtensionProperties = extern struct {
    extensionName: [MAX_EXTENSION_NAME_SIZE]u8,
    specVersion: u32,
};

pub const LayerProperties = extern struct {
    layerName: [MAX_EXTENSION_NAME_SIZE]u8,
    specVersion: u32,
    implementationVersion: u32,
    description: [MAX_DESCRIPTION_SIZE]u8,
};

pub const SubmitInfo = extern struct {
    sType: StructureType = .SUBMIT_INFO,
    pNext: ?*const c_void = null,
    waitSemaphoreCount: u32 = 0,
    pWaitSemaphores: [*]const Semaphore = undefined,
    pWaitDstStageMask: [*]const PipelineStageFlags = undefined,
    commandBufferCount: u32 = 0,
    pCommandBuffers: [*]const CommandBuffer = undefined,
    signalSemaphoreCount: u32 = 0,
    pSignalSemaphores: [*]const Semaphore = undefined,
};

pub const MemoryAllocateInfo = extern struct {
    sType: StructureType = .MEMORY_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    allocationSize: DeviceSize,
    memoryTypeIndex: u32,
};

pub const MappedMemoryRange = extern struct {
    sType: StructureType = .MAPPED_MEMORY_RANGE,
    pNext: ?*const c_void = null,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
};

pub const MemoryRequirements = extern struct {
    size: DeviceSize,
    alignment: DeviceSize,
    memoryTypeBits: u32,
};

pub const SparseImageFormatProperties = extern struct {
    aspectMask: ImageAspectFlags = 0,
    imageGranularity: Extent3D,
    flags: SparseImageFormatFlags = 0,
};

pub const SparseImageMemoryRequirements = extern struct {
    formatProperties: SparseImageFormatProperties,
    imageMipTailFirstLod: u32,
    imageMipTailSize: DeviceSize,
    imageMipTailOffset: DeviceSize,
    imageMipTailStride: DeviceSize,
};

pub const SparseMemoryBind = extern struct {
    resourceOffset: DeviceSize,
    size: DeviceSize,
    memory: ?DeviceMemory = null,
    memoryOffset: DeviceSize,
    flags: SparseMemoryBindFlags = 0,
};

pub const SparseBufferMemoryBindInfo = extern struct {
    buffer: Buffer,
    bindCount: u32,
    pBinds: [*]const SparseMemoryBind,
};

pub const SparseImageOpaqueMemoryBindInfo = extern struct {
    image: Image,
    bindCount: u32,
    pBinds: [*]const SparseMemoryBind,
};

pub const ImageSubresource = extern struct {
    aspectMask: ImageAspectFlags,
    mipLevel: u32,
    arrayLayer: u32,
};

pub const Offset3D = extern struct {
    x: i32,
    y: i32,
    z: i32,
};

pub const SparseImageMemoryBind = extern struct {
    subresource: ImageSubresource,
    offset: Offset3D,
    extent: Extent3D,
    memory: ?DeviceMemory = null,
    memoryOffset: DeviceSize,
    flags: SparseMemoryBindFlags = 0,
};

pub const SparseImageMemoryBindInfo = extern struct {
    image: Image,
    bindCount: u32,
    pBinds: [*]const SparseImageMemoryBind,
};

pub const BindSparseInfo = extern struct {
    sType: StructureType = .BIND_SPARSE_INFO,
    pNext: ?*const c_void = null,
    waitSemaphoreCount: u32 = 0,
    pWaitSemaphores: [*]const Semaphore = undefined,
    bufferBindCount: u32 = 0,
    pBufferBinds: [*]const SparseBufferMemoryBindInfo = undefined,
    imageOpaqueBindCount: u32 = 0,
    pImageOpaqueBinds: [*]const SparseImageOpaqueMemoryBindInfo = undefined,
    imageBindCount: u32 = 0,
    pImageBinds: [*]const SparseImageMemoryBindInfo = undefined,
    signalSemaphoreCount: u32 = 0,
    pSignalSemaphores: [*]const Semaphore = undefined,
};

pub const FenceCreateInfo = extern struct {
    sType: StructureType = .FENCE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: FenceCreateFlags = 0,
};

pub const SemaphoreCreateInfo = extern struct {
    sType: StructureType = .SEMAPHORE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: SemaphoreCreateFlags = 0,
};

pub const EventCreateInfo = extern struct {
    sType: StructureType = .EVENT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: EventCreateFlags = 0,
};

pub const QueryPoolCreateInfo = extern struct {
    sType: StructureType = .QUERY_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: QueryPoolCreateFlags = 0,
    queryType: QueryType,
    queryCount: u32,
    pipelineStatistics: QueryPipelineStatisticFlags = 0,
};

pub const BufferCreateInfo = extern struct {
    sType: StructureType = .BUFFER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: BufferCreateFlags = 0,
    size: DeviceSize,
    usage: BufferUsageFlags,
    sharingMode: SharingMode,
    queueFamilyIndexCount: u32 = 0,
    pQueueFamilyIndices: [*]const u32 = undefined,
};

pub const BufferViewCreateInfo = extern struct {
    sType: StructureType = .BUFFER_VIEW_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: BufferViewCreateFlags = 0,
    buffer: Buffer,
    format: Format,
    offset: DeviceSize,
    range: DeviceSize,
};

pub const ImageCreateInfo = extern struct {
    sType: StructureType = .IMAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ImageCreateFlags = 0,
    imageType: ImageType,
    format: Format,
    extent: Extent3D,
    mipLevels: u32,
    arrayLayers: u32,
    samples: SampleCountFlags,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    sharingMode: SharingMode,
    queueFamilyIndexCount: u32 = 0,
    pQueueFamilyIndices: [*]const u32 = undefined,
    initialLayout: ImageLayout,
};

pub const SubresourceLayout = extern struct {
    offset: DeviceSize,
    size: DeviceSize,
    rowPitch: DeviceSize,
    arrayPitch: DeviceSize,
    depthPitch: DeviceSize,
};

pub const ComponentMapping = extern struct {
    r: ComponentSwizzle,
    g: ComponentSwizzle,
    b: ComponentSwizzle,
    a: ComponentSwizzle,
};

pub const ImageSubresourceRange = extern struct {
    aspectMask: ImageAspectFlags,
    baseMipLevel: u32,
    levelCount: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageViewCreateInfo = extern struct {
    sType: StructureType = .IMAGE_VIEW_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ImageViewCreateFlags = 0,
    image: Image,
    viewType: ImageViewType,
    format: Format,
    components: ComponentMapping,
    subresourceRange: ImageSubresourceRange,
};

pub const ShaderModuleCreateInfo = extern struct {
    sType: StructureType = .SHADER_MODULE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ShaderModuleCreateFlags = 0,
    codeSize: usize,
    pCode: [*]const u32,
};

pub const PipelineCacheCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_CACHE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCacheCreateFlags = 0,
    initialDataSize: usize = 0,
    pInitialData: ?*const c_void = undefined,
};

pub const SpecializationMapEntry = extern struct {
    constantID: u32,
    offset: u32,
    size: usize,
};

pub const SpecializationInfo = extern struct {
    mapEntryCount: u32 = 0,
    pMapEntries: [*]const SpecializationMapEntry = undefined,
    dataSize: usize = 0,
    pData: ?*const c_void = undefined,
};

pub const PipelineShaderStageCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_SHADER_STAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineShaderStageCreateFlags = 0,
    stage: ShaderStageFlags,
    module: ShaderModule,
    pName: CString,
    pSpecializationInfo: ?*const SpecializationInfo = null,
};

pub const VertexInputBindingDescription = extern struct {
    binding: u32,
    stride: u32,
    inputRate: VertexInputRate,
};

pub const VertexInputAttributeDescription = extern struct {
    location: u32,
    binding: u32,
    format: Format,
    offset: u32,
};

pub const PipelineVertexInputStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineVertexInputStateCreateFlags = 0,
    vertexBindingDescriptionCount: u32 = 0,
    pVertexBindingDescriptions: [*]const VertexInputBindingDescription = undefined,
    vertexAttributeDescriptionCount: u32 = 0,
    pVertexAttributeDescriptions: [*]const VertexInputAttributeDescription = undefined,
};

pub const PipelineInputAssemblyStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineInputAssemblyStateCreateFlags = 0,
    topology: PrimitiveTopology,
    primitiveRestartEnable: Bool32,
};

pub const PipelineTessellationStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineTessellationStateCreateFlags = 0,
    patchControlPoints: u32,
};

pub const Viewport = extern struct {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    minDepth: f32,
    maxDepth: f32,
};

pub const Offset2D = extern struct {
    x: i32,
    y: i32,
};

pub const Extent2D = extern struct {
    width: u32,
    height: u32,
};

pub const Rect2D = extern struct {
    offset: Offset2D,
    extent: Extent2D,
};

pub const PipelineViewportStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineViewportStateCreateFlags = 0,
    viewportCount: u32,
    pViewports: ?[*]const Viewport = null,
    scissorCount: u32,
    pScissors: ?[*]const Rect2D = null,
};

pub const PipelineRasterizationStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineRasterizationStateCreateFlags = 0,
    depthClampEnable: Bool32,
    rasterizerDiscardEnable: Bool32,
    polygonMode: PolygonMode,
    cullMode: CullModeFlags = 0,
    frontFace: FrontFace,
    depthBiasEnable: Bool32,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
    lineWidth: f32,
};

pub const PipelineMultisampleStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineMultisampleStateCreateFlags = 0,
    rasterizationSamples: SampleCountFlags,
    sampleShadingEnable: Bool32,
    minSampleShading: f32,
    pSampleMask: ?[*]const SampleMask = null,
    alphaToCoverageEnable: Bool32,
    alphaToOneEnable: Bool32,
};

pub const StencilOpState = extern struct {
    failOp: StencilOp,
    passOp: StencilOp,
    depthFailOp: StencilOp,
    compareOp: CompareOp,
    compareMask: u32,
    writeMask: u32,
    reference: u32,
};

pub const PipelineDepthStencilStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineDepthStencilStateCreateFlags = 0,
    depthTestEnable: Bool32,
    depthWriteEnable: Bool32,
    depthCompareOp: CompareOp,
    depthBoundsTestEnable: Bool32,
    stencilTestEnable: Bool32,
    front: StencilOpState,
    back: StencilOpState,
    minDepthBounds: f32,
    maxDepthBounds: f32,
};

pub const PipelineColorBlendAttachmentState = extern struct {
    blendEnable: Bool32,
    srcColorBlendFactor: BlendFactor,
    dstColorBlendFactor: BlendFactor,
    colorBlendOp: BlendOp,
    srcAlphaBlendFactor: BlendFactor,
    dstAlphaBlendFactor: BlendFactor,
    alphaBlendOp: BlendOp,
    colorWriteMask: ColorComponentFlags = 0,
};

pub const PipelineColorBlendStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineColorBlendStateCreateFlags = 0,
    logicOpEnable: Bool32,
    logicOp: LogicOp,
    attachmentCount: u32 = 0,
    pAttachments: [*]const PipelineColorBlendAttachmentState = undefined,
    blendConstants: [4]f32,
};

pub const PipelineDynamicStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineDynamicStateCreateFlags = 0,
    dynamicStateCount: u32 = 0,
    pDynamicStates: [*]const DynamicState = undefined,
};

pub const GraphicsPipelineCreateInfo = extern struct {
    sType: StructureType = .GRAPHICS_PIPELINE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCreateFlags = 0,
    stageCount: u32,
    pStages: [*]const PipelineShaderStageCreateInfo,
    pVertexInputState: ?*const PipelineVertexInputStateCreateInfo = null,
    pInputAssemblyState: ?*const PipelineInputAssemblyStateCreateInfo = null,
    pTessellationState: ?*const PipelineTessellationStateCreateInfo = null,
    pViewportState: ?*const PipelineViewportStateCreateInfo = null,
    pRasterizationState: *const PipelineRasterizationStateCreateInfo,
    pMultisampleState: ?*const PipelineMultisampleStateCreateInfo = null,
    pDepthStencilState: ?*const PipelineDepthStencilStateCreateInfo = null,
    pColorBlendState: ?*const PipelineColorBlendStateCreateInfo = null,
    pDynamicState: ?*const PipelineDynamicStateCreateInfo = null,
    layout: PipelineLayout,
    renderPass: RenderPass,
    subpass: u32,
    basePipelineHandle: ?Pipeline = null,
    basePipelineIndex: i32,
};

pub const ComputePipelineCreateInfo = extern struct {
    sType: StructureType = .COMPUTE_PIPELINE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCreateFlags = 0,
    stage: PipelineShaderStageCreateInfo,
    layout: PipelineLayout,
    basePipelineHandle: ?Pipeline = null,
    basePipelineIndex: i32,
};

pub const PushConstantRange = extern struct {
    stageFlags: ShaderStageFlags,
    offset: u32,
    size: u32,
};

pub const PipelineLayoutCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_LAYOUT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineLayoutCreateFlags = 0,
    setLayoutCount: u32 = 0,
    pSetLayouts: [*]const DescriptorSetLayout = undefined,
    pushConstantRangeCount: u32 = 0,
    pPushConstantRanges: [*]const PushConstantRange = undefined,
};

pub const SamplerCreateInfo = extern struct {
    sType: StructureType = .SAMPLER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: SamplerCreateFlags = 0,
    magFilter: Filter,
    minFilter: Filter,
    mipmapMode: SamplerMipmapMode,
    addressModeU: SamplerAddressMode,
    addressModeV: SamplerAddressMode,
    addressModeW: SamplerAddressMode,
    mipLodBias: f32,
    anisotropyEnable: Bool32,
    maxAnisotropy: f32,
    compareEnable: Bool32,
    compareOp: CompareOp,
    minLod: f32,
    maxLod: f32,
    borderColor: BorderColor,
    unnormalizedCoordinates: Bool32,
};

pub const DescriptorSetLayoutBinding = extern struct {
    binding: u32,
    descriptorType: DescriptorType,
    descriptorCount: u32 = 0,
    stageFlags: ShaderStageFlags,
    pImmutableSamplers: ?[*]const Sampler = null,
};

pub const DescriptorSetLayoutCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DescriptorSetLayoutCreateFlags = 0,
    bindingCount: u32 = 0,
    pBindings: [*]const DescriptorSetLayoutBinding = undefined,
};

pub const DescriptorPoolSize = extern struct {
    inType: DescriptorType,
    descriptorCount: u32,
};

pub const DescriptorPoolCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DescriptorPoolCreateFlags = 0,
    maxSets: u32,
    poolSizeCount: u32,
    pPoolSizes: [*]const DescriptorPoolSize,
};

pub const DescriptorSetAllocateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    descriptorPool: DescriptorPool,
    descriptorSetCount: u32,
    pSetLayouts: [*]const DescriptorSetLayout,
};

pub const DescriptorImageInfo = extern struct {
    sampler: Sampler,
    imageView: ImageView,
    imageLayout: ImageLayout,
};

pub const DescriptorBufferInfo = extern struct {
    buffer: Buffer,
    offset: DeviceSize,
    range: DeviceSize,
};

pub const WriteDescriptorSet = extern struct {
    sType: StructureType = .WRITE_DESCRIPTOR_SET,
    pNext: ?*const c_void = null,
    dstSet: DescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
    descriptorType: DescriptorType,
    pImageInfo: [*]const DescriptorImageInfo,
    pBufferInfo: [*]const DescriptorBufferInfo,
    pTexelBufferView: [*]const BufferView,
};

pub const CopyDescriptorSet = extern struct {
    sType: StructureType = .COPY_DESCRIPTOR_SET,
    pNext: ?*const c_void = null,
    srcSet: DescriptorSet,
    srcBinding: u32,
    srcArrayElement: u32,
    dstSet: DescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
};

pub const FramebufferCreateInfo = extern struct {
    sType: StructureType = .FRAMEBUFFER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: FramebufferCreateFlags = 0,
    renderPass: RenderPass,
    attachmentCount: u32 = 0,
    pAttachments: [*]const ImageView = undefined,
    width: u32,
    height: u32,
    layers: u32,
};

pub const AttachmentDescription = extern struct {
    flags: AttachmentDescriptionFlags = 0,
    format: Format,
    samples: SampleCountFlags,
    loadOp: AttachmentLoadOp,
    storeOp: AttachmentStoreOp,
    stencilLoadOp: AttachmentLoadOp,
    stencilStoreOp: AttachmentStoreOp,
    initialLayout: ImageLayout,
    finalLayout: ImageLayout,
};

pub const AttachmentReference = extern struct {
    attachment: u32,
    layout: ImageLayout,
};

pub const SubpassDescription = extern struct {
    flags: SubpassDescriptionFlags = 0,
    pipelineBindPoint: PipelineBindPoint,
    inputAttachmentCount: u32 = 0,
    pInputAttachments: [*]const AttachmentReference = undefined,
    colorAttachmentCount: u32 = 0,
    pColorAttachments: [*]const AttachmentReference = undefined,
    pResolveAttachments: ?[*]const AttachmentReference = null,
    pDepthStencilAttachment: ?*const AttachmentReference = null,
    preserveAttachmentCount: u32 = 0,
    pPreserveAttachments: [*]const u32 = undefined,
};

pub const SubpassDependency = extern struct {
    srcSubpass: u32,
    dstSubpass: u32,
    srcStageMask: PipelineStageFlags,
    dstStageMask: PipelineStageFlags,
    srcAccessMask: AccessFlags = 0,
    dstAccessMask: AccessFlags = 0,
    dependencyFlags: DependencyFlags = 0,
};

pub const RenderPassCreateInfo = extern struct {
    sType: StructureType = .RENDER_PASS_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: RenderPassCreateFlags = 0,
    attachmentCount: u32 = 0,
    pAttachments: [*]const AttachmentDescription = undefined,
    subpassCount: u32,
    pSubpasses: [*]const SubpassDescription,
    dependencyCount: u32 = 0,
    pDependencies: [*]const SubpassDependency = undefined,
};

pub const CommandPoolCreateInfo = extern struct {
    sType: StructureType = .COMMAND_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: CommandPoolCreateFlags = 0,
    queueFamilyIndex: u32,
};

pub const CommandBufferAllocateInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    commandPool: CommandPool,
    level: CommandBufferLevel,
    commandBufferCount: u32,
};

pub const CommandBufferInheritanceInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_INHERITANCE_INFO,
    pNext: ?*const c_void = null,
    renderPass: ?RenderPass = null,
    subpass: u32,
    framebuffer: ?Framebuffer = null,
    occlusionQueryEnable: Bool32,
    queryFlags: QueryControlFlags = 0,
    pipelineStatistics: QueryPipelineStatisticFlags = 0,
};

pub const CommandBufferBeginInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_BEGIN_INFO,
    pNext: ?*const c_void = null,
    flags: CommandBufferUsageFlags = 0,
    pInheritanceInfo: ?*const CommandBufferInheritanceInfo = null,
};

pub const BufferCopy = extern struct {
    srcOffset: DeviceSize,
    dstOffset: DeviceSize,
    size: DeviceSize,
};

pub const ImageSubresourceLayers = extern struct {
    aspectMask: ImageAspectFlags,
    mipLevel: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageCopy = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffset: Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffset: Offset3D,
    extent: Extent3D,
};

pub const ImageBlit = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffsets: [2]Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffsets: [2]Offset3D,
};

pub const BufferImageCopy = extern struct {
    bufferOffset: DeviceSize,
    bufferRowLength: u32,
    bufferImageHeight: u32,
    imageSubresource: ImageSubresourceLayers,
    imageOffset: Offset3D,
    imageExtent: Extent3D,
};

pub const ClearColorValue = extern union {
    float32: [4]f32,
    int32: [4]i32,
    uint32: [4]u32,
};

pub const ClearDepthStencilValue = extern struct {
    depth: f32,
    stencil: u32,
};

pub const ClearValue = extern union {
    color: ClearColorValue,
    depthStencil: ClearDepthStencilValue,
};

pub const ClearAttachment = extern struct {
    aspectMask: ImageAspectFlags,
    colorAttachment: u32,
    clearValue: ClearValue,
};

pub const ClearRect = extern struct {
    rect: Rect2D,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageResolve = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffset: Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffset: Offset3D,
    extent: Extent3D,
};

pub const MemoryBarrier = extern struct {
    sType: StructureType = .MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags = 0,
    dstAccessMask: AccessFlags = 0,
};

pub const BufferMemoryBarrier = extern struct {
    sType: StructureType = .BUFFER_MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
};

pub const ImageMemoryBarrier = extern struct {
    sType: StructureType = .IMAGE_MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
    oldLayout: ImageLayout,
    newLayout: ImageLayout,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    image: Image,
    subresourceRange: ImageSubresourceRange,
};

pub const RenderPassBeginInfo = extern struct {
    sType: StructureType = .RENDER_PASS_BEGIN_INFO,
    pNext: ?*const c_void = null,
    renderPass: RenderPass,
    framebuffer: Framebuffer,
    renderArea: Rect2D,
    clearValueCount: u32 = 0,
    pClearValues: [*]const ClearValue = undefined,
};

pub const DispatchIndirectCommand = extern struct {
    x: u32,
    y: u32,
    z: u32,
};

pub const DrawIndexedIndirectCommand = extern struct {
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: i32,
    firstInstance: u32,
};

pub const DrawIndirectCommand = extern struct {
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
};

pub const BaseOutStructure = extern struct {
    sType: StructureType,
    pNext: *@This(),
};

pub const BaseInStructure = extern struct {
    sType: StructureType,
    pNext: *const @This(),
};

pub extern fn vkCreateInstance(
    pCreateInfo: *const InstanceCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pInstance: *Instance,
) Result;

pub extern fn vkDestroyInstance(
    instance: ?Instance,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkEnumeratePhysicalDevices(
    instance: Instance,
    pPhysicalDeviceCount: *u32,
    pPhysicalDevices: ?[*]PhysicalDevice,
) Result;

pub extern fn vkGetPhysicalDeviceFeatures(
    physicalDevice: PhysicalDevice,
    pFeatures: *PhysicalDeviceFeatures,
) void;

pub extern fn vkGetPhysicalDeviceFormatProperties(
    physicalDevice: PhysicalDevice,
    format: Format,
    pFormatProperties: *FormatProperties,
) void;

pub extern fn vkGetPhysicalDeviceImageFormatProperties(
    physicalDevice: PhysicalDevice,
    format: Format,
    inType: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    pImageFormatProperties: *ImageFormatProperties,
) Result;

pub extern fn vkGetPhysicalDeviceProperties(
    physicalDevice: PhysicalDevice,
    pProperties: *PhysicalDeviceProperties,
) void;

pub extern fn vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice: PhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    pQueueFamilyProperties: ?[*]QueueFamilyProperties,
) void;

pub extern fn vkGetPhysicalDeviceMemoryProperties(
    physicalDevice: PhysicalDevice,
    pMemoryProperties: *PhysicalDeviceMemoryProperties,
) void;

pub extern fn vkGetInstanceProcAddr(
    instance: ?Instance,
    pName: CString,
) PFN_VoidFunction;

pub extern fn vkGetDeviceProcAddr(
    device: Device,
    pName: CString,
) PFN_VoidFunction;

pub extern fn vkCreateDevice(
    physicalDevice: PhysicalDevice,
    pCreateInfo: *const DeviceCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pDevice: *Device,
) Result;

pub extern fn vkDestroyDevice(
    device: ?Device,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkEnumerateInstanceExtensionProperties(
    pLayerName: ?CString,
    pPropertyCount: *u32,
    pProperties: ?[*]ExtensionProperties,
) Result;

pub extern fn vkEnumerateDeviceExtensionProperties(
    physicalDevice: PhysicalDevice,
    pLayerName: ?CString,
    pPropertyCount: *u32,
    pProperties: ?[*]ExtensionProperties,
) Result;

pub extern fn vkEnumerateInstanceLayerProperties(
    pPropertyCount: *u32,
    pProperties: ?[*]LayerProperties,
) Result;

pub extern fn vkEnumerateDeviceLayerProperties(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]LayerProperties,
) Result;

pub extern fn vkGetDeviceQueue(
    device: Device,
    queueFamilyIndex: u32,
    queueIndex: u32,
    pQueue: *Queue,
) void;

pub extern fn vkQueueSubmit(
    queue: Queue,
    submitCount: u32,
    pSubmits: [*]const SubmitInfo,
    fence: ?Fence,
) Result;

pub extern fn vkQueueWaitIdle(queue: Queue) Result;
pub extern fn vkDeviceWaitIdle(device: Device) Result;

pub extern fn vkAllocateMemory(
    device: Device,
    pAllocateInfo: *const MemoryAllocateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pMemory: *DeviceMemory,
) Result;

pub extern fn vkFreeMemory(
    device: Device,
    memory: ?DeviceMemory,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkMapMemory(
    device: Device,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
    flags: MemoryMapFlags,
    ppData: ?**c_void,
) Result;

pub extern fn vkUnmapMemory(
    device: Device,
    memory: DeviceMemory,
) void;

pub extern fn vkFlushMappedMemoryRanges(
    device: Device,
    memoryRangeCount: u32,
    pMemoryRanges: [*]const MappedMemoryRange,
) Result;

pub extern fn vkInvalidateMappedMemoryRanges(
    device: Device,
    memoryRangeCount: u32,
    pMemoryRanges: [*]const MappedMemoryRange,
) Result;

pub extern fn vkGetDeviceMemoryCommitment(
    device: Device,
    memory: DeviceMemory,
    pCommittedMemoryInBytes: *DeviceSize,
) void;

pub extern fn vkBindBufferMemory(
    device: Device,
    buffer: Buffer,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
) Result;

pub extern fn vkBindImageMemory(
    device: Device,
    image: Image,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
) Result;

pub extern fn vkGetBufferMemoryRequirements(
    device: Device,
    buffer: Buffer,
    pMemoryRequirements: *MemoryRequirements,
) void;

pub extern fn vkGetImageMemoryRequirements(
    device: Device,
    image: Image,
    pMemoryRequirements: *MemoryRequirements,
) void;

pub extern fn vkGetImageSparseMemoryRequirements(
    device: Device,
    image: Image,
    pSparseMemoryRequirementCount: *u32,
    pSparseMemoryRequirements: ?[*]SparseImageMemoryRequirements,
) void;

pub extern fn vkGetPhysicalDeviceSparseImageFormatProperties(
    physicalDevice: PhysicalDevice,
    format: Format,
    inType: ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
    pPropertyCount: *u32,
    pProperties: ?[*]SparseImageFormatProperties,
) void;

pub extern fn vkQueueBindSparse(
    queue: Queue,
    bindInfoCount: u32,
    pBindInfo: [*]const BindSparseInfo,
    fence: ?Fence,
) Result;

pub extern fn vkCreateFence(
    device: Device,
    pCreateInfo: *const FenceCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pFence: *Fence,
) Result;

pub extern fn vkDestroyFence(
    device: Device,
    fence: ?Fence,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkResetFences(
    device: Device,
    fenceCount: u32,
    pFences: [*]const Fence,
) Result;

pub extern fn vkGetFenceStatus(
    device: Device,
    fence: Fence,
) Result;

pub extern fn vkWaitForFences(
    device: Device,
    fenceCount: u32,
    pFences: [*]const Fence,
    waitAll: Bool32,
    timeout: u64,
) Result;

pub extern fn vkCreateSemaphore(
    device: Device,
    pCreateInfo: *const SemaphoreCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pSemaphore: *Semaphore,
) Result;

pub extern fn vkDestroySemaphore(
    device: Device,
    semaphore: ?Semaphore,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateEvent(
    device: Device,
    pCreateInfo: *const EventCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pEvent: *Event,
) Result;

pub extern fn vkDestroyEvent(
    device: Device,
    event: ?Event,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetEventStatus(
    device: Device,
    event: Event,
) Result;

pub extern fn vkSetEvent(
    device: Device,
    event: Event,
) Result;

pub extern fn vkResetEvent(
    device: Device,
    event: Event,
) Result;

pub extern fn vkCreateQueryPool(
    device: Device,
    pCreateInfo: *const QueryPoolCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pQueryPool: *QueryPool,
) Result;

pub extern fn vkDestroyQueryPool(
    device: Device,
    queryPool: ?QueryPool,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetQueryPoolResults(
    device: Device,
    queryPool: QueryPool,
    firstQuery: u32,
    queryCount: u32,
    dataSize: usize,
    pData: ?*c_void,
    stride: DeviceSize,
    flags: QueryResultFlags,
) Result;

pub extern fn vkCreateBuffer(
    device: Device,
    pCreateInfo: *const BufferCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pBuffer: *Buffer,
) Result;

pub extern fn vkDestroyBuffer(
    device: Device,
    buffer: ?Buffer,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateBufferView(
    device: Device,
    pCreateInfo: *const BufferViewCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pView: *BufferView,
) Result;

pub extern fn vkDestroyBufferView(
    device: Device,
    bufferView: ?BufferView,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateImage(
    device: Device,
    pCreateInfo: *const ImageCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pImage: *Image,
) Result;

pub extern fn vkDestroyImage(
    device: Device,
    image: ?Image,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetImageSubresourceLayout(
    device: Device,
    image: Image,
    pSubresource: *const ImageSubresource,
    pLayout: *SubresourceLayout,
) void;

pub extern fn vkCreateImageView(
    device: Device,
    pCreateInfo: *const ImageViewCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pView: *ImageView,
) Result;

pub extern fn vkDestroyImageView(
    device: Device,
    imageView: ?ImageView,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateShaderModule(
    device: Device,
    pCreateInfo: *const ShaderModuleCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pShaderModule: *ShaderModule,
) Result;

pub extern fn vkDestroyShaderModule(
    device: Device,
    shaderModule: ?ShaderModule,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreatePipelineCache(
    device: Device,
    pCreateInfo: *const PipelineCacheCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pPipelineCache: *PipelineCache,
) Result;

pub extern fn vkDestroyPipelineCache(
    device: Device,
    pipelineCache: ?PipelineCache,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetPipelineCacheData(
    device: Device,
    pipelineCache: PipelineCache,
    pDataSize: *usize,
    pData: ?*c_void,
) Result;

pub extern fn vkMergePipelineCaches(
    device: Device,
    dstCache: PipelineCache,
    srcCacheCount: u32,
    pSrcCaches: [*]const PipelineCache,
) Result;

pub extern fn vkCreateGraphicsPipelines(
    device: Device,
    pipelineCache: ?PipelineCache,
    createInfoCount: u32,
    pCreateInfos: [*]const GraphicsPipelineCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pPipelines: [*]Pipeline,
) Result;

pub extern fn vkCreateComputePipelines(
    device: Device,
    pipelineCache: ?PipelineCache,
    createInfoCount: u32,
    pCreateInfos: [*]const ComputePipelineCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pPipelines: [*]Pipeline,
) Result;

pub extern fn vkDestroyPipeline(
    device: Device,
    pipeline: ?Pipeline,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreatePipelineLayout(
    device: Device,
    pCreateInfo: *const PipelineLayoutCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pPipelineLayout: *PipelineLayout,
) Result;

pub extern fn vkDestroyPipelineLayout(
    device: Device,
    pipelineLayout: ?PipelineLayout,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateSampler(
    device: Device,
    pCreateInfo: *const SamplerCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pSampler: *Sampler,
) Result;

pub extern fn vkDestroySampler(
    device: Device,
    sampler: ?Sampler,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateDescriptorSetLayout(
    device: Device,
    pCreateInfo: *const DescriptorSetLayoutCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pSetLayout: *DescriptorSetLayout,
) Result;

pub extern fn vkDestroyDescriptorSetLayout(
    device: Device,
    descriptorSetLayout: ?DescriptorSetLayout,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateDescriptorPool(
    device: Device,
    pCreateInfo: *const DescriptorPoolCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pDescriptorPool: *DescriptorPool,
) Result;

pub extern fn vkDestroyDescriptorPool(
    device: Device,
    descriptorPool: ?DescriptorPool,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkResetDescriptorPool(
    device: Device,
    descriptorPool: DescriptorPool,
    flags: DescriptorPoolResetFlags,
) Result;

pub extern fn vkAllocateDescriptorSets(
    device: Device,
    pAllocateInfo: *const DescriptorSetAllocateInfo,
    pDescriptorSets: [*]DescriptorSet,
) Result;

pub extern fn vkFreeDescriptorSets(
    device: Device,
    descriptorPool: DescriptorPool,
    descriptorSetCount: u32,
    pDescriptorSets: [*]const DescriptorSet,
) Result;

pub extern fn vkUpdateDescriptorSets(
    device: Device,
    descriptorWriteCount: u32,
    pDescriptorWrites: [*]const WriteDescriptorSet,
    descriptorCopyCount: u32,
    pDescriptorCopies: [*]const CopyDescriptorSet,
) void;

pub extern fn vkCreateFramebuffer(
    device: Device,
    pCreateInfo: *const FramebufferCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pFramebuffer: *Framebuffer,
) Result;

pub extern fn vkDestroyFramebuffer(
    device: Device,
    framebuffer: ?Framebuffer,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateRenderPass(
    device: Device,
    pCreateInfo: *const RenderPassCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pRenderPass: *RenderPass,
) Result;

pub extern fn vkDestroyRenderPass(
    device: Device,
    renderPass: ?RenderPass,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetRenderAreaGranularity(
    device: Device,
    renderPass: RenderPass,
    pGranularity: *Extent2D,
) void;

pub extern fn vkCreateCommandPool(
    device: Device,
    pCreateInfo: *const CommandPoolCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pCommandPool: *CommandPool,
) Result;

pub extern fn vkDestroyCommandPool(
    device: Device,
    commandPool: ?CommandPool,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkResetCommandPool(
    device: Device,
    commandPool: CommandPool,
    flags: CommandPoolResetFlags,
) Result;

pub extern fn vkAllocateCommandBuffers(
    device: Device,
    pAllocateInfo: *const CommandBufferAllocateInfo,
    pCommandBuffers: [*]CommandBuffer,
) Result;

pub extern fn vkFreeCommandBuffers(
    device: Device,
    commandPool: CommandPool,
    commandBufferCount: u32,
    pCommandBuffers: [*]const CommandBuffer,
) void;

pub extern fn vkBeginCommandBuffer(
    commandBuffer: CommandBuffer,
    pBeginInfo: *const CommandBufferBeginInfo,
) Result;

pub extern fn vkEndCommandBuffer(commandBuffer: CommandBuffer) Result;

pub extern fn vkResetCommandBuffer(
    commandBuffer: CommandBuffer,
    flags: CommandBufferResetFlags,
) Result;

pub extern fn vkCmdBindPipeline(
    commandBuffer: CommandBuffer,
    pipelineBindPoint: PipelineBindPoint,
    pipeline: Pipeline,
) void;

pub extern fn vkCmdSetViewport(
    commandBuffer: CommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    pViewports: [*]const Viewport,
) void;

pub extern fn vkCmdSetScissor(
    commandBuffer: CommandBuffer,
    firstScissor: u32,
    scissorCount: u32,
    pScissors: [*]const Rect2D,
) void;

pub extern fn vkCmdSetLineWidth(
    commandBuffer: CommandBuffer,
    lineWidth: f32,
) void;

pub extern fn vkCmdSetDepthBias(
    commandBuffer: CommandBuffer,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
) void;

pub extern fn vkCmdSetBlendConstants(
    commandBuffer: CommandBuffer,
    blendConstants: *const[4]f32,
) void;

pub extern fn vkCmdSetDepthBounds(
    commandBuffer: CommandBuffer,
    minDepthBounds: f32,
    maxDepthBounds: f32,
) void;

pub extern fn vkCmdSetStencilCompareMask(
    commandBuffer: CommandBuffer,
    faceMask: StencilFaceFlags,
    compareMask: u32,
) void;

pub extern fn vkCmdSetStencilWriteMask(
    commandBuffer: CommandBuffer,
    faceMask: StencilFaceFlags,
    writeMask: u32,
) void;

pub extern fn vkCmdSetStencilReference(
    commandBuffer: CommandBuffer,
    faceMask: StencilFaceFlags,
    reference: u32,
) void;

pub extern fn vkCmdBindDescriptorSets(
    commandBuffer: CommandBuffer,
    pipelineBindPoint: PipelineBindPoint,
    layout: PipelineLayout,
    firstSet: u32,
    descriptorSetCount: u32,
    pDescriptorSets: [*]const DescriptorSet,
    dynamicOffsetCount: u32,
    pDynamicOffsets: [*]const u32,
) void;

pub extern fn vkCmdBindIndexBuffer(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    indexType: IndexType,
) void;

pub extern fn vkCmdBindVertexBuffers(
    commandBuffer: CommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    pBuffers: [*]const Buffer,
    pOffsets: [*]const DeviceSize,
) void;

pub extern fn vkCmdDraw(
    commandBuffer: CommandBuffer,
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
) void;

pub extern fn vkCmdDrawIndexed(
    commandBuffer: CommandBuffer,
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: i32,
    firstInstance: u32,
) void;

pub extern fn vkCmdDrawIndirect(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    drawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDrawIndexedIndirect(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    drawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDispatch(
    commandBuffer: CommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) void;

pub extern fn vkCmdDispatchIndirect(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
) void;

pub extern fn vkCmdCopyBuffer(
    commandBuffer: CommandBuffer,
    srcBuffer: Buffer,
    dstBuffer: Buffer,
    regionCount: u32,
    pRegions: [*]const BufferCopy,
) void;

pub extern fn vkCmdCopyImage(
    commandBuffer: CommandBuffer,
    srcImage: Image,
    srcImageLayout: ImageLayout,
    dstImage: Image,
    dstImageLayout: ImageLayout,
    regionCount: u32,
    pRegions: [*]const ImageCopy,
) void;

pub extern fn vkCmdBlitImage(
    commandBuffer: CommandBuffer,
    srcImage: Image,
    srcImageLayout: ImageLayout,
    dstImage: Image,
    dstImageLayout: ImageLayout,
    regionCount: u32,
    pRegions: [*]const ImageBlit,
    filter: Filter,
) void;

pub extern fn vkCmdCopyBufferToImage(
    commandBuffer: CommandBuffer,
    srcBuffer: Buffer,
    dstImage: Image,
    dstImageLayout: ImageLayout,
    regionCount: u32,
    pRegions: [*]const BufferImageCopy,
) void;

pub extern fn vkCmdCopyImageToBuffer(
    commandBuffer: CommandBuffer,
    srcImage: Image,
    srcImageLayout: ImageLayout,
    dstBuffer: Buffer,
    regionCount: u32,
    pRegions: [*]const BufferImageCopy,
) void;

pub extern fn vkCmdUpdateBuffer(
    commandBuffer: CommandBuffer,
    dstBuffer: Buffer,
    dstOffset: DeviceSize,
    dataSize: DeviceSize,
    pData: ?*const c_void,
) void;

pub extern fn vkCmdFillBuffer(
    commandBuffer: CommandBuffer,
    dstBuffer: Buffer,
    dstOffset: DeviceSize,
    size: DeviceSize,
    data: u32,
) void;

pub extern fn vkCmdClearColorImage(
    commandBuffer: CommandBuffer,
    image: Image,
    imageLayout: ImageLayout,
    pColor: *const ClearColorValue,
    rangeCount: u32,
    pRanges: [*]const ImageSubresourceRange,
) void;

pub extern fn vkCmdClearDepthStencilImage(
    commandBuffer: CommandBuffer,
    image: Image,
    imageLayout: ImageLayout,
    pDepthStencil: *const ClearDepthStencilValue,
    rangeCount: u32,
    pRanges: [*]const ImageSubresourceRange,
) void;

pub extern fn vkCmdClearAttachments(
    commandBuffer: CommandBuffer,
    attachmentCount: u32,
    pAttachments: [*]const ClearAttachment,
    rectCount: u32,
    pRects: [*]const ClearRect,
) void;

pub extern fn vkCmdResolveImage(
    commandBuffer: CommandBuffer,
    srcImage: Image,
    srcImageLayout: ImageLayout,
    dstImage: Image,
    dstImageLayout: ImageLayout,
    regionCount: u32,
    pRegions: [*]const ImageResolve,
) void;

pub extern fn vkCmdSetEvent(
    commandBuffer: CommandBuffer,
    event: Event,
    stageMask: PipelineStageFlags,
) void;

pub extern fn vkCmdResetEvent(
    commandBuffer: CommandBuffer,
    event: Event,
    stageMask: PipelineStageFlags,
) void;

pub extern fn vkCmdWaitEvents(
    commandBuffer: CommandBuffer,
    eventCount: u32,
    pEvents: [*]const Event,
    srcStageMask: PipelineStageFlags,
    dstStageMask: PipelineStageFlags,
    memoryBarrierCount: u32,
    pMemoryBarriers: [*]const MemoryBarrier,
    bufferMemoryBarrierCount: u32,
    pBufferMemoryBarriers: [*]const BufferMemoryBarrier,
    imageMemoryBarrierCount: u32,
    pImageMemoryBarriers: [*]const ImageMemoryBarrier,
) void;

pub extern fn vkCmdPipelineBarrier(
    commandBuffer: CommandBuffer,
    srcStageMask: PipelineStageFlags,
    dstStageMask: PipelineStageFlags,
    dependencyFlags: DependencyFlags,
    memoryBarrierCount: u32,
    pMemoryBarriers: [*]const MemoryBarrier,
    bufferMemoryBarrierCount: u32,
    pBufferMemoryBarriers: [*]const BufferMemoryBarrier,
    imageMemoryBarrierCount: u32,
    pImageMemoryBarriers: [*]const ImageMemoryBarrier,
) void;

pub extern fn vkCmdBeginQuery(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
) void;

pub extern fn vkCmdEndQuery(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    query: u32,
) void;

pub extern fn vkCmdResetQueryPool(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    firstQuery: u32,
    queryCount: u32,
) void;

pub extern fn vkCmdWriteTimestamp(
    commandBuffer: CommandBuffer,
    pipelineStage: PipelineStageFlags,
    queryPool: QueryPool,
    query: u32,
) void;

pub extern fn vkCmdCopyQueryPoolResults(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    firstQuery: u32,
    queryCount: u32,
    dstBuffer: Buffer,
    dstOffset: DeviceSize,
    stride: DeviceSize,
    flags: QueryResultFlags,
) void;

pub extern fn vkCmdPushConstants(
    commandBuffer: CommandBuffer,
    layout: PipelineLayout,
    stageFlags: ShaderStageFlags,
    offset: u32,
    size: u32,
    pValues: ?*const c_void,
) void;

pub extern fn vkCmdBeginRenderPass(
    commandBuffer: CommandBuffer,
    pRenderPassBegin: *const RenderPassBeginInfo,
    contents: SubpassContents,
) void;

pub extern fn vkCmdNextSubpass(
    commandBuffer: CommandBuffer,
    contents: SubpassContents,
) void;

pub extern fn vkCmdEndRenderPass(commandBuffer: CommandBuffer) void;

pub extern fn vkCmdExecuteCommands(
    commandBuffer: CommandBuffer,
    commandBufferCount: u32,
    pCommandBuffers: [*]const CommandBuffer,
) void;

pub inline fn CreateInstance(createInfo: InstanceCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_LAYER_NOT_PRESENT,VK_EXTENSION_NOT_PRESENT,VK_INCOMPATIBLE_DRIVER,VK_UNDOCUMENTED_ERROR}!Instance {
    var out_instance: Instance = undefined;
    const result = vkCreateInstance(&createInfo, pAllocator, &out_instance);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            .ERROR_LAYER_NOT_PRESENT => error.VK_LAYER_NOT_PRESENT,
            .ERROR_EXTENSION_NOT_PRESENT => error.VK_EXTENSION_NOT_PRESENT,
            .ERROR_INCOMPATIBLE_DRIVER => error.VK_INCOMPATIBLE_DRIVER,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_instance;
}

pub const DestroyInstance = vkDestroyInstance;

pub const EnumeratePhysicalDevicesResult = struct {
    result: Result,
    physicalDevices: []PhysicalDevice,
};
pub inline fn EnumeratePhysicalDevices(instance: Instance, physicalDevices: []PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!EnumeratePhysicalDevicesResult {
    var returnValues: EnumeratePhysicalDevicesResult = undefined;
    var physicalDeviceCount: u32 = @intCast(u32, physicalDevices.len);
    const result = vkEnumeratePhysicalDevices(instance, &physicalDeviceCount, physicalDevices.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.physicalDevices = physicalDevices[0..physicalDeviceCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumeratePhysicalDevicesCount(instance: Instance) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_physicalDeviceCount: u32 = undefined;
    const result = vkEnumeratePhysicalDevices(instance, &out_physicalDeviceCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_physicalDeviceCount;
}

pub inline fn GetPhysicalDeviceFeatures(physicalDevice: PhysicalDevice) PhysicalDeviceFeatures {
    var out_features: PhysicalDeviceFeatures = undefined;
    vkGetPhysicalDeviceFeatures(physicalDevice, &out_features);
    return out_features;
}

pub inline fn GetPhysicalDeviceFormatProperties(physicalDevice: PhysicalDevice, format: Format) FormatProperties {
    var out_formatProperties: FormatProperties = undefined;
    vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &out_formatProperties);
    return out_formatProperties;
}

pub inline fn GetPhysicalDeviceImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, inType: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FORMAT_NOT_SUPPORTED,VK_UNDOCUMENTED_ERROR}!ImageFormatProperties {
    var out_imageFormatProperties: ImageFormatProperties = undefined;
    const result = vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, inType, tiling, usage, flags, &out_imageFormatProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FORMAT_NOT_SUPPORTED => error.VK_FORMAT_NOT_SUPPORTED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_imageFormatProperties;
}

pub inline fn GetPhysicalDeviceProperties(physicalDevice: PhysicalDevice) PhysicalDeviceProperties {
    var out_properties: PhysicalDeviceProperties = undefined;
    vkGetPhysicalDeviceProperties(physicalDevice, &out_properties);
    return out_properties;
}

pub inline fn GetPhysicalDeviceQueueFamilyProperties(physicalDevice: PhysicalDevice, queueFamilyProperties: []QueueFamilyProperties) []QueueFamilyProperties {
    var out_queueFamilyProperties: []QueueFamilyProperties = undefined;
    var queueFamilyPropertyCount: u32 = @intCast(u32, queueFamilyProperties.len);
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyPropertyCount, queueFamilyProperties.ptr);
    out_queueFamilyProperties = queueFamilyProperties[0..queueFamilyPropertyCount];
    return out_queueFamilyProperties;
}
pub inline fn GetPhysicalDeviceQueueFamilyPropertiesCount(physicalDevice: PhysicalDevice) u32 {
    var out_queueFamilyPropertyCount: u32 = undefined;
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &out_queueFamilyPropertyCount, null);
    return out_queueFamilyPropertyCount;
}

pub inline fn GetPhysicalDeviceMemoryProperties(physicalDevice: PhysicalDevice) PhysicalDeviceMemoryProperties {
    var out_memoryProperties: PhysicalDeviceMemoryProperties = undefined;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &out_memoryProperties);
    return out_memoryProperties;
}

pub const GetInstanceProcAddr = vkGetInstanceProcAddr;
pub const GetDeviceProcAddr = vkGetDeviceProcAddr;

pub inline fn CreateDevice(physicalDevice: PhysicalDevice, createInfo: DeviceCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_EXTENSION_NOT_PRESENT,VK_FEATURE_NOT_PRESENT,VK_TOO_MANY_OBJECTS,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Device {
    var out_device: Device = undefined;
    const result = vkCreateDevice(physicalDevice, &createInfo, pAllocator, &out_device);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            .ERROR_EXTENSION_NOT_PRESENT => error.VK_EXTENSION_NOT_PRESENT,
            .ERROR_FEATURE_NOT_PRESENT => error.VK_FEATURE_NOT_PRESENT,
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_device;
}

pub const DestroyDevice = vkDestroyDevice;

pub const EnumerateInstanceExtensionPropertiesResult = struct {
    result: Result,
    properties: []ExtensionProperties,
};
pub inline fn EnumerateInstanceExtensionProperties(pLayerName: ?CString, properties: []ExtensionProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_LAYER_NOT_PRESENT,VK_UNDOCUMENTED_ERROR}!EnumerateInstanceExtensionPropertiesResult {
    var returnValues: EnumerateInstanceExtensionPropertiesResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkEnumerateInstanceExtensionProperties(pLayerName, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_LAYER_NOT_PRESENT => error.VK_LAYER_NOT_PRESENT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumerateInstanceExtensionPropertiesCount(pLayerName: ?CString) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_LAYER_NOT_PRESENT,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkEnumerateInstanceExtensionProperties(pLayerName, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_LAYER_NOT_PRESENT => error.VK_LAYER_NOT_PRESENT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const EnumerateDeviceExtensionPropertiesResult = struct {
    result: Result,
    properties: []ExtensionProperties,
};
pub inline fn EnumerateDeviceExtensionProperties(physicalDevice: PhysicalDevice, pLayerName: ?CString, properties: []ExtensionProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_LAYER_NOT_PRESENT,VK_UNDOCUMENTED_ERROR}!EnumerateDeviceExtensionPropertiesResult {
    var returnValues: EnumerateDeviceExtensionPropertiesResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_LAYER_NOT_PRESENT => error.VK_LAYER_NOT_PRESENT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumerateDeviceExtensionPropertiesCount(physicalDevice: PhysicalDevice, pLayerName: ?CString) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_LAYER_NOT_PRESENT,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_LAYER_NOT_PRESENT => error.VK_LAYER_NOT_PRESENT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const EnumerateInstanceLayerPropertiesResult = struct {
    result: Result,
    properties: []LayerProperties,
};
pub inline fn EnumerateInstanceLayerProperties(properties: []LayerProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!EnumerateInstanceLayerPropertiesResult {
    var returnValues: EnumerateInstanceLayerPropertiesResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkEnumerateInstanceLayerProperties(&propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumerateInstanceLayerPropertiesCount() error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkEnumerateInstanceLayerProperties(&out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const EnumerateDeviceLayerPropertiesResult = struct {
    result: Result,
    properties: []LayerProperties,
};
pub inline fn EnumerateDeviceLayerProperties(physicalDevice: PhysicalDevice, properties: []LayerProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!EnumerateDeviceLayerPropertiesResult {
    var returnValues: EnumerateDeviceLayerPropertiesResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkEnumerateDeviceLayerProperties(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumerateDeviceLayerPropertiesCount(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkEnumerateDeviceLayerProperties(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub inline fn GetDeviceQueue(device: Device, queueFamilyIndex: u32, queueIndex: u32) Queue {
    var out_queue: Queue = undefined;
    vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &out_queue);
    return out_queue;
}

pub inline fn QueueSubmit(queue: Queue, submits: []const SubmitInfo, fence: ?Fence) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkQueueSubmit(queue, @intCast(u32, submits.len), submits.ptr, fence);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn QueueWaitIdle(queue: Queue) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkQueueWaitIdle(queue);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn DeviceWaitIdle(device: Device) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkDeviceWaitIdle(device);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn AllocateMemory(device: Device, allocateInfo: MemoryAllocateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_TOO_MANY_OBJECTS,VK_INVALID_EXTERNAL_HANDLE,VK_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_UNDOCUMENTED_ERROR}!DeviceMemory {
    var out_memory: DeviceMemory = undefined;
    const result = vkAllocateMemory(device, &allocateInfo, pAllocator, &out_memory);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_INVALID_EXTERNAL_HANDLE => error.VK_INVALID_EXTERNAL_HANDLE,
            .ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => error.VK_INVALID_OPAQUE_CAPTURE_ADDRESS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_memory;
}

pub const FreeMemory = vkFreeMemory;

pub inline fn MapMemory(device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: ?**c_void) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_MEMORY_MAP_FAILED,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkMapMemory(device, memory, offset, size, flags, ppData);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_MEMORY_MAP_FAILED => error.VK_MEMORY_MAP_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const UnmapMemory = vkUnmapMemory;

pub inline fn FlushMappedMemoryRanges(device: Device, memoryRanges: []const MappedMemoryRange) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkFlushMappedMemoryRanges(device, @intCast(u32, memoryRanges.len), memoryRanges.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn InvalidateMappedMemoryRanges(device: Device, memoryRanges: []const MappedMemoryRange) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkInvalidateMappedMemoryRanges(device, @intCast(u32, memoryRanges.len), memoryRanges.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetDeviceMemoryCommitment(device: Device, memory: DeviceMemory) DeviceSize {
    var out_committedMemoryInBytes: DeviceSize = undefined;
    vkGetDeviceMemoryCommitment(device, memory, &out_committedMemoryInBytes);
    return out_committedMemoryInBytes;
}

pub inline fn BindBufferMemory(device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindBufferMemory(device, buffer, memory, memoryOffset);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => error.VK_INVALID_OPAQUE_CAPTURE_ADDRESS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn BindImageMemory(device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindImageMemory(device, image, memory, memoryOffset);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetBufferMemoryRequirements(device: Device, buffer: Buffer) MemoryRequirements {
    var out_memoryRequirements: MemoryRequirements = undefined;
    vkGetBufferMemoryRequirements(device, buffer, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetImageMemoryRequirements(device: Device, image: Image) MemoryRequirements {
    var out_memoryRequirements: MemoryRequirements = undefined;
    vkGetImageMemoryRequirements(device, image, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetImageSparseMemoryRequirements(device: Device, image: Image, sparseMemoryRequirements: []SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
    var out_sparseMemoryRequirements: []SparseImageMemoryRequirements = undefined;
    var sparseMemoryRequirementCount: u32 = @intCast(u32, sparseMemoryRequirements.len);
    vkGetImageSparseMemoryRequirements(device, image, &sparseMemoryRequirementCount, sparseMemoryRequirements.ptr);
    out_sparseMemoryRequirements = sparseMemoryRequirements[0..sparseMemoryRequirementCount];
    return out_sparseMemoryRequirements;
}
pub inline fn GetImageSparseMemoryRequirementsCount(device: Device, image: Image) u32 {
    var out_sparseMemoryRequirementCount: u32 = undefined;
    vkGetImageSparseMemoryRequirements(device, image, &out_sparseMemoryRequirementCount, null);
    return out_sparseMemoryRequirementCount;
}

pub inline fn GetPhysicalDeviceSparseImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, inType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling, properties: []SparseImageFormatProperties) []SparseImageFormatProperties {
    var out_properties: []SparseImageFormatProperties = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, inType, samples, usage, tiling, &propertyCount, properties.ptr);
    out_properties = properties[0..propertyCount];
    return out_properties;
}
pub inline fn GetPhysicalDeviceSparseImageFormatPropertiesCount(physicalDevice: PhysicalDevice, format: Format, inType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling) u32 {
    var out_propertyCount: u32 = undefined;
    vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, inType, samples, usage, tiling, &out_propertyCount, null);
    return out_propertyCount;
}

pub inline fn QueueBindSparse(queue: Queue, bindInfo: []const BindSparseInfo, fence: ?Fence) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkQueueBindSparse(queue, @intCast(u32, bindInfo.len), bindInfo.ptr, fence);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CreateFence(device: Device, createInfo: FenceCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!Fence {
    var out_fence: Fence = undefined;
    const result = vkCreateFence(device, &createInfo, pAllocator, &out_fence);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_fence;
}

pub const DestroyFence = vkDestroyFence;

pub inline fn ResetFences(device: Device, fences: []const Fence) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkResetFences(device, @intCast(u32, fences.len), fences.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetFenceStatus(device: Device, fence: Fence) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkGetFenceStatus(device, fence);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn WaitForFences(device: Device, fences: []const Fence, waitAll: Bool32, timeout: u64) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkWaitForFences(device, @intCast(u32, fences.len), fences.ptr, waitAll, timeout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn CreateSemaphore(device: Device, createInfo: SemaphoreCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!Semaphore {
    var out_semaphore: Semaphore = undefined;
    const result = vkCreateSemaphore(device, &createInfo, pAllocator, &out_semaphore);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_semaphore;
}

pub const DestroySemaphore = vkDestroySemaphore;

pub inline fn CreateEvent(device: Device, createInfo: EventCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!Event {
    var out_event: Event = undefined;
    const result = vkCreateEvent(device, &createInfo, pAllocator, &out_event);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_event;
}

pub const DestroyEvent = vkDestroyEvent;

pub inline fn GetEventStatus(device: Device, event: Event) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkGetEventStatus(device, event);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn SetEvent(device: Device, event: Event) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkSetEvent(device, event);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn ResetEvent(device: Device, event: Event) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkResetEvent(device, event);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CreateQueryPool(device: Device, createInfo: QueryPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!QueryPool {
    var out_queryPool: QueryPool = undefined;
    const result = vkCreateQueryPool(device, &createInfo, pAllocator, &out_queryPool);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_queryPool;
}

pub const DestroyQueryPool = vkDestroyQueryPool;

pub inline fn GetQueryPoolResults(device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, data: []u8, stride: DeviceSize, flags: QueryResultFlags) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, @intCast(usize, data.len), data.ptr, stride, flags);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn CreateBuffer(device: Device, createInfo: BufferCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_UNDOCUMENTED_ERROR}!Buffer {
    var out_buffer: Buffer = undefined;
    const result = vkCreateBuffer(device, &createInfo, pAllocator, &out_buffer);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => error.VK_INVALID_OPAQUE_CAPTURE_ADDRESS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_buffer;
}

pub const DestroyBuffer = vkDestroyBuffer;

pub inline fn CreateBufferView(device: Device, createInfo: BufferViewCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!BufferView {
    var out_view: BufferView = undefined;
    const result = vkCreateBufferView(device, &createInfo, pAllocator, &out_view);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_view;
}

pub const DestroyBufferView = vkDestroyBufferView;

pub inline fn CreateImage(device: Device, createInfo: ImageCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!Image {
    var out_image: Image = undefined;
    const result = vkCreateImage(device, &createInfo, pAllocator, &out_image);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_image;
}

pub const DestroyImage = vkDestroyImage;

pub inline fn GetImageSubresourceLayout(device: Device, image: Image, subresource: ImageSubresource) SubresourceLayout {
    var out_layout: SubresourceLayout = undefined;
    vkGetImageSubresourceLayout(device, image, &subresource, &out_layout);
    return out_layout;
}

pub inline fn CreateImageView(device: Device, createInfo: ImageViewCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!ImageView {
    var out_view: ImageView = undefined;
    const result = vkCreateImageView(device, &createInfo, pAllocator, &out_view);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_view;
}

pub const DestroyImageView = vkDestroyImageView;

pub inline fn CreateShaderModule(device: Device, createInfo: ShaderModuleCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_SHADER_NV,VK_UNDOCUMENTED_ERROR}!ShaderModule {
    var out_shaderModule: ShaderModule = undefined;
    const result = vkCreateShaderModule(device, &createInfo, pAllocator, &out_shaderModule);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_SHADER_NV => error.VK_INVALID_SHADER_NV,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_shaderModule;
}

pub const DestroyShaderModule = vkDestroyShaderModule;

pub inline fn CreatePipelineCache(device: Device, createInfo: PipelineCacheCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!PipelineCache {
    var out_pipelineCache: PipelineCache = undefined;
    const result = vkCreatePipelineCache(device, &createInfo, pAllocator, &out_pipelineCache);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_pipelineCache;
}

pub const DestroyPipelineCache = vkDestroyPipelineCache;

pub const GetPipelineCacheDataResult = struct {
    result: Result,
    data: []u8,
};
pub inline fn GetPipelineCacheData(device: Device, pipelineCache: PipelineCache, data: []u8) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPipelineCacheDataResult {
    var returnValues: GetPipelineCacheDataResult = undefined;
    var dataSize: usize = @intCast(usize, data.len);
    const result = vkGetPipelineCacheData(device, pipelineCache, &dataSize, data.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.data = data[0..dataSize];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPipelineCacheDataCount(device: Device, pipelineCache: PipelineCache) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!usize {
    var out_dataSize: usize = undefined;
    const result = vkGetPipelineCacheData(device, pipelineCache, &out_dataSize, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_dataSize;
}

pub inline fn MergePipelineCaches(device: Device, dstCache: PipelineCache, srcCaches: []const PipelineCache) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkMergePipelineCaches(device, dstCache, @intCast(u32, srcCaches.len), srcCaches.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CreateGraphicsPipelines(device: Device, pipelineCache: ?PipelineCache, createInfos: []const GraphicsPipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, pipelines: []Pipeline) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_SHADER_NV,VK_UNDOCUMENTED_ERROR}!void {
    assert(pipelines.len >= createInfos.len);
    const result = vkCreateGraphicsPipelines(device, pipelineCache, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, pipelines.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_SHADER_NV => error.VK_INVALID_SHADER_NV,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CreateComputePipelines(device: Device, pipelineCache: ?PipelineCache, createInfos: []const ComputePipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, pipelines: []Pipeline) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_SHADER_NV,VK_UNDOCUMENTED_ERROR}!void {
    assert(pipelines.len >= createInfos.len);
    const result = vkCreateComputePipelines(device, pipelineCache, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, pipelines.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_SHADER_NV => error.VK_INVALID_SHADER_NV,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const DestroyPipeline = vkDestroyPipeline;

pub inline fn CreatePipelineLayout(device: Device, createInfo: PipelineLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!PipelineLayout {
    var out_pipelineLayout: PipelineLayout = undefined;
    const result = vkCreatePipelineLayout(device, &createInfo, pAllocator, &out_pipelineLayout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_pipelineLayout;
}

pub const DestroyPipelineLayout = vkDestroyPipelineLayout;

pub inline fn CreateSampler(device: Device, createInfo: SamplerCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_TOO_MANY_OBJECTS,VK_UNDOCUMENTED_ERROR}!Sampler {
    var out_sampler: Sampler = undefined;
    const result = vkCreateSampler(device, &createInfo, pAllocator, &out_sampler);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_sampler;
}

pub const DestroySampler = vkDestroySampler;

pub inline fn CreateDescriptorSetLayout(device: Device, createInfo: DescriptorSetLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DescriptorSetLayout {
    var out_setLayout: DescriptorSetLayout = undefined;
    const result = vkCreateDescriptorSetLayout(device, &createInfo, pAllocator, &out_setLayout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_setLayout;
}

pub const DestroyDescriptorSetLayout = vkDestroyDescriptorSetLayout;

pub inline fn CreateDescriptorPool(device: Device, createInfo: DescriptorPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FRAGMENTATION,VK_UNDOCUMENTED_ERROR}!DescriptorPool {
    var out_descriptorPool: DescriptorPool = undefined;
    const result = vkCreateDescriptorPool(device, &createInfo, pAllocator, &out_descriptorPool);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FRAGMENTATION => error.VK_FRAGMENTATION,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_descriptorPool;
}

pub const DestroyDescriptorPool = vkDestroyDescriptorPool;

pub inline fn ResetDescriptorPool(device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) error{VK_UNDOCUMENTED_ERROR}!void {
    const result = vkResetDescriptorPool(device, descriptorPool, flags);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
}

pub inline fn AllocateDescriptorSets(device: Device, allocateInfo: DescriptorSetAllocateInfo, descriptorSets: []DescriptorSet) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FRAGMENTED_POOL,VK_OUT_OF_POOL_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    assert(descriptorSets.len >= allocateInfo.descriptorSetCount);
    const result = vkAllocateDescriptorSets(device, &allocateInfo, descriptorSets.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FRAGMENTED_POOL => error.VK_FRAGMENTED_POOL,
            .ERROR_OUT_OF_POOL_MEMORY => error.VK_OUT_OF_POOL_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn FreeDescriptorSets(device: Device, descriptorPool: DescriptorPool, descriptorSets: []const DescriptorSet) error{VK_UNDOCUMENTED_ERROR}!void {
    const result = vkFreeDescriptorSets(device, descriptorPool, @intCast(u32, descriptorSets.len), descriptorSets.ptr);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
}

pub inline fn UpdateDescriptorSets(device: Device, descriptorWrites: []const WriteDescriptorSet, descriptorCopies: []const CopyDescriptorSet) void {
    vkUpdateDescriptorSets(device, @intCast(u32, descriptorWrites.len), descriptorWrites.ptr, @intCast(u32, descriptorCopies.len), descriptorCopies.ptr);
}

pub inline fn CreateFramebuffer(device: Device, createInfo: FramebufferCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!Framebuffer {
    var out_framebuffer: Framebuffer = undefined;
    const result = vkCreateFramebuffer(device, &createInfo, pAllocator, &out_framebuffer);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_framebuffer;
}

pub const DestroyFramebuffer = vkDestroyFramebuffer;

pub inline fn CreateRenderPass(device: Device, createInfo: RenderPassCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!RenderPass {
    var out_renderPass: RenderPass = undefined;
    const result = vkCreateRenderPass(device, &createInfo, pAllocator, &out_renderPass);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_renderPass;
}

pub const DestroyRenderPass = vkDestroyRenderPass;

pub inline fn GetRenderAreaGranularity(device: Device, renderPass: RenderPass) Extent2D {
    var out_granularity: Extent2D = undefined;
    vkGetRenderAreaGranularity(device, renderPass, &out_granularity);
    return out_granularity;
}

pub inline fn CreateCommandPool(device: Device, createInfo: CommandPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!CommandPool {
    var out_commandPool: CommandPool = undefined;
    const result = vkCreateCommandPool(device, &createInfo, pAllocator, &out_commandPool);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_commandPool;
}

pub const DestroyCommandPool = vkDestroyCommandPool;

pub inline fn ResetCommandPool(device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkResetCommandPool(device, commandPool, flags);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn AllocateCommandBuffers(device: Device, allocateInfo: CommandBufferAllocateInfo, commandBuffers: []CommandBuffer) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    assert(commandBuffers.len >= allocateInfo.commandBufferCount);
    const result = vkAllocateCommandBuffers(device, &allocateInfo, commandBuffers.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn FreeCommandBuffers(device: Device, commandPool: CommandPool, commandBuffers: []const CommandBuffer) void {
    vkFreeCommandBuffers(device, commandPool, @intCast(u32, commandBuffers.len), commandBuffers.ptr);
}

pub inline fn BeginCommandBuffer(commandBuffer: CommandBuffer, beginInfo: CommandBufferBeginInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBeginCommandBuffer(commandBuffer, &beginInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn EndCommandBuffer(commandBuffer: CommandBuffer) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkEndCommandBuffer(commandBuffer);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn ResetCommandBuffer(commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkResetCommandBuffer(commandBuffer, flags);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const CmdBindPipeline = vkCmdBindPipeline;

pub inline fn CmdSetViewport(commandBuffer: CommandBuffer, firstViewport: u32, viewports: []const Viewport) void {
    vkCmdSetViewport(commandBuffer, firstViewport, @intCast(u32, viewports.len), viewports.ptr);
}

pub inline fn CmdSetScissor(commandBuffer: CommandBuffer, firstScissor: u32, scissors: []const Rect2D) void {
    vkCmdSetScissor(commandBuffer, firstScissor, @intCast(u32, scissors.len), scissors.ptr);
}

pub const CmdSetLineWidth = vkCmdSetLineWidth;
pub const CmdSetDepthBias = vkCmdSetDepthBias;

pub inline fn CmdSetBlendConstants(commandBuffer: CommandBuffer, blendConstants: [4]f32) void {
    vkCmdSetBlendConstants(commandBuffer, &blendConstants);
}

pub const CmdSetDepthBounds = vkCmdSetDepthBounds;
pub const CmdSetStencilCompareMask = vkCmdSetStencilCompareMask;
pub const CmdSetStencilWriteMask = vkCmdSetStencilWriteMask;
pub const CmdSetStencilReference = vkCmdSetStencilReference;

pub inline fn CmdBindDescriptorSets(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSets: []const DescriptorSet, dynamicOffsets: []const u32) void {
    vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, @intCast(u32, descriptorSets.len), descriptorSets.ptr, @intCast(u32, dynamicOffsets.len), dynamicOffsets.ptr);
}

pub const CmdBindIndexBuffer = vkCmdBindIndexBuffer;

pub inline fn CmdBindVertexBuffers(commandBuffer: CommandBuffer, firstBinding: u32, buffers: []const Buffer, offsets: []const DeviceSize) void {
    assert(offsets.len >= buffers.len);
    vkCmdBindVertexBuffers(commandBuffer, firstBinding, @intCast(u32, buffers.len), buffers.ptr, offsets.ptr);
}

pub const CmdDraw = vkCmdDraw;
pub const CmdDrawIndexed = vkCmdDrawIndexed;
pub const CmdDrawIndirect = vkCmdDrawIndirect;
pub const CmdDrawIndexedIndirect = vkCmdDrawIndexedIndirect;
pub const CmdDispatch = vkCmdDispatch;
pub const CmdDispatchIndirect = vkCmdDispatchIndirect;

pub inline fn CmdCopyBuffer(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regions: []const BufferCopy) void {
    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, @intCast(u32, regions.len), regions.ptr);
}

pub inline fn CmdCopyImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageCopy) void {
    vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub inline fn CmdBlitImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageBlit, filter: Filter) void {
    vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr, filter);
}

pub inline fn CmdCopyBufferToImage(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regions: []const BufferImageCopy) void {
    vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub inline fn CmdCopyImageToBuffer(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regions: []const BufferImageCopy) void {
    vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, @intCast(u32, regions.len), regions.ptr);
}

pub inline fn CmdUpdateBuffer(commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, data: []const u8) void {
    vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, @intCast(DeviceSize, data.len), data.ptr);
}

pub const CmdFillBuffer = vkCmdFillBuffer;

pub inline fn CmdClearColorImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, color: ClearColorValue, ranges: []const ImageSubresourceRange) void {
    vkCmdClearColorImage(commandBuffer, image, imageLayout, &color, @intCast(u32, ranges.len), ranges.ptr);
}

pub inline fn CmdClearDepthStencilImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, depthStencil: ClearDepthStencilValue, ranges: []const ImageSubresourceRange) void {
    vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, &depthStencil, @intCast(u32, ranges.len), ranges.ptr);
}

pub inline fn CmdClearAttachments(commandBuffer: CommandBuffer, attachments: []const ClearAttachment, rects: []const ClearRect) void {
    vkCmdClearAttachments(commandBuffer, @intCast(u32, attachments.len), attachments.ptr, @intCast(u32, rects.len), rects.ptr);
}

pub inline fn CmdResolveImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageResolve) void {
    vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub const CmdSetEvent = vkCmdSetEvent;
pub const CmdResetEvent = vkCmdResetEvent;

pub inline fn CmdWaitEvents(commandBuffer: CommandBuffer, events: []const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarriers: []const MemoryBarrier, bufferMemoryBarriers: []const BufferMemoryBarrier, imageMemoryBarriers: []const ImageMemoryBarrier) void {
    vkCmdWaitEvents(commandBuffer, @intCast(u32, events.len), events.ptr, srcStageMask, dstStageMask, @intCast(u32, memoryBarriers.len), memoryBarriers.ptr, @intCast(u32, bufferMemoryBarriers.len), bufferMemoryBarriers.ptr, @intCast(u32, imageMemoryBarriers.len), imageMemoryBarriers.ptr);
}

pub inline fn CmdPipelineBarrier(commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarriers: []const MemoryBarrier, bufferMemoryBarriers: []const BufferMemoryBarrier, imageMemoryBarriers: []const ImageMemoryBarrier) void {
    vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, @intCast(u32, memoryBarriers.len), memoryBarriers.ptr, @intCast(u32, bufferMemoryBarriers.len), bufferMemoryBarriers.ptr, @intCast(u32, imageMemoryBarriers.len), imageMemoryBarriers.ptr);
}

pub const CmdBeginQuery = vkCmdBeginQuery;
pub const CmdEndQuery = vkCmdEndQuery;
pub const CmdResetQueryPool = vkCmdResetQueryPool;
pub const CmdWriteTimestamp = vkCmdWriteTimestamp;
pub const CmdCopyQueryPoolResults = vkCmdCopyQueryPoolResults;

pub inline fn CmdPushConstants(commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, values: []const u8) void {
    vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, @intCast(u32, values.len), values.ptr);
}

pub inline fn CmdBeginRenderPass(commandBuffer: CommandBuffer, renderPassBegin: RenderPassBeginInfo, contents: SubpassContents) void {
    vkCmdBeginRenderPass(commandBuffer, &renderPassBegin, contents);
}

pub const CmdNextSubpass = vkCmdNextSubpass;
pub const CmdEndRenderPass = vkCmdEndRenderPass;

pub inline fn CmdExecuteCommands(commandBuffer: CommandBuffer, commandBuffers: []const CommandBuffer) void {
    vkCmdExecuteCommands(commandBuffer, @intCast(u32, commandBuffers.len), commandBuffers.ptr);
}


pub const VERSION_1_1 = 1;
// Vulkan 1.1 version number
pub const API_VERSION_1_1 = MAKE_VERSION(1, 1, 0);// Patch version should always be set to 0

pub const SamplerYcbcrConversion = *@OpaqueType();
pub const DescriptorUpdateTemplate = *@OpaqueType();

pub const MAX_DEVICE_GROUP_SIZE = 32;
pub const LUID_SIZE = 8;
pub const QUEUE_FAMILY_EXTERNAL = (~u32(0)-1);

pub const PointClippingBehavior = extern enum {
    ALL_CLIP_PLANES = 0,
    USER_CLIP_PLANES_ONLY = 1,

    const Self = @This();
    pub const ALL_CLIP_PLANES_KHR = Self.ALL_CLIP_PLANES;
    pub const USER_CLIP_PLANES_ONLY_KHR = Self.USER_CLIP_PLANES_ONLY;
};

pub const TessellationDomainOrigin = extern enum {
    UPPER_LEFT = 0,
    LOWER_LEFT = 1,

    const Self = @This();
    pub const UPPER_LEFT_KHR = Self.UPPER_LEFT;
    pub const LOWER_LEFT_KHR = Self.LOWER_LEFT;
};

pub const SamplerYcbcrModelConversion = extern enum {
    RGB_IDENTITY = 0,
    YCBCR_IDENTITY = 1,
    YCBCR_709 = 2,
    YCBCR_601 = 3,
    YCBCR_2020 = 4,

    const Self = @This();
    pub const RGB_IDENTITY_KHR = Self.RGB_IDENTITY;
    pub const YCBCR_IDENTITY_KHR = Self.YCBCR_IDENTITY;
    pub const YCBCR_709_KHR = Self.YCBCR_709;
    pub const YCBCR_601_KHR = Self.YCBCR_601;
    pub const YCBCR_2020_KHR = Self.YCBCR_2020;
};

pub const SamplerYcbcrRange = extern enum {
    ITU_FULL = 0,
    ITU_NARROW = 1,

    const Self = @This();
    pub const ITU_FULL_KHR = Self.ITU_FULL;
    pub const ITU_NARROW_KHR = Self.ITU_NARROW;
};

pub const ChromaLocation = extern enum {
    COSITED_EVEN = 0,
    MIDPOINT = 1,

    const Self = @This();
    pub const COSITED_EVEN_KHR = Self.COSITED_EVEN;
    pub const MIDPOINT_KHR = Self.MIDPOINT;
};

pub const DescriptorUpdateTemplateType = extern enum {
    DESCRIPTOR_SET = 0,
    PUSH_DESCRIPTORS_KHR = 1,

    const Self = @This();
    pub const DESCRIPTOR_SET_KHR = Self.DESCRIPTOR_SET;
};

pub const SubgroupFeatureFlags = Flags;
pub const SubgroupFeatureFlagBits = struct {
    pub const BASIC_BIT: SubgroupFeatureFlags = 0x00000001;
    pub const VOTE_BIT: SubgroupFeatureFlags = 0x00000002;
    pub const ARITHMETIC_BIT: SubgroupFeatureFlags = 0x00000004;
    pub const BALLOT_BIT: SubgroupFeatureFlags = 0x00000008;
    pub const SHUFFLE_BIT: SubgroupFeatureFlags = 0x00000010;
    pub const SHUFFLE_RELATIVE_BIT: SubgroupFeatureFlags = 0x00000020;
    pub const CLUSTERED_BIT: SubgroupFeatureFlags = 0x00000040;
    pub const QUAD_BIT: SubgroupFeatureFlags = 0x00000080;
    pub const PARTITIONED_BIT_NV: SubgroupFeatureFlags = 0x00000100;
};

pub const PeerMemoryFeatureFlags = Flags;
pub const PeerMemoryFeatureFlagBits = struct {
    pub const COPY_SRC_BIT: PeerMemoryFeatureFlags = 0x00000001;
    pub const COPY_DST_BIT: PeerMemoryFeatureFlags = 0x00000002;
    pub const GENERIC_SRC_BIT: PeerMemoryFeatureFlags = 0x00000004;
    pub const GENERIC_DST_BIT: PeerMemoryFeatureFlags = 0x00000008;

    pub const COPY_SRC_BIT_KHR = COPY_SRC_BIT;
    pub const COPY_DST_BIT_KHR = COPY_DST_BIT;
    pub const GENERIC_SRC_BIT_KHR = GENERIC_SRC_BIT;
    pub const GENERIC_DST_BIT_KHR = GENERIC_DST_BIT;
};

pub const MemoryAllocateFlags = Flags;
pub const MemoryAllocateFlagBits = struct {
    pub const DEVICE_MASK_BIT: MemoryAllocateFlags = 0x00000001;
    pub const DEVICE_ADDRESS_BIT: MemoryAllocateFlags = 0x00000002;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: MemoryAllocateFlags = 0x00000004;

    pub const DEVICE_MASK_BIT_KHR = DEVICE_MASK_BIT;
    pub const DEVICE_ADDRESS_BIT_KHR = DEVICE_ADDRESS_BIT;
    pub const DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
};

pub const CommandPoolTrimFlags = Flags;
pub const DescriptorUpdateTemplateCreateFlags = Flags;

pub const ExternalMemoryHandleTypeFlags = Flags;
pub const ExternalMemoryHandleTypeFlagBits = struct {
    pub const OPAQUE_FD_BIT: ExternalMemoryHandleTypeFlags = 0x00000001;
    pub const OPAQUE_WIN32_BIT: ExternalMemoryHandleTypeFlags = 0x00000002;
    pub const OPAQUE_WIN32_KMT_BIT: ExternalMemoryHandleTypeFlags = 0x00000004;
    pub const D3D11_TEXTURE_BIT: ExternalMemoryHandleTypeFlags = 0x00000008;
    pub const D3D11_TEXTURE_KMT_BIT: ExternalMemoryHandleTypeFlags = 0x00000010;
    pub const D3D12_HEAP_BIT: ExternalMemoryHandleTypeFlags = 0x00000020;
    pub const D3D12_RESOURCE_BIT: ExternalMemoryHandleTypeFlags = 0x00000040;
    pub const DMA_BUF_BIT_EXT: ExternalMemoryHandleTypeFlags = 0x00000200;
    pub const ANDROID_HARDWARE_BUFFER_BIT_ANDROID: ExternalMemoryHandleTypeFlags = 0x00000400;
    pub const HOST_ALLOCATION_BIT_EXT: ExternalMemoryHandleTypeFlags = 0x00000080;
    pub const HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: ExternalMemoryHandleTypeFlags = 0x00000100;

    pub const OPAQUE_FD_BIT_KHR = OPAQUE_FD_BIT;
    pub const OPAQUE_WIN32_BIT_KHR = OPAQUE_WIN32_BIT;
    pub const OPAQUE_WIN32_KMT_BIT_KHR = OPAQUE_WIN32_KMT_BIT;
    pub const D3D11_TEXTURE_BIT_KHR = D3D11_TEXTURE_BIT;
    pub const D3D11_TEXTURE_KMT_BIT_KHR = D3D11_TEXTURE_KMT_BIT;
    pub const D3D12_HEAP_BIT_KHR = D3D12_HEAP_BIT;
    pub const D3D12_RESOURCE_BIT_KHR = D3D12_RESOURCE_BIT;
};

pub const ExternalMemoryFeatureFlags = Flags;
pub const ExternalMemoryFeatureFlagBits = struct {
    pub const DEDICATED_ONLY_BIT: ExternalMemoryFeatureFlags = 0x00000001;
    pub const EXPORTABLE_BIT: ExternalMemoryFeatureFlags = 0x00000002;
    pub const IMPORTABLE_BIT: ExternalMemoryFeatureFlags = 0x00000004;

    pub const DEDICATED_ONLY_BIT_KHR = DEDICATED_ONLY_BIT;
    pub const EXPORTABLE_BIT_KHR = EXPORTABLE_BIT;
    pub const IMPORTABLE_BIT_KHR = IMPORTABLE_BIT;
};

pub const ExternalFenceHandleTypeFlags = Flags;
pub const ExternalFenceHandleTypeFlagBits = struct {
    pub const OPAQUE_FD_BIT: ExternalFenceHandleTypeFlags = 0x00000001;
    pub const OPAQUE_WIN32_BIT: ExternalFenceHandleTypeFlags = 0x00000002;
    pub const OPAQUE_WIN32_KMT_BIT: ExternalFenceHandleTypeFlags = 0x00000004;
    pub const SYNC_FD_BIT: ExternalFenceHandleTypeFlags = 0x00000008;

    pub const OPAQUE_FD_BIT_KHR = OPAQUE_FD_BIT;
    pub const OPAQUE_WIN32_BIT_KHR = OPAQUE_WIN32_BIT;
    pub const OPAQUE_WIN32_KMT_BIT_KHR = OPAQUE_WIN32_KMT_BIT;
    pub const SYNC_FD_BIT_KHR = SYNC_FD_BIT;
};

pub const ExternalFenceFeatureFlags = Flags;
pub const ExternalFenceFeatureFlagBits = struct {
    pub const EXPORTABLE_BIT: ExternalFenceFeatureFlags = 0x00000001;
    pub const IMPORTABLE_BIT: ExternalFenceFeatureFlags = 0x00000002;

    pub const EXPORTABLE_BIT_KHR = EXPORTABLE_BIT;
    pub const IMPORTABLE_BIT_KHR = IMPORTABLE_BIT;
};

pub const FenceImportFlags = Flags;
pub const FenceImportFlagBits = struct {
    pub const TEMPORARY_BIT: FenceImportFlags = 0x00000001;

    pub const TEMPORARY_BIT_KHR = TEMPORARY_BIT;
};

pub const SemaphoreImportFlags = Flags;
pub const SemaphoreImportFlagBits = struct {
    pub const TEMPORARY_BIT: SemaphoreImportFlags = 0x00000001;

    pub const TEMPORARY_BIT_KHR = TEMPORARY_BIT;
};

pub const ExternalSemaphoreHandleTypeFlags = Flags;
pub const ExternalSemaphoreHandleTypeFlagBits = struct {
    pub const OPAQUE_FD_BIT: ExternalSemaphoreHandleTypeFlags = 0x00000001;
    pub const OPAQUE_WIN32_BIT: ExternalSemaphoreHandleTypeFlags = 0x00000002;
    pub const OPAQUE_WIN32_KMT_BIT: ExternalSemaphoreHandleTypeFlags = 0x00000004;
    pub const D3D12_FENCE_BIT: ExternalSemaphoreHandleTypeFlags = 0x00000008;
    pub const SYNC_FD_BIT: ExternalSemaphoreHandleTypeFlags = 0x00000010;

    pub const OPAQUE_FD_BIT_KHR = OPAQUE_FD_BIT;
    pub const OPAQUE_WIN32_BIT_KHR = OPAQUE_WIN32_BIT;
    pub const OPAQUE_WIN32_KMT_BIT_KHR = OPAQUE_WIN32_KMT_BIT;
    pub const D3D12_FENCE_BIT_KHR = D3D12_FENCE_BIT;
    pub const SYNC_FD_BIT_KHR = SYNC_FD_BIT;
};

pub const ExternalSemaphoreFeatureFlags = Flags;
pub const ExternalSemaphoreFeatureFlagBits = struct {
    pub const EXPORTABLE_BIT: ExternalSemaphoreFeatureFlags = 0x00000001;
    pub const IMPORTABLE_BIT: ExternalSemaphoreFeatureFlags = 0x00000002;

    pub const EXPORTABLE_BIT_KHR = EXPORTABLE_BIT;
    pub const IMPORTABLE_BIT_KHR = IMPORTABLE_BIT;
};

pub const PhysicalDeviceSubgroupProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    pNext: ?*c_void = null,
    subgroupSize: u32,
    supportedStages: ShaderStageFlags,
    supportedOperations: SubgroupFeatureFlags,
    quadOperationsInAllStages: Bool32,
};

pub const BindBufferMemoryInfo = extern struct {
    sType: StructureType = .BIND_BUFFER_MEMORY_INFO,
    pNext: ?*const c_void = null,
    buffer: Buffer,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
};

pub const BindImageMemoryInfo = extern struct {
    sType: StructureType = .BIND_IMAGE_MEMORY_INFO,
    pNext: ?*const c_void = null,
    image: Image,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
};

pub const PhysicalDevice16BitStorageFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    pNext: ?*c_void = null,
    storageBuffer16BitAccess: Bool32,
    uniformAndStorageBuffer16BitAccess: Bool32,
    storagePushConstant16: Bool32,
    storageInputOutput16: Bool32,
};

pub const MemoryDedicatedRequirements = extern struct {
    sType: StructureType = .MEMORY_DEDICATED_REQUIREMENTS,
    pNext: ?*c_void = null,
    prefersDedicatedAllocation: Bool32,
    requiresDedicatedAllocation: Bool32,
};

pub const MemoryDedicatedAllocateInfo = extern struct {
    sType: StructureType = .MEMORY_DEDICATED_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    image: ?Image = null,
    buffer: ?Buffer = null,
};

pub const MemoryAllocateFlagsInfo = extern struct {
    sType: StructureType = .MEMORY_ALLOCATE_FLAGS_INFO,
    pNext: ?*const c_void = null,
    flags: MemoryAllocateFlags = 0,
    deviceMask: u32,
};

pub const DeviceGroupRenderPassBeginInfo = extern struct {
    sType: StructureType = .DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    pNext: ?*const c_void = null,
    deviceMask: u32,
    deviceRenderAreaCount: u32 = 0,
    pDeviceRenderAreas: [*]const Rect2D = undefined,
};

pub const DeviceGroupCommandBufferBeginInfo = extern struct {
    sType: StructureType = .DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    pNext: ?*const c_void = null,
    deviceMask: u32,
};

pub const DeviceGroupSubmitInfo = extern struct {
    sType: StructureType = .DEVICE_GROUP_SUBMIT_INFO,
    pNext: ?*const c_void = null,
    waitSemaphoreCount: u32 = 0,
    pWaitSemaphoreDeviceIndices: [*]const u32 = undefined,
    commandBufferCount: u32 = 0,
    pCommandBufferDeviceMasks: [*]const u32 = undefined,
    signalSemaphoreCount: u32 = 0,
    pSignalSemaphoreDeviceIndices: [*]const u32 = undefined,
};

pub const DeviceGroupBindSparseInfo = extern struct {
    sType: StructureType = .DEVICE_GROUP_BIND_SPARSE_INFO,
    pNext: ?*const c_void = null,
    resourceDeviceIndex: u32,
    memoryDeviceIndex: u32,
};

pub const BindBufferMemoryDeviceGroupInfo = extern struct {
    sType: StructureType = .BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    pNext: ?*const c_void = null,
    deviceIndexCount: u32 = 0,
    pDeviceIndices: [*]const u32 = undefined,
};

pub const BindImageMemoryDeviceGroupInfo = extern struct {
    sType: StructureType = .BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    pNext: ?*const c_void = null,
    deviceIndexCount: u32 = 0,
    pDeviceIndices: [*]const u32 = undefined,
    splitInstanceBindRegionCount: u32 = 0,
    pSplitInstanceBindRegions: [*]const Rect2D = undefined,
};

pub const PhysicalDeviceGroupProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_GROUP_PROPERTIES,
    pNext: ?*c_void = null,
    physicalDeviceCount: u32,
    physicalDevices: [MAX_DEVICE_GROUP_SIZE]PhysicalDevice,
    subsetAllocation: Bool32,
};

pub const DeviceGroupDeviceCreateInfo = extern struct {
    sType: StructureType = .DEVICE_GROUP_DEVICE_CREATE_INFO,
    pNext: ?*const c_void = null,
    physicalDeviceCount: u32 = 0,
    pPhysicalDevices: [*]const PhysicalDevice = undefined,
};

pub const BufferMemoryRequirementsInfo2 = extern struct {
    sType: StructureType = .BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    pNext: ?*const c_void = null,
    buffer: Buffer,
};

pub const ImageMemoryRequirementsInfo2 = extern struct {
    sType: StructureType = .IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    pNext: ?*const c_void = null,
    image: Image,
};

pub const ImageSparseMemoryRequirementsInfo2 = extern struct {
    sType: StructureType = .IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    pNext: ?*const c_void = null,
    image: Image,
};

pub const MemoryRequirements2 = extern struct {
    sType: StructureType = .MEMORY_REQUIREMENTS_2,
    pNext: ?*c_void = null,
    memoryRequirements: MemoryRequirements,
};

pub const MemoryRequirements2KHR = MemoryRequirements2;

pub const SparseImageMemoryRequirements2 = extern struct {
    sType: StructureType = .SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    pNext: ?*c_void = null,
    memoryRequirements: SparseImageMemoryRequirements,
};

pub const PhysicalDeviceFeatures2 = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FEATURES_2,
    pNext: ?*c_void = null,
    features: PhysicalDeviceFeatures,
};

pub const PhysicalDeviceProperties2 = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PROPERTIES_2,
    pNext: ?*c_void = null,
    properties: PhysicalDeviceProperties,
};

pub const FormatProperties2 = extern struct {
    sType: StructureType = .FORMAT_PROPERTIES_2,
    pNext: ?*c_void = null,
    formatProperties: FormatProperties,
};

pub const ImageFormatProperties2 = extern struct {
    sType: StructureType = .IMAGE_FORMAT_PROPERTIES_2,
    pNext: ?*c_void = null,
    imageFormatProperties: ImageFormatProperties,
};

pub const PhysicalDeviceImageFormatInfo2 = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    pNext: ?*const c_void = null,
    format: Format,
    inType: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags = 0,
};

pub const QueueFamilyProperties2 = extern struct {
    sType: StructureType = .QUEUE_FAMILY_PROPERTIES_2,
    pNext: ?*c_void = null,
    queueFamilyProperties: QueueFamilyProperties,
};

pub const PhysicalDeviceMemoryProperties2 = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    pNext: ?*c_void = null,
    memoryProperties: PhysicalDeviceMemoryProperties,
};

pub const SparseImageFormatProperties2 = extern struct {
    sType: StructureType = .SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    pNext: ?*c_void = null,
    properties: SparseImageFormatProperties,
};

pub const PhysicalDeviceSparseImageFormatInfo2 = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    pNext: ?*const c_void = null,
    format: Format,
    inType: ImageType,
    samples: SampleCountFlags,
    usage: ImageUsageFlags,
    tiling: ImageTiling,
};

pub const PhysicalDevicePointClippingProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    pNext: ?*c_void = null,
    pointClippingBehavior: PointClippingBehavior,
};

pub const InputAttachmentAspectReference = extern struct {
    subpass: u32,
    inputAttachmentIndex: u32,
    aspectMask: ImageAspectFlags,
};

pub const RenderPassInputAttachmentAspectCreateInfo = extern struct {
    sType: StructureType = .RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    pNext: ?*const c_void = null,
    aspectReferenceCount: u32,
    pAspectReferences: [*]const InputAttachmentAspectReference,
};

pub const ImageViewUsageCreateInfo = extern struct {
    sType: StructureType = .IMAGE_VIEW_USAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    usage: ImageUsageFlags,
};

pub const PipelineTessellationDomainOriginStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    domainOrigin: TessellationDomainOrigin,
};

pub const RenderPassMultiviewCreateInfo = extern struct {
    sType: StructureType = .RENDER_PASS_MULTIVIEW_CREATE_INFO,
    pNext: ?*const c_void = null,
    subpassCount: u32 = 0,
    pViewMasks: [*]const u32 = undefined,
    dependencyCount: u32 = 0,
    pViewOffsets: [*]const i32 = undefined,
    correlationMaskCount: u32 = 0,
    pCorrelationMasks: [*]const u32 = undefined,
};

pub const PhysicalDeviceMultiviewFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    pNext: ?*c_void = null,
    multiview: Bool32,
    multiviewGeometryShader: Bool32,
    multiviewTessellationShader: Bool32,
};

pub const PhysicalDeviceMultiviewProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    pNext: ?*c_void = null,
    maxMultiviewViewCount: u32,
    maxMultiviewInstanceIndex: u32,
};

pub const PhysicalDeviceVariablePointersFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    pNext: ?*c_void = null,
    variablePointersStorageBuffer: Bool32,
    variablePointers: Bool32,
};

pub const PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures;

pub const PhysicalDeviceProtectedMemoryFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    pNext: ?*c_void = null,
    protectedMemory: Bool32,
};

pub const PhysicalDeviceProtectedMemoryProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    pNext: ?*c_void = null,
    protectedNoFault: Bool32,
};

pub const DeviceQueueInfo2 = extern struct {
    sType: StructureType = .DEVICE_QUEUE_INFO_2,
    pNext: ?*const c_void = null,
    flags: DeviceQueueCreateFlags = 0,
    queueFamilyIndex: u32,
    queueIndex: u32,
};

pub const ProtectedSubmitInfo = extern struct {
    sType: StructureType = .PROTECTED_SUBMIT_INFO,
    pNext: ?*const c_void = null,
    protectedSubmit: Bool32,
};

pub const SamplerYcbcrConversionCreateInfo = extern struct {
    sType: StructureType = .SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    pNext: ?*const c_void = null,
    format: Format,
    ycbcrModel: SamplerYcbcrModelConversion,
    ycbcrRange: SamplerYcbcrRange,
    components: ComponentMapping,
    xChromaOffset: ChromaLocation,
    yChromaOffset: ChromaLocation,
    chromaFilter: Filter,
    forceExplicitReconstruction: Bool32,
};

pub const SamplerYcbcrConversionInfo = extern struct {
    sType: StructureType = .SAMPLER_YCBCR_CONVERSION_INFO,
    pNext: ?*const c_void = null,
    conversion: SamplerYcbcrConversion,
};

pub const BindImagePlaneMemoryInfo = extern struct {
    sType: StructureType = .BIND_IMAGE_PLANE_MEMORY_INFO,
    pNext: ?*const c_void = null,
    planeAspect: ImageAspectFlags,
};

pub const ImagePlaneMemoryRequirementsInfo = extern struct {
    sType: StructureType = .IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    pNext: ?*const c_void = null,
    planeAspect: ImageAspectFlags,
};

pub const PhysicalDeviceSamplerYcbcrConversionFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    pNext: ?*c_void = null,
    samplerYcbcrConversion: Bool32,
};

pub const SamplerYcbcrConversionImageFormatProperties = extern struct {
    sType: StructureType = .SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    pNext: ?*c_void = null,
    combinedImageSamplerDescriptorCount: u32,
};

pub const DescriptorUpdateTemplateEntry = extern struct {
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
    descriptorType: DescriptorType,
    offset: usize,
    stride: usize,
};

pub const DescriptorUpdateTemplateCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DescriptorUpdateTemplateCreateFlags = 0,
    descriptorUpdateEntryCount: u32,
    pDescriptorUpdateEntries: [*]const DescriptorUpdateTemplateEntry,
    templateType: DescriptorUpdateTemplateType,
    descriptorSetLayout: DescriptorSetLayout,
    pipelineBindPoint: PipelineBindPoint,
    pipelineLayout: PipelineLayout,
    set: u32,
};

pub const ExternalMemoryProperties = extern struct {
    externalMemoryFeatures: ExternalMemoryFeatureFlags,
    exportFromImportedHandleTypes: ExternalMemoryHandleTypeFlags = 0,
    compatibleHandleTypes: ExternalMemoryHandleTypeFlags,
};

pub const PhysicalDeviceExternalImageFormatInfo = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    pNext: ?*const c_void = null,
    handleType: ExternalMemoryHandleTypeFlags = 0,
};

pub const ExternalImageFormatProperties = extern struct {
    sType: StructureType = .EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    pNext: ?*c_void = null,
    externalMemoryProperties: ExternalMemoryProperties,
};

pub const PhysicalDeviceExternalBufferInfo = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    pNext: ?*const c_void = null,
    flags: BufferCreateFlags = 0,
    usage: BufferUsageFlags,
    handleType: ExternalMemoryHandleTypeFlags,
};

pub const ExternalBufferProperties = extern struct {
    sType: StructureType = .EXTERNAL_BUFFER_PROPERTIES,
    pNext: ?*c_void = null,
    externalMemoryProperties: ExternalMemoryProperties,
};

pub const PhysicalDeviceIDProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_ID_PROPERTIES,
    pNext: ?*c_void = null,
    deviceUUID: [UUID_SIZE]u8,
    driverUUID: [UUID_SIZE]u8,
    deviceLUID: [LUID_SIZE]u8,
    deviceNodeMask: u32,
    deviceLUIDValid: Bool32,
};

pub const ExternalMemoryImageCreateInfo = extern struct {
    sType: StructureType = .EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    handleTypes: ExternalMemoryHandleTypeFlags,
};

pub const ExternalMemoryBufferCreateInfo = extern struct {
    sType: StructureType = .EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    pNext: ?*const c_void = null,
    handleTypes: ExternalMemoryHandleTypeFlags = 0,
};

pub const ExportMemoryAllocateInfo = extern struct {
    sType: StructureType = .EXPORT_MEMORY_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    handleTypes: ExternalMemoryHandleTypeFlags = 0,
};

pub const PhysicalDeviceExternalFenceInfo = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    pNext: ?*const c_void = null,
    handleType: ExternalFenceHandleTypeFlags,
};

pub const ExternalFenceProperties = extern struct {
    sType: StructureType = .EXTERNAL_FENCE_PROPERTIES,
    pNext: ?*c_void = null,
    exportFromImportedHandleTypes: ExternalFenceHandleTypeFlags,
    compatibleHandleTypes: ExternalFenceHandleTypeFlags,
    externalFenceFeatures: ExternalFenceFeatureFlags = 0,
};

pub const ExportFenceCreateInfo = extern struct {
    sType: StructureType = .EXPORT_FENCE_CREATE_INFO,
    pNext: ?*const c_void = null,
    handleTypes: ExternalFenceHandleTypeFlags = 0,
};

pub const ExportSemaphoreCreateInfo = extern struct {
    sType: StructureType = .EXPORT_SEMAPHORE_CREATE_INFO,
    pNext: ?*const c_void = null,
    handleTypes: ExternalSemaphoreHandleTypeFlags = 0,
};

pub const PhysicalDeviceExternalSemaphoreInfo = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    pNext: ?*const c_void = null,
    handleType: ExternalSemaphoreHandleTypeFlags,
};

pub const ExternalSemaphoreProperties = extern struct {
    sType: StructureType = .EXTERNAL_SEMAPHORE_PROPERTIES,
    pNext: ?*c_void = null,
    exportFromImportedHandleTypes: ExternalSemaphoreHandleTypeFlags,
    compatibleHandleTypes: ExternalSemaphoreHandleTypeFlags,
    externalSemaphoreFeatures: ExternalSemaphoreFeatureFlags = 0,
};

pub const PhysicalDeviceMaintenance3Properties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    pNext: ?*c_void = null,
    maxPerSetDescriptors: u32,
    maxMemoryAllocationSize: DeviceSize,
};

pub const DescriptorSetLayoutSupport = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_LAYOUT_SUPPORT,
    pNext: ?*c_void = null,
    supported: Bool32,
};

pub const PhysicalDeviceShaderDrawParametersFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    pNext: ?*c_void = null,
    shaderDrawParameters: Bool32,
};

pub const PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;

pub extern fn vkEnumerateInstanceVersion(pApiVersion: *u32) Result;

pub extern fn vkBindBufferMemory2(
    device: Device,
    bindInfoCount: u32,
    pBindInfos: [*]const BindBufferMemoryInfo,
) Result;

pub extern fn vkBindImageMemory2(
    device: Device,
    bindInfoCount: u32,
    pBindInfos: [*]const BindImageMemoryInfo,
) Result;

pub extern fn vkGetDeviceGroupPeerMemoryFeatures(
    device: Device,
    heapIndex: u32,
    localDeviceIndex: u32,
    remoteDeviceIndex: u32,
    pPeerMemoryFeatures: *PeerMemoryFeatureFlags,
) void;

pub extern fn vkCmdSetDeviceMask(
    commandBuffer: CommandBuffer,
    deviceMask: u32,
) void;

pub extern fn vkCmdDispatchBase(
    commandBuffer: CommandBuffer,
    baseGroupX: u32,
    baseGroupY: u32,
    baseGroupZ: u32,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) void;

pub extern fn vkEnumeratePhysicalDeviceGroups(
    instance: Instance,
    pPhysicalDeviceGroupCount: *u32,
    pPhysicalDeviceGroupProperties: ?[*]PhysicalDeviceGroupProperties,
) Result;

pub extern fn vkGetImageMemoryRequirements2(
    device: Device,
    pInfo: *const ImageMemoryRequirementsInfo2,
    pMemoryRequirements: *MemoryRequirements2,
) void;

pub extern fn vkGetBufferMemoryRequirements2(
    device: Device,
    pInfo: *const BufferMemoryRequirementsInfo2,
    pMemoryRequirements: *MemoryRequirements2,
) void;

pub extern fn vkGetImageSparseMemoryRequirements2(
    device: Device,
    pInfo: *const ImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount: *u32,
    pSparseMemoryRequirements: ?[*]SparseImageMemoryRequirements2,
) void;

pub extern fn vkGetPhysicalDeviceFeatures2(
    physicalDevice: PhysicalDevice,
    pFeatures: *PhysicalDeviceFeatures2,
) void;

pub extern fn vkGetPhysicalDeviceProperties2(
    physicalDevice: PhysicalDevice,
    pProperties: *PhysicalDeviceProperties2,
) void;

pub extern fn vkGetPhysicalDeviceFormatProperties2(
    physicalDevice: PhysicalDevice,
    format: Format,
    pFormatProperties: *FormatProperties2,
) void;

pub extern fn vkGetPhysicalDeviceImageFormatProperties2(
    physicalDevice: PhysicalDevice,
    pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2,
    pImageFormatProperties: *ImageFormatProperties2,
) Result;

pub extern fn vkGetPhysicalDeviceQueueFamilyProperties2(
    physicalDevice: PhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    pQueueFamilyProperties: ?[*]QueueFamilyProperties2,
) void;

pub extern fn vkGetPhysicalDeviceMemoryProperties2(
    physicalDevice: PhysicalDevice,
    pMemoryProperties: *PhysicalDeviceMemoryProperties2,
) void;

pub extern fn vkGetPhysicalDeviceSparseImageFormatProperties2(
    physicalDevice: PhysicalDevice,
    pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount: *u32,
    pProperties: ?[*]SparseImageFormatProperties2,
) void;

pub extern fn vkTrimCommandPool(
    device: Device,
    commandPool: CommandPool,
    flags: CommandPoolTrimFlags,
) void;

pub extern fn vkGetDeviceQueue2(
    device: Device,
    pQueueInfo: *const DeviceQueueInfo2,
    pQueue: *Queue,
) void;

pub extern fn vkCreateSamplerYcbcrConversion(
    device: Device,
    pCreateInfo: *const SamplerYcbcrConversionCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pYcbcrConversion: *SamplerYcbcrConversion,
) Result;

pub extern fn vkDestroySamplerYcbcrConversion(
    device: Device,
    ycbcrConversion: ?SamplerYcbcrConversion,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateDescriptorUpdateTemplate(
    device: Device,
    pCreateInfo: *const DescriptorUpdateTemplateCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pDescriptorUpdateTemplate: *DescriptorUpdateTemplate,
) Result;

pub extern fn vkDestroyDescriptorUpdateTemplate(
    device: Device,
    descriptorUpdateTemplate: ?DescriptorUpdateTemplate,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkUpdateDescriptorSetWithTemplate(
    device: Device,
    descriptorSet: DescriptorSet,
    descriptorUpdateTemplate: DescriptorUpdateTemplate,
    pData: ?*const c_void,
) void;

pub extern fn vkGetPhysicalDeviceExternalBufferProperties(
    physicalDevice: PhysicalDevice,
    pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties: *ExternalBufferProperties,
) void;

pub extern fn vkGetPhysicalDeviceExternalFenceProperties(
    physicalDevice: PhysicalDevice,
    pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties: *ExternalFenceProperties,
) void;

pub extern fn vkGetPhysicalDeviceExternalSemaphoreProperties(
    physicalDevice: PhysicalDevice,
    pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties: *ExternalSemaphoreProperties,
) void;

pub extern fn vkGetDescriptorSetLayoutSupport(
    device: Device,
    pCreateInfo: *const DescriptorSetLayoutCreateInfo,
    pSupport: *DescriptorSetLayoutSupport,
) void;

pub inline fn EnumerateInstanceVersion() error{VK_UNDOCUMENTED_ERROR}!u32 {
    var out_apiVersion: u32 = undefined;
    const result = vkEnumerateInstanceVersion(&out_apiVersion);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    return out_apiVersion;
}

pub inline fn BindBufferMemory2(device: Device, bindInfos: []const BindBufferMemoryInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindBufferMemory2(device, @intCast(u32, bindInfos.len), bindInfos.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => error.VK_INVALID_OPAQUE_CAPTURE_ADDRESS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn BindImageMemory2(device: Device, bindInfos: []const BindImageMemoryInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindImageMemory2(device, @intCast(u32, bindInfos.len), bindInfos.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetDeviceGroupPeerMemoryFeatures(device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32) PeerMemoryFeatureFlags {
    var out_peerMemoryFeatures: PeerMemoryFeatureFlags = undefined;
    vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, &out_peerMemoryFeatures);
    return out_peerMemoryFeatures;
}

pub const CmdSetDeviceMask = vkCmdSetDeviceMask;
pub const CmdDispatchBase = vkCmdDispatchBase;

pub const EnumeratePhysicalDeviceGroupsResult = struct {
    result: Result,
    physicalDeviceGroupProperties: []PhysicalDeviceGroupProperties,
};
pub inline fn EnumeratePhysicalDeviceGroups(instance: Instance, physicalDeviceGroupProperties: []PhysicalDeviceGroupProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!EnumeratePhysicalDeviceGroupsResult {
    var returnValues: EnumeratePhysicalDeviceGroupsResult = undefined;
    var physicalDeviceGroupCount: u32 = @intCast(u32, physicalDeviceGroupProperties.len);
    const result = vkEnumeratePhysicalDeviceGroups(instance, &physicalDeviceGroupCount, physicalDeviceGroupProperties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.physicalDeviceGroupProperties = physicalDeviceGroupProperties[0..physicalDeviceGroupCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumeratePhysicalDeviceGroupsCount(instance: Instance) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_physicalDeviceGroupCount: u32 = undefined;
    const result = vkEnumeratePhysicalDeviceGroups(instance, &out_physicalDeviceGroupCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_physicalDeviceGroupCount;
}

pub inline fn GetImageMemoryRequirements2(device: Device, info: ImageMemoryRequirementsInfo2) MemoryRequirements2 {
    var out_memoryRequirements: MemoryRequirements2 = undefined;
    vkGetImageMemoryRequirements2(device, &info, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetBufferMemoryRequirements2(device: Device, info: BufferMemoryRequirementsInfo2) MemoryRequirements2 {
    var out_memoryRequirements: MemoryRequirements2 = undefined;
    vkGetBufferMemoryRequirements2(device, &info, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetImageSparseMemoryRequirements2(device: Device, info: ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirements: []SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
    var out_sparseMemoryRequirements: []SparseImageMemoryRequirements2 = undefined;
    var sparseMemoryRequirementCount: u32 = @intCast(u32, sparseMemoryRequirements.len);
    vkGetImageSparseMemoryRequirements2(device, &info, &sparseMemoryRequirementCount, sparseMemoryRequirements.ptr);
    out_sparseMemoryRequirements = sparseMemoryRequirements[0..sparseMemoryRequirementCount];
    return out_sparseMemoryRequirements;
}
pub inline fn GetImageSparseMemoryRequirements2Count(device: Device, info: ImageSparseMemoryRequirementsInfo2) u32 {
    var out_sparseMemoryRequirementCount: u32 = undefined;
    vkGetImageSparseMemoryRequirements2(device, &info, &out_sparseMemoryRequirementCount, null);
    return out_sparseMemoryRequirementCount;
}

pub inline fn GetPhysicalDeviceFeatures2(physicalDevice: PhysicalDevice) PhysicalDeviceFeatures2 {
    var out_features: PhysicalDeviceFeatures2 = undefined;
    vkGetPhysicalDeviceFeatures2(physicalDevice, &out_features);
    return out_features;
}

pub inline fn GetPhysicalDeviceProperties2(physicalDevice: PhysicalDevice) PhysicalDeviceProperties2 {
    var out_properties: PhysicalDeviceProperties2 = undefined;
    vkGetPhysicalDeviceProperties2(physicalDevice, &out_properties);
    return out_properties;
}

pub inline fn GetPhysicalDeviceFormatProperties2(physicalDevice: PhysicalDevice, format: Format) FormatProperties2 {
    var out_formatProperties: FormatProperties2 = undefined;
    vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &out_formatProperties);
    return out_formatProperties;
}

pub inline fn GetPhysicalDeviceImageFormatProperties2(physicalDevice: PhysicalDevice, imageFormatInfo: PhysicalDeviceImageFormatInfo2) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FORMAT_NOT_SUPPORTED,VK_UNDOCUMENTED_ERROR}!ImageFormatProperties2 {
    var out_imageFormatProperties: ImageFormatProperties2 = undefined;
    const result = vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, &imageFormatInfo, &out_imageFormatProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FORMAT_NOT_SUPPORTED => error.VK_FORMAT_NOT_SUPPORTED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_imageFormatProperties;
}

pub inline fn GetPhysicalDeviceQueueFamilyProperties2(physicalDevice: PhysicalDevice, queueFamilyProperties: []QueueFamilyProperties2) []QueueFamilyProperties2 {
    var out_queueFamilyProperties: []QueueFamilyProperties2 = undefined;
    var queueFamilyPropertyCount: u32 = @intCast(u32, queueFamilyProperties.len);
    vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &queueFamilyPropertyCount, queueFamilyProperties.ptr);
    out_queueFamilyProperties = queueFamilyProperties[0..queueFamilyPropertyCount];
    return out_queueFamilyProperties;
}
pub inline fn GetPhysicalDeviceQueueFamilyProperties2Count(physicalDevice: PhysicalDevice) u32 {
    var out_queueFamilyPropertyCount: u32 = undefined;
    vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &out_queueFamilyPropertyCount, null);
    return out_queueFamilyPropertyCount;
}

pub inline fn GetPhysicalDeviceMemoryProperties2(physicalDevice: PhysicalDevice) PhysicalDeviceMemoryProperties2 {
    var out_memoryProperties: PhysicalDeviceMemoryProperties2 = undefined;
    vkGetPhysicalDeviceMemoryProperties2(physicalDevice, &out_memoryProperties);
    return out_memoryProperties;
}

pub inline fn GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice: PhysicalDevice, formatInfo: PhysicalDeviceSparseImageFormatInfo2, properties: []SparseImageFormatProperties2) []SparseImageFormatProperties2 {
    var out_properties: []SparseImageFormatProperties2 = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, &formatInfo, &propertyCount, properties.ptr);
    out_properties = properties[0..propertyCount];
    return out_properties;
}
pub inline fn GetPhysicalDeviceSparseImageFormatProperties2Count(physicalDevice: PhysicalDevice, formatInfo: PhysicalDeviceSparseImageFormatInfo2) u32 {
    var out_propertyCount: u32 = undefined;
    vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, &formatInfo, &out_propertyCount, null);
    return out_propertyCount;
}

pub const TrimCommandPool = vkTrimCommandPool;

pub inline fn GetDeviceQueue2(device: Device, queueInfo: DeviceQueueInfo2) Queue {
    var out_queue: Queue = undefined;
    vkGetDeviceQueue2(device, &queueInfo, &out_queue);
    return out_queue;
}

pub inline fn CreateSamplerYcbcrConversion(device: Device, createInfo: SamplerYcbcrConversionCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!SamplerYcbcrConversion {
    var out_ycbcrConversion: SamplerYcbcrConversion = undefined;
    const result = vkCreateSamplerYcbcrConversion(device, &createInfo, pAllocator, &out_ycbcrConversion);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_ycbcrConversion;
}

pub const DestroySamplerYcbcrConversion = vkDestroySamplerYcbcrConversion;

pub inline fn CreateDescriptorUpdateTemplate(device: Device, createInfo: DescriptorUpdateTemplateCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DescriptorUpdateTemplate {
    var out_descriptorUpdateTemplate: DescriptorUpdateTemplate = undefined;
    const result = vkCreateDescriptorUpdateTemplate(device, &createInfo, pAllocator, &out_descriptorUpdateTemplate);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_descriptorUpdateTemplate;
}

pub const DestroyDescriptorUpdateTemplate = vkDestroyDescriptorUpdateTemplate;
pub const UpdateDescriptorSetWithTemplate = vkUpdateDescriptorSetWithTemplate;

pub inline fn GetPhysicalDeviceExternalBufferProperties(physicalDevice: PhysicalDevice, externalBufferInfo: PhysicalDeviceExternalBufferInfo) ExternalBufferProperties {
    var out_externalBufferProperties: ExternalBufferProperties = undefined;
    vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, &externalBufferInfo, &out_externalBufferProperties);
    return out_externalBufferProperties;
}

pub inline fn GetPhysicalDeviceExternalFenceProperties(physicalDevice: PhysicalDevice, externalFenceInfo: PhysicalDeviceExternalFenceInfo) ExternalFenceProperties {
    var out_externalFenceProperties: ExternalFenceProperties = undefined;
    vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, &externalFenceInfo, &out_externalFenceProperties);
    return out_externalFenceProperties;
}

pub inline fn GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice: PhysicalDevice, externalSemaphoreInfo: PhysicalDeviceExternalSemaphoreInfo) ExternalSemaphoreProperties {
    var out_externalSemaphoreProperties: ExternalSemaphoreProperties = undefined;
    vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &externalSemaphoreInfo, &out_externalSemaphoreProperties);
    return out_externalSemaphoreProperties;
}

pub inline fn GetDescriptorSetLayoutSupport(device: Device, createInfo: DescriptorSetLayoutCreateInfo) DescriptorSetLayoutSupport {
    var out_support: DescriptorSetLayoutSupport = undefined;
    vkGetDescriptorSetLayoutSupport(device, &createInfo, &out_support);
    return out_support;
}


pub const VERSION_1_2 = 1;
// Vulkan 1.2 version number
pub const API_VERSION_1_2 = MAKE_VERSION(1, 2, 0);// Patch version should always be set to 0

pub const DeviceAddress = u64;

pub const MAX_DRIVER_NAME_SIZE = 256;
pub const MAX_DRIVER_INFO_SIZE = 256;

pub const DriverId = extern enum {
    AMD_PROPRIETARY = 1,
    AMD_OPEN_SOURCE = 2,
    MESA_RADV = 3,
    NVIDIA_PROPRIETARY = 4,
    INTEL_PROPRIETARY_WINDOWS = 5,
    INTEL_OPEN_SOURCE_MESA = 6,
    IMAGINATION_PROPRIETARY = 7,
    QUALCOMM_PROPRIETARY = 8,
    ARM_PROPRIETARY = 9,
    GOOGLE_SWIFTSHADER = 10,
    GGP_PROPRIETARY = 11,
    BROADCOM_PROPRIETARY = 12,

    const Self = @This();
    pub const AMD_PROPRIETARY_KHR = Self.AMD_PROPRIETARY;
    pub const AMD_OPEN_SOURCE_KHR = Self.AMD_OPEN_SOURCE;
    pub const MESA_RADV_KHR = Self.MESA_RADV;
    pub const NVIDIA_PROPRIETARY_KHR = Self.NVIDIA_PROPRIETARY;
    pub const INTEL_PROPRIETARY_WINDOWS_KHR = Self.INTEL_PROPRIETARY_WINDOWS;
    pub const INTEL_OPEN_SOURCE_MESA_KHR = Self.INTEL_OPEN_SOURCE_MESA;
    pub const IMAGINATION_PROPRIETARY_KHR = Self.IMAGINATION_PROPRIETARY;
    pub const QUALCOMM_PROPRIETARY_KHR = Self.QUALCOMM_PROPRIETARY;
    pub const ARM_PROPRIETARY_KHR = Self.ARM_PROPRIETARY;
    pub const GOOGLE_SWIFTSHADER_KHR = Self.GOOGLE_SWIFTSHADER;
    pub const GGP_PROPRIETARY_KHR = Self.GGP_PROPRIETARY;
    pub const BROADCOM_PROPRIETARY_KHR = Self.BROADCOM_PROPRIETARY;
};

pub const ShaderFloatControlsIndependence = extern enum {
    T_32_BIT_ONLY = 0,
    ALL = 1,
    NONE = 2,

    const Self = @This();
    pub const T_32_BIT_ONLY_KHR = Self.T_32_BIT_ONLY;
    pub const ALL_KHR = Self.ALL;
    pub const NONE_KHR = Self.NONE;
};

pub const SamplerReductionMode = extern enum {
    WEIGHTED_AVERAGE = 0,
    MIN = 1,
    MAX = 2,

    const Self = @This();
    pub const WEIGHTED_AVERAGE_EXT = Self.WEIGHTED_AVERAGE;
    pub const MIN_EXT = Self.MIN;
    pub const MAX_EXT = Self.MAX;
};

pub const SemaphoreType = extern enum {
    BINARY = 0,
    TIMELINE = 1,

    const Self = @This();
    pub const BINARY_KHR = Self.BINARY;
    pub const TIMELINE_KHR = Self.TIMELINE;
};

pub const ResolveModeFlags = Flags;
pub const ResolveModeFlagBits = struct {
    pub const NONE: ResolveModeFlags = 0;
    pub const SAMPLE_ZERO_BIT: ResolveModeFlags = 0x00000001;
    pub const AVERAGE_BIT: ResolveModeFlags = 0x00000002;
    pub const MIN_BIT: ResolveModeFlags = 0x00000004;
    pub const MAX_BIT: ResolveModeFlags = 0x00000008;

    pub const NONE_KHR = NONE;
    pub const SAMPLE_ZERO_BIT_KHR = SAMPLE_ZERO_BIT;
    pub const AVERAGE_BIT_KHR = AVERAGE_BIT;
    pub const MIN_BIT_KHR = MIN_BIT;
    pub const MAX_BIT_KHR = MAX_BIT;
};

pub const DescriptorBindingFlags = Flags;
pub const DescriptorBindingFlagBits = struct {
    pub const UPDATE_AFTER_BIND_BIT: DescriptorBindingFlags = 0x00000001;
    pub const UPDATE_UNUSED_WHILE_PENDING_BIT: DescriptorBindingFlags = 0x00000002;
    pub const PARTIALLY_BOUND_BIT: DescriptorBindingFlags = 0x00000004;
    pub const VARIABLE_DESCRIPTOR_COUNT_BIT: DescriptorBindingFlags = 0x00000008;

    pub const UPDATE_AFTER_BIND_BIT_EXT = UPDATE_AFTER_BIND_BIT;
    pub const UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = UPDATE_UNUSED_WHILE_PENDING_BIT;
    pub const PARTIALLY_BOUND_BIT_EXT = PARTIALLY_BOUND_BIT;
    pub const VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VARIABLE_DESCRIPTOR_COUNT_BIT;
};

pub const SemaphoreWaitFlags = Flags;
pub const SemaphoreWaitFlagBits = struct {
    pub const ANY_BIT: SemaphoreWaitFlags = 0x00000001;

    pub const ANY_BIT_KHR = ANY_BIT;
};

pub const PhysicalDeviceVulkan11Features = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
    pNext: ?*c_void = null,
    storageBuffer16BitAccess: Bool32,
    uniformAndStorageBuffer16BitAccess: Bool32,
    storagePushConstant16: Bool32,
    storageInputOutput16: Bool32,
    multiview: Bool32,
    multiviewGeometryShader: Bool32,
    multiviewTessellationShader: Bool32,
    variablePointersStorageBuffer: Bool32,
    variablePointers: Bool32,
    protectedMemory: Bool32,
    samplerYcbcrConversion: Bool32,
    shaderDrawParameters: Bool32,
};

pub const PhysicalDeviceVulkan11Properties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
    pNext: ?*c_void = null,
    deviceUUID: [UUID_SIZE]u8,
    driverUUID: [UUID_SIZE]u8,
    deviceLUID: [LUID_SIZE]u8,
    deviceNodeMask: u32,
    deviceLUIDValid: Bool32,
    subgroupSize: u32,
    subgroupSupportedStages: ShaderStageFlags,
    subgroupSupportedOperations: SubgroupFeatureFlags,
    subgroupQuadOperationsInAllStages: Bool32,
    pointClippingBehavior: PointClippingBehavior,
    maxMultiviewViewCount: u32,
    maxMultiviewInstanceIndex: u32,
    protectedNoFault: Bool32,
    maxPerSetDescriptors: u32,
    maxMemoryAllocationSize: DeviceSize,
};

pub const PhysicalDeviceVulkan12Features = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
    pNext: ?*c_void = null,
    samplerMirrorClampToEdge: Bool32,
    drawIndirectCount: Bool32,
    storageBuffer8BitAccess: Bool32,
    uniformAndStorageBuffer8BitAccess: Bool32,
    storagePushConstant8: Bool32,
    shaderBufferInt64Atomics: Bool32,
    shaderSharedInt64Atomics: Bool32,
    shaderFloat16: Bool32,
    shaderInt8: Bool32,
    descriptorIndexing: Bool32,
    shaderInputAttachmentArrayDynamicIndexing: Bool32,
    shaderUniformTexelBufferArrayDynamicIndexing: Bool32,
    shaderStorageTexelBufferArrayDynamicIndexing: Bool32,
    shaderUniformBufferArrayNonUniformIndexing: Bool32,
    shaderSampledImageArrayNonUniformIndexing: Bool32,
    shaderStorageBufferArrayNonUniformIndexing: Bool32,
    shaderStorageImageArrayNonUniformIndexing: Bool32,
    shaderInputAttachmentArrayNonUniformIndexing: Bool32,
    shaderUniformTexelBufferArrayNonUniformIndexing: Bool32,
    shaderStorageTexelBufferArrayNonUniformIndexing: Bool32,
    descriptorBindingUniformBufferUpdateAfterBind: Bool32,
    descriptorBindingSampledImageUpdateAfterBind: Bool32,
    descriptorBindingStorageImageUpdateAfterBind: Bool32,
    descriptorBindingStorageBufferUpdateAfterBind: Bool32,
    descriptorBindingUniformTexelBufferUpdateAfterBind: Bool32,
    descriptorBindingStorageTexelBufferUpdateAfterBind: Bool32,
    descriptorBindingUpdateUnusedWhilePending: Bool32,
    descriptorBindingPartiallyBound: Bool32,
    descriptorBindingVariableDescriptorCount: Bool32,
    runtimeDescriptorArray: Bool32,
    samplerFilterMinmax: Bool32,
    scalarBlockLayout: Bool32,
    imagelessFramebuffer: Bool32,
    uniformBufferStandardLayout: Bool32,
    shaderSubgroupExtendedTypes: Bool32,
    separateDepthStencilLayouts: Bool32,
    hostQueryReset: Bool32,
    timelineSemaphore: Bool32,
    bufferDeviceAddress: Bool32,
    bufferDeviceAddressCaptureReplay: Bool32,
    bufferDeviceAddressMultiDevice: Bool32,
    vulkanMemoryModel: Bool32,
    vulkanMemoryModelDeviceScope: Bool32,
    vulkanMemoryModelAvailabilityVisibilityChains: Bool32,
    shaderOutputViewportIndex: Bool32,
    shaderOutputLayer: Bool32,
    subgroupBroadcastDynamicId: Bool32,
};

pub const ConformanceVersion = extern struct {
    major: u8,
    minor: u8,
    subminor: u8,
    patch: u8,
};

pub const PhysicalDeviceVulkan12Properties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
    pNext: ?*c_void = null,
    driverID: DriverId,
    driverName: [MAX_DRIVER_NAME_SIZE]u8,
    driverInfo: [MAX_DRIVER_INFO_SIZE]u8,
    conformanceVersion: ConformanceVersion,
    denormBehaviorIndependence: ShaderFloatControlsIndependence,
    roundingModeIndependence: ShaderFloatControlsIndependence,
    shaderSignedZeroInfNanPreserveFloat16: Bool32,
    shaderSignedZeroInfNanPreserveFloat32: Bool32,
    shaderSignedZeroInfNanPreserveFloat64: Bool32,
    shaderDenormPreserveFloat16: Bool32,
    shaderDenormPreserveFloat32: Bool32,
    shaderDenormPreserveFloat64: Bool32,
    shaderDenormFlushToZeroFloat16: Bool32,
    shaderDenormFlushToZeroFloat32: Bool32,
    shaderDenormFlushToZeroFloat64: Bool32,
    shaderRoundingModeRTEFloat16: Bool32,
    shaderRoundingModeRTEFloat32: Bool32,
    shaderRoundingModeRTEFloat64: Bool32,
    shaderRoundingModeRTZFloat16: Bool32,
    shaderRoundingModeRTZFloat32: Bool32,
    shaderRoundingModeRTZFloat64: Bool32,
    maxUpdateAfterBindDescriptorsInAllPools: u32,
    shaderUniformBufferArrayNonUniformIndexingNative: Bool32,
    shaderSampledImageArrayNonUniformIndexingNative: Bool32,
    shaderStorageBufferArrayNonUniformIndexingNative: Bool32,
    shaderStorageImageArrayNonUniformIndexingNative: Bool32,
    shaderInputAttachmentArrayNonUniformIndexingNative: Bool32,
    robustBufferAccessUpdateAfterBind: Bool32,
    quadDivergentImplicitLod: Bool32,
    maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    maxPerStageUpdateAfterBindResources: u32,
    maxDescriptorSetUpdateAfterBindSamplers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindSampledImages: u32,
    maxDescriptorSetUpdateAfterBindStorageImages: u32,
    maxDescriptorSetUpdateAfterBindInputAttachments: u32,
    supportedDepthResolveModes: ResolveModeFlags,
    supportedStencilResolveModes: ResolveModeFlags,
    independentResolveNone: Bool32,
    independentResolve: Bool32,
    filterMinmaxSingleComponentFormats: Bool32,
    filterMinmaxImageComponentMapping: Bool32,
    maxTimelineSemaphoreValueDifference: u64,
    framebufferIntegerColorSampleCounts: SampleCountFlags = 0,
};

pub const ImageFormatListCreateInfo = extern struct {
    sType: StructureType = .IMAGE_FORMAT_LIST_CREATE_INFO,
    pNext: ?*const c_void = null,
    viewFormatCount: u32 = 0,
    pViewFormats: [*]const Format = undefined,
};

pub const AttachmentDescription2 = extern struct {
    sType: StructureType = .ATTACHMENT_DESCRIPTION_2,
    pNext: ?*const c_void = null,
    flags: AttachmentDescriptionFlags = 0,
    format: Format,
    samples: SampleCountFlags,
    loadOp: AttachmentLoadOp,
    storeOp: AttachmentStoreOp,
    stencilLoadOp: AttachmentLoadOp,
    stencilStoreOp: AttachmentStoreOp,
    initialLayout: ImageLayout,
    finalLayout: ImageLayout,
};

pub const AttachmentReference2 = extern struct {
    sType: StructureType = .ATTACHMENT_REFERENCE_2,
    pNext: ?*const c_void = null,
    attachment: u32,
    layout: ImageLayout,
    aspectMask: ImageAspectFlags,
};

pub const SubpassDescription2 = extern struct {
    sType: StructureType = .SUBPASS_DESCRIPTION_2,
    pNext: ?*const c_void = null,
    flags: SubpassDescriptionFlags = 0,
    pipelineBindPoint: PipelineBindPoint,
    viewMask: u32,
    inputAttachmentCount: u32 = 0,
    pInputAttachments: [*]const AttachmentReference2 = undefined,
    colorAttachmentCount: u32 = 0,
    pColorAttachments: [*]const AttachmentReference2 = undefined,
    pResolveAttachments: ?[*]const AttachmentReference2 = null,
    pDepthStencilAttachment: ?*const AttachmentReference2 = null,
    preserveAttachmentCount: u32 = 0,
    pPreserveAttachments: [*]const u32 = undefined,
};

pub const SubpassDependency2 = extern struct {
    sType: StructureType = .SUBPASS_DEPENDENCY_2,
    pNext: ?*const c_void = null,
    srcSubpass: u32,
    dstSubpass: u32,
    srcStageMask: PipelineStageFlags,
    dstStageMask: PipelineStageFlags,
    srcAccessMask: AccessFlags = 0,
    dstAccessMask: AccessFlags = 0,
    dependencyFlags: DependencyFlags = 0,
    viewOffset: i32 = 0,
};

pub const RenderPassCreateInfo2 = extern struct {
    sType: StructureType = .RENDER_PASS_CREATE_INFO_2,
    pNext: ?*const c_void = null,
    flags: RenderPassCreateFlags = 0,
    attachmentCount: u32 = 0,
    pAttachments: [*]const AttachmentDescription2 = undefined,
    subpassCount: u32,
    pSubpasses: [*]const SubpassDescription2,
    dependencyCount: u32 = 0,
    pDependencies: [*]const SubpassDependency2 = undefined,
    correlatedViewMaskCount: u32 = 0,
    pCorrelatedViewMasks: [*]const u32 = undefined,
};

pub const SubpassBeginInfo = extern struct {
    sType: StructureType = .SUBPASS_BEGIN_INFO,
    pNext: ?*const c_void = null,
    contents: SubpassContents,
};

pub const SubpassEndInfo = extern struct {
    sType: StructureType = .SUBPASS_END_INFO,
    pNext: ?*const c_void = null,
};

pub const PhysicalDevice8BitStorageFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
    pNext: ?*c_void = null,
    storageBuffer8BitAccess: Bool32,
    uniformAndStorageBuffer8BitAccess: Bool32,
    storagePushConstant8: Bool32,
};

pub const PhysicalDeviceDriverProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DRIVER_PROPERTIES,
    pNext: ?*c_void = null,
    driverID: DriverId,
    driverName: [MAX_DRIVER_NAME_SIZE]u8,
    driverInfo: [MAX_DRIVER_INFO_SIZE]u8,
    conformanceVersion: ConformanceVersion,
};

pub const PhysicalDeviceShaderAtomicInt64Features = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
    pNext: ?*c_void = null,
    shaderBufferInt64Atomics: Bool32,
    shaderSharedInt64Atomics: Bool32,
};

pub const PhysicalDeviceShaderFloat16Int8Features = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
    pNext: ?*c_void = null,
    shaderFloat16: Bool32,
    shaderInt8: Bool32,
};

pub const PhysicalDeviceFloatControlsProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
    pNext: ?*c_void = null,
    denormBehaviorIndependence: ShaderFloatControlsIndependence,
    roundingModeIndependence: ShaderFloatControlsIndependence,
    shaderSignedZeroInfNanPreserveFloat16: Bool32,
    shaderSignedZeroInfNanPreserveFloat32: Bool32,
    shaderSignedZeroInfNanPreserveFloat64: Bool32,
    shaderDenormPreserveFloat16: Bool32,
    shaderDenormPreserveFloat32: Bool32,
    shaderDenormPreserveFloat64: Bool32,
    shaderDenormFlushToZeroFloat16: Bool32,
    shaderDenormFlushToZeroFloat32: Bool32,
    shaderDenormFlushToZeroFloat64: Bool32,
    shaderRoundingModeRTEFloat16: Bool32,
    shaderRoundingModeRTEFloat32: Bool32,
    shaderRoundingModeRTEFloat64: Bool32,
    shaderRoundingModeRTZFloat16: Bool32,
    shaderRoundingModeRTZFloat32: Bool32,
    shaderRoundingModeRTZFloat64: Bool32,
};

pub const DescriptorSetLayoutBindingFlagsCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
    pNext: ?*const c_void = null,
    bindingCount: u32 = 0,
    pBindingFlags: ?[*]const DescriptorBindingFlags = null,
};

pub const PhysicalDeviceDescriptorIndexingFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
    pNext: ?*c_void = null,
    shaderInputAttachmentArrayDynamicIndexing: Bool32,
    shaderUniformTexelBufferArrayDynamicIndexing: Bool32,
    shaderStorageTexelBufferArrayDynamicIndexing: Bool32,
    shaderUniformBufferArrayNonUniformIndexing: Bool32,
    shaderSampledImageArrayNonUniformIndexing: Bool32,
    shaderStorageBufferArrayNonUniformIndexing: Bool32,
    shaderStorageImageArrayNonUniformIndexing: Bool32,
    shaderInputAttachmentArrayNonUniformIndexing: Bool32,
    shaderUniformTexelBufferArrayNonUniformIndexing: Bool32,
    shaderStorageTexelBufferArrayNonUniformIndexing: Bool32,
    descriptorBindingUniformBufferUpdateAfterBind: Bool32,
    descriptorBindingSampledImageUpdateAfterBind: Bool32,
    descriptorBindingStorageImageUpdateAfterBind: Bool32,
    descriptorBindingStorageBufferUpdateAfterBind: Bool32,
    descriptorBindingUniformTexelBufferUpdateAfterBind: Bool32,
    descriptorBindingStorageTexelBufferUpdateAfterBind: Bool32,
    descriptorBindingUpdateUnusedWhilePending: Bool32,
    descriptorBindingPartiallyBound: Bool32,
    descriptorBindingVariableDescriptorCount: Bool32,
    runtimeDescriptorArray: Bool32,
};

pub const PhysicalDeviceDescriptorIndexingProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
    pNext: ?*c_void = null,
    maxUpdateAfterBindDescriptorsInAllPools: u32,
    shaderUniformBufferArrayNonUniformIndexingNative: Bool32,
    shaderSampledImageArrayNonUniformIndexingNative: Bool32,
    shaderStorageBufferArrayNonUniformIndexingNative: Bool32,
    shaderStorageImageArrayNonUniformIndexingNative: Bool32,
    shaderInputAttachmentArrayNonUniformIndexingNative: Bool32,
    robustBufferAccessUpdateAfterBind: Bool32,
    quadDivergentImplicitLod: Bool32,
    maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    maxPerStageUpdateAfterBindResources: u32,
    maxDescriptorSetUpdateAfterBindSamplers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    maxDescriptorSetUpdateAfterBindSampledImages: u32,
    maxDescriptorSetUpdateAfterBindStorageImages: u32,
    maxDescriptorSetUpdateAfterBindInputAttachments: u32,
};

pub const DescriptorSetVariableDescriptorCountAllocateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    descriptorSetCount: u32 = 0,
    pDescriptorCounts: [*]const u32 = undefined,
};

pub const DescriptorSetVariableDescriptorCountLayoutSupport = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
    pNext: ?*c_void = null,
    maxVariableDescriptorCount: u32,
};

pub const SubpassDescriptionDepthStencilResolve = extern struct {
    sType: StructureType = .SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
    pNext: ?*const c_void = null,
    depthResolveMode: ResolveModeFlags,
    stencilResolveMode: ResolveModeFlags,
    pDepthStencilResolveAttachment: ?*const AttachmentReference2 = null,
};

pub const PhysicalDeviceDepthStencilResolveProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
    pNext: ?*c_void = null,
    supportedDepthResolveModes: ResolveModeFlags,
    supportedStencilResolveModes: ResolveModeFlags,
    independentResolveNone: Bool32,
    independentResolve: Bool32,
};

pub const PhysicalDeviceScalarBlockLayoutFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
    pNext: ?*c_void = null,
    scalarBlockLayout: Bool32,
};

pub const ImageStencilUsageCreateInfo = extern struct {
    sType: StructureType = .IMAGE_STENCIL_USAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    stencilUsage: ImageUsageFlags,
};

pub const SamplerReductionModeCreateInfo = extern struct {
    sType: StructureType = .SAMPLER_REDUCTION_MODE_CREATE_INFO,
    pNext: ?*const c_void = null,
    reductionMode: SamplerReductionMode,
};

pub const PhysicalDeviceSamplerFilterMinmaxProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
    pNext: ?*c_void = null,
    filterMinmaxSingleComponentFormats: Bool32,
    filterMinmaxImageComponentMapping: Bool32,
};

pub const PhysicalDeviceVulkanMemoryModelFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
    pNext: ?*c_void = null,
    vulkanMemoryModel: Bool32,
    vulkanMemoryModelDeviceScope: Bool32,
    vulkanMemoryModelAvailabilityVisibilityChains: Bool32,
};

pub const PhysicalDeviceImagelessFramebufferFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
    pNext: ?*c_void = null,
    imagelessFramebuffer: Bool32,
};

pub const FramebufferAttachmentImageInfo = extern struct {
    sType: StructureType = .FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
    pNext: ?*const c_void = null,
    flags: ImageCreateFlags = 0,
    usage: ImageUsageFlags,
    width: u32,
    height: u32,
    layerCount: u32,
    viewFormatCount: u32 = 0,
    pViewFormats: [*]const Format = undefined,
};

pub const FramebufferAttachmentsCreateInfo = extern struct {
    sType: StructureType = .FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
    pNext: ?*const c_void = null,
    attachmentImageInfoCount: u32 = 0,
    pAttachmentImageInfos: [*]const FramebufferAttachmentImageInfo = undefined,
};

pub const RenderPassAttachmentBeginInfo = extern struct {
    sType: StructureType = .RENDER_PASS_ATTACHMENT_BEGIN_INFO,
    pNext: ?*const c_void = null,
    attachmentCount: u32 = 0,
    pAttachments: [*]const ImageView = undefined,
};

pub const PhysicalDeviceUniformBufferStandardLayoutFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
    pNext: ?*c_void = null,
    uniformBufferStandardLayout: Bool32,
};

pub const PhysicalDeviceShaderSubgroupExtendedTypesFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
    pNext: ?*c_void = null,
    shaderSubgroupExtendedTypes: Bool32,
};

pub const PhysicalDeviceSeparateDepthStencilLayoutsFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
    pNext: ?*c_void = null,
    separateDepthStencilLayouts: Bool32,
};

pub const AttachmentReferenceStencilLayout = extern struct {
    sType: StructureType = .ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
    pNext: ?*c_void = null,
    stencilLayout: ImageLayout,
};

pub const AttachmentDescriptionStencilLayout = extern struct {
    sType: StructureType = .ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
    pNext: ?*c_void = null,
    stencilInitialLayout: ImageLayout,
    stencilFinalLayout: ImageLayout,
};

pub const PhysicalDeviceHostQueryResetFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
    pNext: ?*c_void = null,
    hostQueryReset: Bool32,
};

pub const PhysicalDeviceTimelineSemaphoreFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
    pNext: ?*c_void = null,
    timelineSemaphore: Bool32,
};

pub const PhysicalDeviceTimelineSemaphoreProperties = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
    pNext: ?*c_void = null,
    maxTimelineSemaphoreValueDifference: u64,
};

pub const SemaphoreTypeCreateInfo = extern struct {
    sType: StructureType = .SEMAPHORE_TYPE_CREATE_INFO,
    pNext: ?*const c_void = null,
    semaphoreType: SemaphoreType,
    initialValue: u64,
};

pub const TimelineSemaphoreSubmitInfo = extern struct {
    sType: StructureType = .TIMELINE_SEMAPHORE_SUBMIT_INFO,
    pNext: ?*const c_void = null,
    waitSemaphoreValueCount: u32 = 0,
    pWaitSemaphoreValues: ?[*]const u64 = null,
    signalSemaphoreValueCount: u32 = 0,
    pSignalSemaphoreValues: ?[*]const u64 = null,
};

pub const SemaphoreWaitInfo = extern struct {
    sType: StructureType = .SEMAPHORE_WAIT_INFO,
    pNext: ?*const c_void = null,
    flags: SemaphoreWaitFlags = 0,
    semaphoreCount: u32,
    pSemaphores: [*]const Semaphore,
    pValues: [*]const u64,
};

pub const SemaphoreSignalInfo = extern struct {
    sType: StructureType = .SEMAPHORE_SIGNAL_INFO,
    pNext: ?*const c_void = null,
    semaphore: Semaphore,
    value: u64,
};

pub const PhysicalDeviceBufferDeviceAddressFeatures = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
    pNext: ?*c_void = null,
    bufferDeviceAddress: Bool32,
    bufferDeviceAddressCaptureReplay: Bool32,
    bufferDeviceAddressMultiDevice: Bool32,
};

pub const BufferDeviceAddressInfo = extern struct {
    sType: StructureType = .BUFFER_DEVICE_ADDRESS_INFO,
    pNext: ?*const c_void = null,
    buffer: Buffer,
};

pub const BufferOpaqueCaptureAddressCreateInfo = extern struct {
    sType: StructureType = .BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
    pNext: ?*const c_void = null,
    opaqueCaptureAddress: u64,
};

pub const MemoryOpaqueCaptureAddressAllocateInfo = extern struct {
    sType: StructureType = .MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    opaqueCaptureAddress: u64,
};

pub const DeviceMemoryOpaqueCaptureAddressInfo = extern struct {
    sType: StructureType = .DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
    pNext: ?*const c_void = null,
    memory: DeviceMemory,
};

pub extern fn vkCmdDrawIndirectCount(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDrawIndexedIndirectCount(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub extern fn vkCreateRenderPass2(
    device: Device,
    pCreateInfo: *const RenderPassCreateInfo2,
    pAllocator: ?*const AllocationCallbacks,
    pRenderPass: *RenderPass,
) Result;

pub extern fn vkCmdBeginRenderPass2(
    commandBuffer: CommandBuffer,
    pRenderPassBegin: *const RenderPassBeginInfo,
    pSubpassBeginInfo: *const SubpassBeginInfo,
) void;

pub extern fn vkCmdNextSubpass2(
    commandBuffer: CommandBuffer,
    pSubpassBeginInfo: *const SubpassBeginInfo,
    pSubpassEndInfo: *const SubpassEndInfo,
) void;

pub extern fn vkCmdEndRenderPass2(
    commandBuffer: CommandBuffer,
    pSubpassEndInfo: *const SubpassEndInfo,
) void;

pub extern fn vkResetQueryPool(
    device: Device,
    queryPool: QueryPool,
    firstQuery: u32,
    queryCount: u32,
) void;

pub extern fn vkGetSemaphoreCounterValue(
    device: Device,
    semaphore: Semaphore,
    pValue: *u64,
) Result;

pub extern fn vkWaitSemaphores(
    device: Device,
    pWaitInfo: *const SemaphoreWaitInfo,
    timeout: u64,
) Result;

pub extern fn vkSignalSemaphore(
    device: Device,
    pSignalInfo: *const SemaphoreSignalInfo,
) Result;

pub extern fn vkGetBufferDeviceAddress(
    device: Device,
    pInfo: *const BufferDeviceAddressInfo,
) DeviceAddress;

pub extern fn vkGetBufferOpaqueCaptureAddress(
    device: Device,
    pInfo: *const BufferDeviceAddressInfo,
) u64;

pub extern fn vkGetDeviceMemoryOpaqueCaptureAddress(
    device: Device,
    pInfo: *const DeviceMemoryOpaqueCaptureAddressInfo,
) u64;

pub const CmdDrawIndirectCount = vkCmdDrawIndirectCount;
pub const CmdDrawIndexedIndirectCount = vkCmdDrawIndexedIndirectCount;

pub inline fn CreateRenderPass2(device: Device, createInfo: RenderPassCreateInfo2, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!RenderPass {
    var out_renderPass: RenderPass = undefined;
    const result = vkCreateRenderPass2(device, &createInfo, pAllocator, &out_renderPass);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_renderPass;
}

pub inline fn CmdBeginRenderPass2(commandBuffer: CommandBuffer, renderPassBegin: RenderPassBeginInfo, subpassBeginInfo: SubpassBeginInfo) void {
    vkCmdBeginRenderPass2(commandBuffer, &renderPassBegin, &subpassBeginInfo);
}

pub inline fn CmdNextSubpass2(commandBuffer: CommandBuffer, subpassBeginInfo: SubpassBeginInfo, subpassEndInfo: SubpassEndInfo) void {
    vkCmdNextSubpass2(commandBuffer, &subpassBeginInfo, &subpassEndInfo);
}

pub inline fn CmdEndRenderPass2(commandBuffer: CommandBuffer, subpassEndInfo: SubpassEndInfo) void {
    vkCmdEndRenderPass2(commandBuffer, &subpassEndInfo);
}

pub const ResetQueryPool = vkResetQueryPool;

pub inline fn GetSemaphoreCounterValue(device: Device, semaphore: Semaphore) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!u64 {
    var out_value: u64 = undefined;
    const result = vkGetSemaphoreCounterValue(device, semaphore, &out_value);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_value;
}

pub inline fn WaitSemaphores(device: Device, waitInfo: SemaphoreWaitInfo, timeout: u64) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkWaitSemaphores(device, &waitInfo, timeout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn SignalSemaphore(device: Device, signalInfo: SemaphoreSignalInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkSignalSemaphore(device, &signalInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetBufferDeviceAddress(device: Device, info: BufferDeviceAddressInfo) DeviceAddress {
    const result = vkGetBufferDeviceAddress(device, &info);
    return result;
}

pub inline fn GetBufferOpaqueCaptureAddress(device: Device, info: BufferDeviceAddressInfo) u64 {
    const result = vkGetBufferOpaqueCaptureAddress(device, &info);
    return result;
}

pub inline fn GetDeviceMemoryOpaqueCaptureAddress(device: Device, info: DeviceMemoryOpaqueCaptureAddressInfo) u64 {
    const result = vkGetDeviceMemoryOpaqueCaptureAddress(device, &info);
    return result;
}


pub const KHR_surface = 1;
pub const SurfaceKHR = *@OpaqueType();

pub const KHR_SURFACE_SPEC_VERSION = 25;
pub const KHR_SURFACE_EXTENSION_NAME = c"VK_KHR_surface";

pub const ColorSpaceKHR = extern enum {
    SRGB_NONLINEAR = 0,
    DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    DISPLAY_P3_LINEAR_EXT = 1000104003,
    DCI_P3_NONLINEAR_EXT = 1000104004,
    BT709_LINEAR_EXT = 1000104005,
    BT709_NONLINEAR_EXT = 1000104006,
    BT2020_LINEAR_EXT = 1000104007,
    HDR10_ST2084_EXT = 1000104008,
    DOLBYVISION_EXT = 1000104009,
    HDR10_HLG_EXT = 1000104010,
    ADOBERGB_LINEAR_EXT = 1000104011,
    ADOBERGB_NONLINEAR_EXT = 1000104012,
    PASS_THROUGH_EXT = 1000104013,
    EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    DISPLAY_NATIVE_AMD = 1000213000,

    const Self = @This();
    pub const COLORSPACE_SRGB_NONLINEAR = Self.SRGB_NONLINEAR;
    pub const DCI_P3_LINEAR_EXT = Self.DISPLAY_P3_LINEAR_EXT;
};

pub const PresentModeKHR = extern enum {
    IMMEDIATE = 0,
    MAILBOX = 1,
    FIFO = 2,
    FIFO_RELAXED = 3,
    SHARED_DEMAND_REFRESH = 1000111000,
    SHARED_CONTINUOUS_REFRESH = 1000111001,
};

pub const SurfaceTransformFlagsKHR = Flags;
pub const SurfaceTransformFlagBitsKHR = struct {
    pub const IDENTITY_BIT: SurfaceTransformFlagsKHR = 0x00000001;
    pub const ROTATE_90_BIT: SurfaceTransformFlagsKHR = 0x00000002;
    pub const ROTATE_180_BIT: SurfaceTransformFlagsKHR = 0x00000004;
    pub const ROTATE_270_BIT: SurfaceTransformFlagsKHR = 0x00000008;
    pub const HORIZONTAL_MIRROR_BIT: SurfaceTransformFlagsKHR = 0x00000010;
    pub const HORIZONTAL_MIRROR_ROTATE_90_BIT: SurfaceTransformFlagsKHR = 0x00000020;
    pub const HORIZONTAL_MIRROR_ROTATE_180_BIT: SurfaceTransformFlagsKHR = 0x00000040;
    pub const HORIZONTAL_MIRROR_ROTATE_270_BIT: SurfaceTransformFlagsKHR = 0x00000080;
    pub const INHERIT_BIT: SurfaceTransformFlagsKHR = 0x00000100;
};

pub const CompositeAlphaFlagsKHR = Flags;
pub const CompositeAlphaFlagBitsKHR = struct {
    pub const OPAQUE_BIT: CompositeAlphaFlagsKHR = 0x00000001;
    pub const PRE_MULTIPLIED_BIT: CompositeAlphaFlagsKHR = 0x00000002;
    pub const POST_MULTIPLIED_BIT: CompositeAlphaFlagsKHR = 0x00000004;
    pub const INHERIT_BIT: CompositeAlphaFlagsKHR = 0x00000008;
};

pub const SurfaceCapabilitiesKHR = extern struct {
    minImageCount: u32,
    maxImageCount: u32,
    currentExtent: Extent2D,
    minImageExtent: Extent2D,
    maxImageExtent: Extent2D,
    maxImageArrayLayers: u32,
    supportedTransforms: SurfaceTransformFlagsKHR = 0,
    currentTransform: SurfaceTransformFlagsKHR,
    supportedCompositeAlpha: CompositeAlphaFlagsKHR = 0,
    supportedUsageFlags: ImageUsageFlags = 0,
};

pub const SurfaceFormatKHR = extern struct {
    format: Format,
    colorSpace: ColorSpaceKHR,
};

pub extern fn vkDestroySurfaceKHR(
    instance: Instance,
    surface: ?SurfaceKHR,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetPhysicalDeviceSurfaceSupportKHR(
    physicalDevice: PhysicalDevice,
    queueFamilyIndex: u32,
    surface: SurfaceKHR,
    pSupported: *Bool32,
) Result;

pub extern fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    physicalDevice: PhysicalDevice,
    surface: SurfaceKHR,
    pSurfaceCapabilities: *SurfaceCapabilitiesKHR,
) Result;

pub extern fn vkGetPhysicalDeviceSurfaceFormatsKHR(
    physicalDevice: PhysicalDevice,
    surface: SurfaceKHR,
    pSurfaceFormatCount: *u32,
    pSurfaceFormats: ?[*]SurfaceFormatKHR,
) Result;

pub extern fn vkGetPhysicalDeviceSurfacePresentModesKHR(
    physicalDevice: PhysicalDevice,
    surface: SurfaceKHR,
    pPresentModeCount: *u32,
    pPresentModes: ?[*]PresentModeKHR,
) Result;

pub const DestroySurfaceKHR = vkDestroySurfaceKHR;

pub inline fn GetPhysicalDeviceSurfaceSupportKHR(physicalDevice: PhysicalDevice, queueFamilyIndex: u32, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!Bool32 {
    var out_supported: Bool32 = undefined;
    const result = vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, &out_supported);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_supported;
}

pub inline fn GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!SurfaceCapabilitiesKHR {
    var out_surfaceCapabilities: SurfaceCapabilitiesKHR = undefined;
    const result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &out_surfaceCapabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surfaceCapabilities;
}

pub const GetPhysicalDeviceSurfaceFormatsKHRResult = struct {
    result: Result,
    surfaceFormats: []SurfaceFormatKHR,
};
pub inline fn GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR, surfaceFormats: []SurfaceFormatKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceSurfaceFormatsKHRResult {
    var returnValues: GetPhysicalDeviceSurfaceFormatsKHRResult = undefined;
    var surfaceFormatCount: u32 = @intCast(u32, surfaceFormats.len);
    const result = vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &surfaceFormatCount, surfaceFormats.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.surfaceFormats = surfaceFormats[0..surfaceFormatCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceSurfaceFormatsCountKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_surfaceFormatCount: u32 = undefined;
    const result = vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &out_surfaceFormatCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surfaceFormatCount;
}

pub const GetPhysicalDeviceSurfacePresentModesKHRResult = struct {
    result: Result,
    presentModes: []PresentModeKHR,
};
pub inline fn GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR, presentModes: []PresentModeKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceSurfacePresentModesKHRResult {
    var returnValues: GetPhysicalDeviceSurfacePresentModesKHRResult = undefined;
    var presentModeCount: u32 = @intCast(u32, presentModes.len);
    const result = vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, presentModes.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.presentModes = presentModes[0..presentModeCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceSurfacePresentModesCountKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_presentModeCount: u32 = undefined;
    const result = vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &out_presentModeCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_presentModeCount;
}


pub const KHR_swapchain = 1;
pub const SwapchainKHR = *@OpaqueType();

pub const KHR_SWAPCHAIN_SPEC_VERSION = 70;
pub const KHR_SWAPCHAIN_EXTENSION_NAME = c"VK_KHR_swapchain";

pub const SwapchainCreateFlagsKHR = Flags;
pub const SwapchainCreateFlagBitsKHR = struct {
    pub const SPLIT_INSTANCE_BIND_REGIONS_BIT: SwapchainCreateFlagsKHR = 0x00000001;
    pub const PROTECTED_BIT: SwapchainCreateFlagsKHR = 0x00000002;
    pub const MUTABLE_FORMAT_BIT: SwapchainCreateFlagsKHR = 0x00000004;
};

pub const DeviceGroupPresentModeFlagsKHR = Flags;
pub const DeviceGroupPresentModeFlagBitsKHR = struct {
    pub const LOCAL_BIT: DeviceGroupPresentModeFlagsKHR = 0x00000001;
    pub const REMOTE_BIT: DeviceGroupPresentModeFlagsKHR = 0x00000002;
    pub const SUM_BIT: DeviceGroupPresentModeFlagsKHR = 0x00000004;
    pub const LOCAL_MULTI_DEVICE_BIT: DeviceGroupPresentModeFlagsKHR = 0x00000008;
};

pub const SwapchainCreateInfoKHR = extern struct {
    sType: StructureType = .SWAPCHAIN_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    flags: SwapchainCreateFlagsKHR = 0,
    surface: SurfaceKHR,
    minImageCount: u32,
    imageFormat: Format,
    imageColorSpace: ColorSpaceKHR,
    imageExtent: Extent2D,
    imageArrayLayers: u32,
    imageUsage: ImageUsageFlags,
    imageSharingMode: SharingMode,
    queueFamilyIndexCount: u32 = 0,
    pQueueFamilyIndices: [*]const u32 = undefined,
    preTransform: SurfaceTransformFlagsKHR,
    compositeAlpha: CompositeAlphaFlagsKHR,
    presentMode: PresentModeKHR,
    clipped: Bool32,
    oldSwapchain: ?SwapchainKHR = null,
};

pub const PresentInfoKHR = extern struct {
    sType: StructureType = .PRESENT_INFO_KHR,
    pNext: ?*const c_void = null,
    waitSemaphoreCount: u32 = 0,
    pWaitSemaphores: [*]const Semaphore = undefined,
    swapchainCount: u32,
    pSwapchains: [*]const SwapchainKHR,
    pImageIndices: [*]const u32,
    pResults: ?[*]Result = null,
};

pub const ImageSwapchainCreateInfoKHR = extern struct {
    sType: StructureType = .IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    swapchain: ?SwapchainKHR = null,
};

pub const BindImageMemorySwapchainInfoKHR = extern struct {
    sType: StructureType = .BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    pNext: ?*const c_void = null,
    swapchain: SwapchainKHR,
    imageIndex: u32,
};

pub const AcquireNextImageInfoKHR = extern struct {
    sType: StructureType = .ACQUIRE_NEXT_IMAGE_INFO_KHR,
    pNext: ?*const c_void = null,
    swapchain: SwapchainKHR,
    timeout: u64,
    semaphore: ?Semaphore = null,
    fence: ?Fence = null,
    deviceMask: u32,
};

pub const DeviceGroupPresentCapabilitiesKHR = extern struct {
    sType: StructureType = .DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    pNext: ?*const c_void = null,
    presentMask: [MAX_DEVICE_GROUP_SIZE]u32,
    modes: DeviceGroupPresentModeFlagsKHR,
};

pub const DeviceGroupPresentInfoKHR = extern struct {
    sType: StructureType = .DEVICE_GROUP_PRESENT_INFO_KHR,
    pNext: ?*const c_void = null,
    swapchainCount: u32 = 0,
    pDeviceMasks: [*]const u32 = undefined,
    mode: DeviceGroupPresentModeFlagsKHR,
};

pub const DeviceGroupSwapchainCreateInfoKHR = extern struct {
    sType: StructureType = .DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    modes: DeviceGroupPresentModeFlagsKHR,
};

pub extern fn vkCreateSwapchainKHR(
    device: Device,
    pCreateInfo: *const SwapchainCreateInfoKHR,
    pAllocator: ?*const AllocationCallbacks,
    pSwapchain: *SwapchainKHR,
) Result;

pub extern fn vkDestroySwapchainKHR(
    device: Device,
    swapchain: ?SwapchainKHR,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetSwapchainImagesKHR(
    device: Device,
    swapchain: SwapchainKHR,
    pSwapchainImageCount: *u32,
    pSwapchainImages: ?[*]Image,
) Result;

pub extern fn vkAcquireNextImageKHR(
    device: Device,
    swapchain: SwapchainKHR,
    timeout: u64,
    semaphore: ?Semaphore,
    fence: ?Fence,
    pImageIndex: *u32,
) Result;

pub extern fn vkQueuePresentKHR(
    queue: Queue,
    pPresentInfo: *const PresentInfoKHR,
) Result;

pub extern fn vkGetDeviceGroupPresentCapabilitiesKHR(
    device: Device,
    pDeviceGroupPresentCapabilities: *DeviceGroupPresentCapabilitiesKHR,
) Result;

pub extern fn vkGetDeviceGroupSurfacePresentModesKHR(
    device: Device,
    surface: SurfaceKHR,
    pModes: *DeviceGroupPresentModeFlagsKHR,
) Result;

pub extern fn vkGetPhysicalDevicePresentRectanglesKHR(
    physicalDevice: PhysicalDevice,
    surface: SurfaceKHR,
    pRectCount: *u32,
    pRects: ?[*]Rect2D,
) Result;

pub extern fn vkAcquireNextImage2KHR(
    device: Device,
    pAcquireInfo: *const AcquireNextImageInfoKHR,
    pImageIndex: *u32,
) Result;

pub inline fn CreateSwapchainKHR(device: Device, createInfo: SwapchainCreateInfoKHR, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_SURFACE_LOST_KHR,VK_NATIVE_WINDOW_IN_USE_KHR,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!SwapchainKHR {
    var out_swapchain: SwapchainKHR = undefined;
    const result = vkCreateSwapchainKHR(device, &createInfo, pAllocator, &out_swapchain);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            .ERROR_NATIVE_WINDOW_IN_USE_KHR => error.VK_NATIVE_WINDOW_IN_USE_KHR,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_swapchain;
}

pub const DestroySwapchainKHR = vkDestroySwapchainKHR;

pub const GetSwapchainImagesKHRResult = struct {
    result: Result,
    swapchainImages: []Image,
};
pub inline fn GetSwapchainImagesKHR(device: Device, swapchain: SwapchainKHR, swapchainImages: []Image) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetSwapchainImagesKHRResult {
    var returnValues: GetSwapchainImagesKHRResult = undefined;
    var swapchainImageCount: u32 = @intCast(u32, swapchainImages.len);
    const result = vkGetSwapchainImagesKHR(device, swapchain, &swapchainImageCount, swapchainImages.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.swapchainImages = swapchainImages[0..swapchainImageCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetSwapchainImagesCountKHR(device: Device, swapchain: SwapchainKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_swapchainImageCount: u32 = undefined;
    const result = vkGetSwapchainImagesKHR(device, swapchain, &out_swapchainImageCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_swapchainImageCount;
}

pub const AcquireNextImageKHRResult = struct {
    result: Result,
    imageIndex: u32,
};
pub inline fn AcquireNextImageKHR(device: Device, swapchain: SwapchainKHR, timeout: u64, semaphore: ?Semaphore, fence: ?Fence) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_UNDOCUMENTED_ERROR}!AcquireNextImageKHRResult {
    var returnValues: AcquireNextImageKHRResult = undefined;
    const result = vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, &returnValues.imageIndex);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            .ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => error.VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.result = result;
    return returnValues;
}

pub inline fn QueuePresentKHR(queue: Queue, presentInfo: PresentInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkQueuePresentKHR(queue, &presentInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            .ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => error.VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn GetDeviceGroupPresentCapabilitiesKHR(device: Device) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DeviceGroupPresentCapabilitiesKHR {
    var out_deviceGroupPresentCapabilities: DeviceGroupPresentCapabilitiesKHR = undefined;
    const result = vkGetDeviceGroupPresentCapabilitiesKHR(device, &out_deviceGroupPresentCapabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_deviceGroupPresentCapabilities;
}

pub inline fn GetDeviceGroupSurfacePresentModesKHR(device: Device, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!DeviceGroupPresentModeFlagsKHR {
    var out_modes: DeviceGroupPresentModeFlagsKHR = undefined;
    const result = vkGetDeviceGroupSurfacePresentModesKHR(device, surface, &out_modes);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_modes;
}

pub const GetPhysicalDevicePresentRectanglesKHRResult = struct {
    result: Result,
    rects: []Rect2D,
};
pub inline fn GetPhysicalDevicePresentRectanglesKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR, rects: []Rect2D) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDevicePresentRectanglesKHRResult {
    var returnValues: GetPhysicalDevicePresentRectanglesKHRResult = undefined;
    var rectCount: u32 = @intCast(u32, rects.len);
    const result = vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, &rectCount, rects.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.rects = rects[0..rectCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDevicePresentRectanglesCountKHR(physicalDevice: PhysicalDevice, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_rectCount: u32 = undefined;
    const result = vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, &out_rectCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_rectCount;
}

pub const AcquireNextImage2KHRResult = struct {
    result: Result,
    imageIndex: u32,
};
pub inline fn AcquireNextImage2KHR(device: Device, acquireInfo: AcquireNextImageInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_UNDOCUMENTED_ERROR}!AcquireNextImage2KHRResult {
    var returnValues: AcquireNextImage2KHRResult = undefined;
    const result = vkAcquireNextImage2KHR(device, &acquireInfo, &returnValues.imageIndex);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            .ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => error.VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.result = result;
    return returnValues;
}


pub const KHR_display = 1;
pub const DisplayKHR = *@OpaqueType();
pub const DisplayModeKHR = *@OpaqueType();

pub const KHR_DISPLAY_SPEC_VERSION = 23;
pub const KHR_DISPLAY_EXTENSION_NAME = c"VK_KHR_display";

pub const DisplayPlaneAlphaFlagsKHR = Flags;
pub const DisplayPlaneAlphaFlagBitsKHR = struct {
    pub const OPAQUE_BIT: DisplayPlaneAlphaFlagsKHR = 0x00000001;
    pub const GLOBAL_BIT: DisplayPlaneAlphaFlagsKHR = 0x00000002;
    pub const PER_PIXEL_BIT: DisplayPlaneAlphaFlagsKHR = 0x00000004;
    pub const PER_PIXEL_PREMULTIPLIED_BIT: DisplayPlaneAlphaFlagsKHR = 0x00000008;
};

pub const DisplayModeCreateFlagsKHR = Flags;
pub const DisplaySurfaceCreateFlagsKHR = Flags;

pub const DisplayPropertiesKHR = extern struct {
    display: DisplayKHR,
    displayName: CString,
    physicalDimensions: Extent2D,
    physicalResolution: Extent2D,
    supportedTransforms: SurfaceTransformFlagsKHR = 0,
    planeReorderPossible: Bool32,
    persistentContent: Bool32,
};

pub const DisplayModeParametersKHR = extern struct {
    visibleRegion: Extent2D,
    refreshRate: u32,
};

pub const DisplayModePropertiesKHR = extern struct {
    displayMode: DisplayModeKHR,
    parameters: DisplayModeParametersKHR,
};

pub const DisplayModeCreateInfoKHR = extern struct {
    sType: StructureType = .DISPLAY_MODE_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    flags: DisplayModeCreateFlagsKHR = 0,
    parameters: DisplayModeParametersKHR,
};

pub const DisplayPlaneCapabilitiesKHR = extern struct {
    supportedAlpha: DisplayPlaneAlphaFlagsKHR = 0,
    minSrcPosition: Offset2D,
    maxSrcPosition: Offset2D,
    minSrcExtent: Extent2D,
    maxSrcExtent: Extent2D,
    minDstPosition: Offset2D,
    maxDstPosition: Offset2D,
    minDstExtent: Extent2D,
    maxDstExtent: Extent2D,
};

pub const DisplayPlanePropertiesKHR = extern struct {
    currentDisplay: DisplayKHR,
    currentStackIndex: u32,
};

pub const DisplaySurfaceCreateInfoKHR = extern struct {
    sType: StructureType = .DISPLAY_SURFACE_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    flags: DisplaySurfaceCreateFlagsKHR = 0,
    displayMode: DisplayModeKHR,
    planeIndex: u32,
    planeStackIndex: u32,
    transform: SurfaceTransformFlagsKHR,
    globalAlpha: f32,
    alphaMode: DisplayPlaneAlphaFlagsKHR,
    imageExtent: Extent2D,
};

pub extern fn vkGetPhysicalDeviceDisplayPropertiesKHR(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayPropertiesKHR,
) Result;

pub extern fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayPlanePropertiesKHR,
) Result;

pub extern fn vkGetDisplayPlaneSupportedDisplaysKHR(
    physicalDevice: PhysicalDevice,
    planeIndex: u32,
    pDisplayCount: *u32,
    pDisplays: ?[*]DisplayKHR,
) Result;

pub extern fn vkGetDisplayModePropertiesKHR(
    physicalDevice: PhysicalDevice,
    display: DisplayKHR,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayModePropertiesKHR,
) Result;

pub extern fn vkCreateDisplayModeKHR(
    physicalDevice: PhysicalDevice,
    display: DisplayKHR,
    pCreateInfo: *const DisplayModeCreateInfoKHR,
    pAllocator: ?*const AllocationCallbacks,
    pMode: *DisplayModeKHR,
) Result;

pub extern fn vkGetDisplayPlaneCapabilitiesKHR(
    physicalDevice: PhysicalDevice,
    mode: DisplayModeKHR,
    planeIndex: u32,
    pCapabilities: *DisplayPlaneCapabilitiesKHR,
) Result;

pub extern fn vkCreateDisplayPlaneSurfaceKHR(
    instance: Instance,
    pCreateInfo: *const DisplaySurfaceCreateInfoKHR,
    pAllocator: ?*const AllocationCallbacks,
    pSurface: *SurfaceKHR,
) Result;

pub const GetPhysicalDeviceDisplayPropertiesKHRResult = struct {
    result: Result,
    properties: []DisplayPropertiesKHR,
};
pub inline fn GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice: PhysicalDevice, properties: []DisplayPropertiesKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceDisplayPropertiesKHRResult {
    var returnValues: GetPhysicalDeviceDisplayPropertiesKHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceDisplayPropertiesCountKHR(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const GetPhysicalDeviceDisplayPlanePropertiesKHRResult = struct {
    result: Result,
    properties: []DisplayPlanePropertiesKHR,
};
pub inline fn GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice: PhysicalDevice, properties: []DisplayPlanePropertiesKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceDisplayPlanePropertiesKHRResult {
    var returnValues: GetPhysicalDeviceDisplayPlanePropertiesKHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceDisplayPlanePropertiesCountKHR(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const GetDisplayPlaneSupportedDisplaysKHRResult = struct {
    result: Result,
    displays: []DisplayKHR,
};
pub inline fn GetDisplayPlaneSupportedDisplaysKHR(physicalDevice: PhysicalDevice, planeIndex: u32, displays: []DisplayKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetDisplayPlaneSupportedDisplaysKHRResult {
    var returnValues: GetDisplayPlaneSupportedDisplaysKHRResult = undefined;
    var displayCount: u32 = @intCast(u32, displays.len);
    const result = vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, &displayCount, displays.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.displays = displays[0..displayCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetDisplayPlaneSupportedDisplaysCountKHR(physicalDevice: PhysicalDevice, planeIndex: u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_displayCount: u32 = undefined;
    const result = vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, &out_displayCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_displayCount;
}

pub const GetDisplayModePropertiesKHRResult = struct {
    result: Result,
    properties: []DisplayModePropertiesKHR,
};
pub inline fn GetDisplayModePropertiesKHR(physicalDevice: PhysicalDevice, display: DisplayKHR, properties: []DisplayModePropertiesKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetDisplayModePropertiesKHRResult {
    var returnValues: GetDisplayModePropertiesKHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetDisplayModePropertiesKHR(physicalDevice, display, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetDisplayModePropertiesCountKHR(physicalDevice: PhysicalDevice, display: DisplayKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetDisplayModePropertiesKHR(physicalDevice, display, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub inline fn CreateDisplayModeKHR(physicalDevice: PhysicalDevice, display: DisplayKHR, createInfo: DisplayModeCreateInfoKHR, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!DisplayModeKHR {
    var out_mode: DisplayModeKHR = undefined;
    const result = vkCreateDisplayModeKHR(physicalDevice, display, &createInfo, pAllocator, &out_mode);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_mode;
}

pub inline fn GetDisplayPlaneCapabilitiesKHR(physicalDevice: PhysicalDevice, mode: DisplayModeKHR, planeIndex: u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DisplayPlaneCapabilitiesKHR {
    var out_capabilities: DisplayPlaneCapabilitiesKHR = undefined;
    const result = vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, &out_capabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_capabilities;
}

pub inline fn CreateDisplayPlaneSurfaceKHR(instance: Instance, createInfo: DisplaySurfaceCreateInfoKHR, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = vkCreateDisplayPlaneSurfaceKHR(instance, &createInfo, pAllocator, &out_surface);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surface;
}


pub const KHR_display_swapchain = 1;
pub const KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10;
pub const KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = c"VK_KHR_display_swapchain";

pub const DisplayPresentInfoKHR = extern struct {
    sType: StructureType = .DISPLAY_PRESENT_INFO_KHR,
    pNext: ?*const c_void = null,
    srcRect: Rect2D,
    dstRect: Rect2D,
    persistent: Bool32,
};

pub extern fn vkCreateSharedSwapchainsKHR(
    device: Device,
    swapchainCount: u32,
    pCreateInfos: [*]const SwapchainCreateInfoKHR,
    pAllocator: ?*const AllocationCallbacks,
    pSwapchains: [*]SwapchainKHR,
) Result;

pub inline fn CreateSharedSwapchainsKHR(device: Device, createInfos: []const SwapchainCreateInfoKHR, pAllocator: ?*const AllocationCallbacks, swapchains: []SwapchainKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INCOMPATIBLE_DISPLAY_KHR,VK_DEVICE_LOST,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!void {
    assert(swapchains.len >= createInfos.len);
    const result = vkCreateSharedSwapchainsKHR(device, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, swapchains.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INCOMPATIBLE_DISPLAY_KHR => error.VK_INCOMPATIBLE_DISPLAY_KHR,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}


pub const KHR_sampler_mirror_clamp_to_edge = 1;
pub const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3;
pub const KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = c"VK_KHR_sampler_mirror_clamp_to_edge";


pub const KHR_multiview = 1;
pub const KHR_MULTIVIEW_SPEC_VERSION = 1;
pub const KHR_MULTIVIEW_EXTENSION_NAME = c"VK_KHR_multiview";

pub const RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
pub const PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
pub const PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;


pub const KHR_get_physical_device_properties2 = 1;
pub const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2;
pub const KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = c"VK_KHR_get_physical_device_properties2";

pub const PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
pub const PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
pub const FormatProperties2KHR = FormatProperties2;
pub const ImageFormatProperties2KHR = ImageFormatProperties2;
pub const PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
pub const QueueFamilyProperties2KHR = QueueFamilyProperties2;
pub const PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
pub const SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
pub const PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;

pub extern fn vkGetPhysicalDeviceFeatures2KHR(
    physicalDevice: PhysicalDevice,
    pFeatures: *PhysicalDeviceFeatures2,
) void;

pub extern fn vkGetPhysicalDeviceProperties2KHR(
    physicalDevice: PhysicalDevice,
    pProperties: *PhysicalDeviceProperties2,
) void;

pub extern fn vkGetPhysicalDeviceFormatProperties2KHR(
    physicalDevice: PhysicalDevice,
    format: Format,
    pFormatProperties: *FormatProperties2,
) void;

pub extern fn vkGetPhysicalDeviceImageFormatProperties2KHR(
    physicalDevice: PhysicalDevice,
    pImageFormatInfo: *const PhysicalDeviceImageFormatInfo2,
    pImageFormatProperties: *ImageFormatProperties2,
) Result;

pub extern fn vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    physicalDevice: PhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    pQueueFamilyProperties: ?[*]QueueFamilyProperties2,
) void;

pub extern fn vkGetPhysicalDeviceMemoryProperties2KHR(
    physicalDevice: PhysicalDevice,
    pMemoryProperties: *PhysicalDeviceMemoryProperties2,
) void;

pub extern fn vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    physicalDevice: PhysicalDevice,
    pFormatInfo: *const PhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount: *u32,
    pProperties: ?[*]SparseImageFormatProperties2,
) void;

pub inline fn GetPhysicalDeviceFeatures2KHR(physicalDevice: PhysicalDevice) PhysicalDeviceFeatures2 {
    var out_features: PhysicalDeviceFeatures2 = undefined;
    vkGetPhysicalDeviceFeatures2KHR(physicalDevice, &out_features);
    return out_features;
}

pub inline fn GetPhysicalDeviceProperties2KHR(physicalDevice: PhysicalDevice) PhysicalDeviceProperties2 {
    var out_properties: PhysicalDeviceProperties2 = undefined;
    vkGetPhysicalDeviceProperties2KHR(physicalDevice, &out_properties);
    return out_properties;
}

pub inline fn GetPhysicalDeviceFormatProperties2KHR(physicalDevice: PhysicalDevice, format: Format) FormatProperties2 {
    var out_formatProperties: FormatProperties2 = undefined;
    vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, &out_formatProperties);
    return out_formatProperties;
}

pub inline fn GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice: PhysicalDevice, imageFormatInfo: PhysicalDeviceImageFormatInfo2) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FORMAT_NOT_SUPPORTED,VK_UNDOCUMENTED_ERROR}!ImageFormatProperties2 {
    var out_imageFormatProperties: ImageFormatProperties2 = undefined;
    const result = vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, &imageFormatInfo, &out_imageFormatProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FORMAT_NOT_SUPPORTED => error.VK_FORMAT_NOT_SUPPORTED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_imageFormatProperties;
}

pub inline fn GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice: PhysicalDevice, queueFamilyProperties: []QueueFamilyProperties2) []QueueFamilyProperties2 {
    var out_queueFamilyProperties: []QueueFamilyProperties2 = undefined;
    var queueFamilyPropertyCount: u32 = @intCast(u32, queueFamilyProperties.len);
    vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, &queueFamilyPropertyCount, queueFamilyProperties.ptr);
    out_queueFamilyProperties = queueFamilyProperties[0..queueFamilyPropertyCount];
    return out_queueFamilyProperties;
}
pub inline fn GetPhysicalDeviceQueueFamilyProperties2CountKHR(physicalDevice: PhysicalDevice) u32 {
    var out_queueFamilyPropertyCount: u32 = undefined;
    vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, &out_queueFamilyPropertyCount, null);
    return out_queueFamilyPropertyCount;
}

pub inline fn GetPhysicalDeviceMemoryProperties2KHR(physicalDevice: PhysicalDevice) PhysicalDeviceMemoryProperties2 {
    var out_memoryProperties: PhysicalDeviceMemoryProperties2 = undefined;
    vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, &out_memoryProperties);
    return out_memoryProperties;
}

pub inline fn GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice: PhysicalDevice, formatInfo: PhysicalDeviceSparseImageFormatInfo2, properties: []SparseImageFormatProperties2) []SparseImageFormatProperties2 {
    var out_properties: []SparseImageFormatProperties2 = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, &formatInfo, &propertyCount, properties.ptr);
    out_properties = properties[0..propertyCount];
    return out_properties;
}
pub inline fn GetPhysicalDeviceSparseImageFormatProperties2CountKHR(physicalDevice: PhysicalDevice, formatInfo: PhysicalDeviceSparseImageFormatInfo2) u32 {
    var out_propertyCount: u32 = undefined;
    vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, &formatInfo, &out_propertyCount, null);
    return out_propertyCount;
}


pub const KHR_device_group = 1;
pub const KHR_DEVICE_GROUP_SPEC_VERSION = 4;
pub const KHR_DEVICE_GROUP_EXTENSION_NAME = c"VK_KHR_device_group";

pub const PeerMemoryFeatureFlagsKHR = PeerMemoryFeatureFlags;
pub const PeerMemoryFeatureFlagBitsKHR = PeerMemoryFeatureFlagBits;
pub const MemoryAllocateFlagsKHR = MemoryAllocateFlags;
pub const MemoryAllocateFlagBitsKHR = MemoryAllocateFlagBits;

pub const MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
pub const DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
pub const DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
pub const DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
pub const DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
pub const BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
pub const BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;

pub extern fn vkGetDeviceGroupPeerMemoryFeaturesKHR(
    device: Device,
    heapIndex: u32,
    localDeviceIndex: u32,
    remoteDeviceIndex: u32,
    pPeerMemoryFeatures: *PeerMemoryFeatureFlags,
) void;

pub extern fn vkCmdSetDeviceMaskKHR(
    commandBuffer: CommandBuffer,
    deviceMask: u32,
) void;

pub extern fn vkCmdDispatchBaseKHR(
    commandBuffer: CommandBuffer,
    baseGroupX: u32,
    baseGroupY: u32,
    baseGroupZ: u32,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) void;

pub inline fn GetDeviceGroupPeerMemoryFeaturesKHR(device: Device, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32) PeerMemoryFeatureFlags {
    var out_peerMemoryFeatures: PeerMemoryFeatureFlags = undefined;
    vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, &out_peerMemoryFeatures);
    return out_peerMemoryFeatures;
}

pub const CmdSetDeviceMaskKHR = vkCmdSetDeviceMaskKHR;
pub const CmdDispatchBaseKHR = vkCmdDispatchBaseKHR;


pub const KHR_shader_draw_parameters = 1;
pub const KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1;
pub const KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = c"VK_KHR_shader_draw_parameters";


pub const KHR_maintenance1 = 1;
pub const KHR_MAINTENANCE1_SPEC_VERSION = 2;
pub const KHR_MAINTENANCE1_EXTENSION_NAME = c"VK_KHR_maintenance1";

pub const CommandPoolTrimFlagsKHR = CommandPoolTrimFlags;

pub extern fn vkTrimCommandPoolKHR(
    device: Device,
    commandPool: CommandPool,
    flags: CommandPoolTrimFlags,
) void;

pub const TrimCommandPoolKHR = vkTrimCommandPoolKHR;


pub const KHR_device_group_creation = 1;
pub const KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1;
pub const KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = c"VK_KHR_device_group_creation";
pub const MAX_DEVICE_GROUP_SIZE_KHR = MAX_DEVICE_GROUP_SIZE;

pub const PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
pub const DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;

pub extern fn vkEnumeratePhysicalDeviceGroupsKHR(
    instance: Instance,
    pPhysicalDeviceGroupCount: *u32,
    pPhysicalDeviceGroupProperties: ?[*]PhysicalDeviceGroupProperties,
) Result;

pub const EnumeratePhysicalDeviceGroupsKHRResult = struct {
    result: Result,
    physicalDeviceGroupProperties: []PhysicalDeviceGroupProperties,
};
pub inline fn EnumeratePhysicalDeviceGroupsKHR(instance: Instance, physicalDeviceGroupProperties: []PhysicalDeviceGroupProperties) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!EnumeratePhysicalDeviceGroupsKHRResult {
    var returnValues: EnumeratePhysicalDeviceGroupsKHRResult = undefined;
    var physicalDeviceGroupCount: u32 = @intCast(u32, physicalDeviceGroupProperties.len);
    const result = vkEnumeratePhysicalDeviceGroupsKHR(instance, &physicalDeviceGroupCount, physicalDeviceGroupProperties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.physicalDeviceGroupProperties = physicalDeviceGroupProperties[0..physicalDeviceGroupCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumeratePhysicalDeviceGroupsCountKHR(instance: Instance) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_physicalDeviceGroupCount: u32 = undefined;
    const result = vkEnumeratePhysicalDeviceGroupsKHR(instance, &out_physicalDeviceGroupCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_physicalDeviceGroupCount;
}


pub const KHR_external_memory_capabilities = 1;
pub const KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = c"VK_KHR_external_memory_capabilities";
pub const LUID_SIZE_KHR = LUID_SIZE;

pub const ExternalMemoryHandleTypeFlagsKHR = ExternalMemoryHandleTypeFlags;
pub const ExternalMemoryHandleTypeFlagBitsKHR = ExternalMemoryHandleTypeFlagBits;
pub const ExternalMemoryFeatureFlagsKHR = ExternalMemoryFeatureFlags;
pub const ExternalMemoryFeatureFlagBitsKHR = ExternalMemoryFeatureFlagBits;

pub const ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
pub const PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
pub const ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
pub const PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
pub const ExternalBufferPropertiesKHR = ExternalBufferProperties;
pub const PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;

pub extern fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    physicalDevice: PhysicalDevice,
    pExternalBufferInfo: *const PhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties: *ExternalBufferProperties,
) void;

pub inline fn GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice: PhysicalDevice, externalBufferInfo: PhysicalDeviceExternalBufferInfo) ExternalBufferProperties {
    var out_externalBufferProperties: ExternalBufferProperties = undefined;
    vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, &externalBufferInfo, &out_externalBufferProperties);
    return out_externalBufferProperties;
}


pub const KHR_external_memory = 1;
pub const KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_MEMORY_EXTENSION_NAME = c"VK_KHR_external_memory";
pub const QUEUE_FAMILY_EXTERNAL_KHR = QUEUE_FAMILY_EXTERNAL;

pub const ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
pub const ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
pub const ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;


pub const KHR_external_memory_fd = 1;
pub const KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = c"VK_KHR_external_memory_fd";

pub const ImportMemoryFdInfoKHR = extern struct {
    sType: StructureType = .IMPORT_MEMORY_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    handleType: ExternalMemoryHandleTypeFlags = 0,
    fd: c_int,
};

pub const MemoryFdPropertiesKHR = extern struct {
    sType: StructureType = .MEMORY_FD_PROPERTIES_KHR,
    pNext: ?*c_void = null,
    memoryTypeBits: u32,
};

pub const MemoryGetFdInfoKHR = extern struct {
    sType: StructureType = .MEMORY_GET_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    memory: DeviceMemory,
    handleType: ExternalMemoryHandleTypeFlags,
};

pub extern fn vkGetMemoryFdKHR(
    device: Device,
    pGetFdInfo: *const MemoryGetFdInfoKHR,
    pFd: *c_int,
) Result;

pub extern fn vkGetMemoryFdPropertiesKHR(
    device: Device,
    handleType: ExternalMemoryHandleTypeFlags,
    fd: c_int,
    pMemoryFdProperties: *MemoryFdPropertiesKHR,
) Result;

pub inline fn GetMemoryFdKHR(device: Device, getFdInfo: MemoryGetFdInfoKHR) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!c_int {
    var out_fd: c_int = undefined;
    const result = vkGetMemoryFdKHR(device, &getFdInfo, &out_fd);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_fd;
}

pub inline fn GetMemoryFdPropertiesKHR(device: Device, handleType: ExternalMemoryHandleTypeFlags, fd: c_int) error{VK_INVALID_EXTERNAL_HANDLE,VK_UNDOCUMENTED_ERROR}!MemoryFdPropertiesKHR {
    var out_memoryFdProperties: MemoryFdPropertiesKHR = undefined;
    const result = vkGetMemoryFdPropertiesKHR(device, handleType, fd, &out_memoryFdProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_INVALID_EXTERNAL_HANDLE => error.VK_INVALID_EXTERNAL_HANDLE,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_memoryFdProperties;
}


pub const KHR_external_semaphore_capabilities = 1;
pub const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = c"VK_KHR_external_semaphore_capabilities";

pub const ExternalSemaphoreHandleTypeFlagsKHR = ExternalSemaphoreHandleTypeFlags;
pub const ExternalSemaphoreHandleTypeFlagBitsKHR = ExternalSemaphoreHandleTypeFlagBits;
pub const ExternalSemaphoreFeatureFlagsKHR = ExternalSemaphoreFeatureFlags;
pub const ExternalSemaphoreFeatureFlagBitsKHR = ExternalSemaphoreFeatureFlagBits;

pub const PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
pub const ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;

pub extern fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    physicalDevice: PhysicalDevice,
    pExternalSemaphoreInfo: *const PhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties: *ExternalSemaphoreProperties,
) void;

pub inline fn GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice: PhysicalDevice, externalSemaphoreInfo: PhysicalDeviceExternalSemaphoreInfo) ExternalSemaphoreProperties {
    var out_externalSemaphoreProperties: ExternalSemaphoreProperties = undefined;
    vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, &externalSemaphoreInfo, &out_externalSemaphoreProperties);
    return out_externalSemaphoreProperties;
}


pub const KHR_external_semaphore = 1;
pub const KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = c"VK_KHR_external_semaphore";

pub const SemaphoreImportFlagsKHR = SemaphoreImportFlags;
pub const SemaphoreImportFlagBitsKHR = SemaphoreImportFlagBits;

pub const ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;


pub const KHR_external_semaphore_fd = 1;
pub const KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = c"VK_KHR_external_semaphore_fd";

pub const ImportSemaphoreFdInfoKHR = extern struct {
    sType: StructureType = .IMPORT_SEMAPHORE_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    semaphore: Semaphore,
    flags: SemaphoreImportFlags = 0,
    handleType: ExternalSemaphoreHandleTypeFlags,
    fd: c_int,
};

pub const SemaphoreGetFdInfoKHR = extern struct {
    sType: StructureType = .SEMAPHORE_GET_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    semaphore: Semaphore,
    handleType: ExternalSemaphoreHandleTypeFlags,
};

pub extern fn vkImportSemaphoreFdKHR(
    device: Device,
    pImportSemaphoreFdInfo: *const ImportSemaphoreFdInfoKHR,
) Result;

pub extern fn vkGetSemaphoreFdKHR(
    device: Device,
    pGetFdInfo: *const SemaphoreGetFdInfoKHR,
    pFd: *c_int,
) Result;

pub inline fn ImportSemaphoreFdKHR(device: Device, importSemaphoreFdInfo: ImportSemaphoreFdInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_INVALID_EXTERNAL_HANDLE,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkImportSemaphoreFdKHR(device, &importSemaphoreFdInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_INVALID_EXTERNAL_HANDLE => error.VK_INVALID_EXTERNAL_HANDLE,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetSemaphoreFdKHR(device: Device, getFdInfo: SemaphoreGetFdInfoKHR) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!c_int {
    var out_fd: c_int = undefined;
    const result = vkGetSemaphoreFdKHR(device, &getFdInfo, &out_fd);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_fd;
}


pub const KHR_push_descriptor = 1;
pub const KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2;
pub const KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = c"VK_KHR_push_descriptor";

pub const PhysicalDevicePushDescriptorPropertiesKHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
    pNext: ?*c_void = null,
    maxPushDescriptors: u32,
};

pub extern fn vkCmdPushDescriptorSetKHR(
    commandBuffer: CommandBuffer,
    pipelineBindPoint: PipelineBindPoint,
    layout: PipelineLayout,
    set: u32,
    descriptorWriteCount: u32,
    pDescriptorWrites: [*]const WriteDescriptorSet,
) void;

pub extern fn vkCmdPushDescriptorSetWithTemplateKHR(
    commandBuffer: CommandBuffer,
    descriptorUpdateTemplate: DescriptorUpdateTemplate,
    layout: PipelineLayout,
    set: u32,
    pData: ?*const c_void,
) void;

pub inline fn CmdPushDescriptorSetKHR(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, set: u32, descriptorWrites: []const WriteDescriptorSet) void {
    vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, @intCast(u32, descriptorWrites.len), descriptorWrites.ptr);
}

pub const CmdPushDescriptorSetWithTemplateKHR = vkCmdPushDescriptorSetWithTemplateKHR;


pub const KHR_shader_float16_int8 = 1;
pub const KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1;
pub const KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = c"VK_KHR_shader_float16_int8";

pub const PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
pub const PhysicalDeviceFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;


pub const KHR_16bit_storage = 1;
pub const KHR_16BIT_STORAGE_SPEC_VERSION = 1;
pub const KHR_16BIT_STORAGE_EXTENSION_NAME = c"VK_KHR_16bit_storage";

pub const PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;


pub const KHR_incremental_present = 1;
pub const KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 1;
pub const KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = c"VK_KHR_incremental_present";

pub const RectLayerKHR = extern struct {
    offset: Offset2D,
    extent: Extent2D,
    layer: u32,
};

pub const PresentRegionKHR = extern struct {
    rectangleCount: u32 = 0,
    pRectangles: ?[*]const RectLayerKHR = null,
};

pub const PresentRegionsKHR = extern struct {
    sType: StructureType = .PRESENT_REGIONS_KHR,
    pNext: ?*const c_void = null,
    swapchainCount: u32,
    pRegions: ?[*]const PresentRegionKHR = null,
};


pub const KHR_descriptor_update_template = 1;
pub const DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;

pub const KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1;
pub const KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = c"VK_KHR_descriptor_update_template";

pub const DescriptorUpdateTemplateTypeKHR = DescriptorUpdateTemplateType;

pub const DescriptorUpdateTemplateCreateFlagsKHR = DescriptorUpdateTemplateCreateFlags;

pub const DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
pub const DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;

pub extern fn vkCreateDescriptorUpdateTemplateKHR(
    device: Device,
    pCreateInfo: *const DescriptorUpdateTemplateCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pDescriptorUpdateTemplate: *DescriptorUpdateTemplate,
) Result;

pub extern fn vkDestroyDescriptorUpdateTemplateKHR(
    device: Device,
    descriptorUpdateTemplate: ?DescriptorUpdateTemplate,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkUpdateDescriptorSetWithTemplateKHR(
    device: Device,
    descriptorSet: DescriptorSet,
    descriptorUpdateTemplate: DescriptorUpdateTemplate,
    pData: ?*const c_void,
) void;

pub inline fn CreateDescriptorUpdateTemplateKHR(device: Device, createInfo: DescriptorUpdateTemplateCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DescriptorUpdateTemplate {
    var out_descriptorUpdateTemplate: DescriptorUpdateTemplate = undefined;
    const result = vkCreateDescriptorUpdateTemplateKHR(device, &createInfo, pAllocator, &out_descriptorUpdateTemplate);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_descriptorUpdateTemplate;
}

pub const DestroyDescriptorUpdateTemplateKHR = vkDestroyDescriptorUpdateTemplateKHR;
pub const UpdateDescriptorSetWithTemplateKHR = vkUpdateDescriptorSetWithTemplateKHR;


pub const KHR_imageless_framebuffer = 1;
pub const KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1;
pub const KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = c"VK_KHR_imageless_framebuffer";

pub const PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
pub const FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
pub const FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
pub const RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;


pub const KHR_create_renderpass2 = 1;
pub const KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1;
pub const KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = c"VK_KHR_create_renderpass2";

pub const RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
pub const AttachmentDescription2KHR = AttachmentDescription2;
pub const AttachmentReference2KHR = AttachmentReference2;
pub const SubpassDescription2KHR = SubpassDescription2;
pub const SubpassDependency2KHR = SubpassDependency2;
pub const SubpassBeginInfoKHR = SubpassBeginInfo;
pub const SubpassEndInfoKHR = SubpassEndInfo;

pub extern fn vkCreateRenderPass2KHR(
    device: Device,
    pCreateInfo: *const RenderPassCreateInfo2,
    pAllocator: ?*const AllocationCallbacks,
    pRenderPass: *RenderPass,
) Result;

pub extern fn vkCmdBeginRenderPass2KHR(
    commandBuffer: CommandBuffer,
    pRenderPassBegin: *const RenderPassBeginInfo,
    pSubpassBeginInfo: *const SubpassBeginInfo,
) void;

pub extern fn vkCmdNextSubpass2KHR(
    commandBuffer: CommandBuffer,
    pSubpassBeginInfo: *const SubpassBeginInfo,
    pSubpassEndInfo: *const SubpassEndInfo,
) void;

pub extern fn vkCmdEndRenderPass2KHR(
    commandBuffer: CommandBuffer,
    pSubpassEndInfo: *const SubpassEndInfo,
) void;

pub inline fn CreateRenderPass2KHR(device: Device, createInfo: RenderPassCreateInfo2, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!RenderPass {
    var out_renderPass: RenderPass = undefined;
    const result = vkCreateRenderPass2KHR(device, &createInfo, pAllocator, &out_renderPass);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_renderPass;
}

pub inline fn CmdBeginRenderPass2KHR(commandBuffer: CommandBuffer, renderPassBegin: RenderPassBeginInfo, subpassBeginInfo: SubpassBeginInfo) void {
    vkCmdBeginRenderPass2KHR(commandBuffer, &renderPassBegin, &subpassBeginInfo);
}

pub inline fn CmdNextSubpass2KHR(commandBuffer: CommandBuffer, subpassBeginInfo: SubpassBeginInfo, subpassEndInfo: SubpassEndInfo) void {
    vkCmdNextSubpass2KHR(commandBuffer, &subpassBeginInfo, &subpassEndInfo);
}

pub inline fn CmdEndRenderPass2KHR(commandBuffer: CommandBuffer, subpassEndInfo: SubpassEndInfo) void {
    vkCmdEndRenderPass2KHR(commandBuffer, &subpassEndInfo);
}


pub const KHR_shared_presentable_image = 1;
pub const KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1;
pub const KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = c"VK_KHR_shared_presentable_image";

pub const SharedPresentSurfaceCapabilitiesKHR = extern struct {
    sType: StructureType = .SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    pNext: ?*c_void = null,
    sharedPresentSupportedUsageFlags: ImageUsageFlags = 0,
};

pub extern fn vkGetSwapchainStatusKHR(
    device: Device,
    swapchain: SwapchainKHR,
) Result;

pub inline fn GetSwapchainStatusKHR(device: Device, swapchain: SwapchainKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkGetSwapchainStatusKHR(device, swapchain);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            .ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => error.VK_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}


pub const KHR_external_fence_capabilities = 1;
pub const KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = c"VK_KHR_external_fence_capabilities";

pub const ExternalFenceHandleTypeFlagsKHR = ExternalFenceHandleTypeFlags;
pub const ExternalFenceHandleTypeFlagBitsKHR = ExternalFenceHandleTypeFlagBits;
pub const ExternalFenceFeatureFlagsKHR = ExternalFenceFeatureFlags;
pub const ExternalFenceFeatureFlagBitsKHR = ExternalFenceFeatureFlagBits;

pub const PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
pub const ExternalFencePropertiesKHR = ExternalFenceProperties;

pub extern fn vkGetPhysicalDeviceExternalFencePropertiesKHR(
    physicalDevice: PhysicalDevice,
    pExternalFenceInfo: *const PhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties: *ExternalFenceProperties,
) void;

pub inline fn GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice: PhysicalDevice, externalFenceInfo: PhysicalDeviceExternalFenceInfo) ExternalFenceProperties {
    var out_externalFenceProperties: ExternalFenceProperties = undefined;
    vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, &externalFenceInfo, &out_externalFenceProperties);
    return out_externalFenceProperties;
}


pub const KHR_external_fence = 1;
pub const KHR_EXTERNAL_FENCE_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_FENCE_EXTENSION_NAME = c"VK_KHR_external_fence";

pub const FenceImportFlagsKHR = FenceImportFlags;
pub const FenceImportFlagBitsKHR = FenceImportFlagBits;

pub const ExportFenceCreateInfoKHR = ExportFenceCreateInfo;


pub const KHR_external_fence_fd = 1;
pub const KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1;
pub const KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = c"VK_KHR_external_fence_fd";

pub const ImportFenceFdInfoKHR = extern struct {
    sType: StructureType = .IMPORT_FENCE_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    fence: Fence,
    flags: FenceImportFlags = 0,
    handleType: ExternalFenceHandleTypeFlags,
    fd: c_int,
};

pub const FenceGetFdInfoKHR = extern struct {
    sType: StructureType = .FENCE_GET_FD_INFO_KHR,
    pNext: ?*const c_void = null,
    fence: Fence,
    handleType: ExternalFenceHandleTypeFlags,
};

pub extern fn vkImportFenceFdKHR(
    device: Device,
    pImportFenceFdInfo: *const ImportFenceFdInfoKHR,
) Result;

pub extern fn vkGetFenceFdKHR(
    device: Device,
    pGetFdInfo: *const FenceGetFdInfoKHR,
    pFd: *c_int,
) Result;

pub inline fn ImportFenceFdKHR(device: Device, importFenceFdInfo: ImportFenceFdInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_INVALID_EXTERNAL_HANDLE,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkImportFenceFdKHR(device, &importFenceFdInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_INVALID_EXTERNAL_HANDLE => error.VK_INVALID_EXTERNAL_HANDLE,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetFenceFdKHR(device: Device, getFdInfo: FenceGetFdInfoKHR) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!c_int {
    var out_fd: c_int = undefined;
    const result = vkGetFenceFdKHR(device, &getFdInfo, &out_fd);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_fd;
}


pub const KHR_performance_query = 1;
pub const KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1;
pub const KHR_PERFORMANCE_QUERY_EXTENSION_NAME = c"VK_KHR_performance_query";

pub const PerformanceCounterUnitKHR = extern enum {
    GENERIC = 0,
    PERCENTAGE = 1,
    NANOSECONDS = 2,
    BYTES = 3,
    BYTES_PER_SECOND = 4,
    KELVIN = 5,
    WATTS = 6,
    VOLTS = 7,
    AMPS = 8,
    HERTZ = 9,
    CYCLES = 10,
};

pub const PerformanceCounterScopeKHR = extern enum {
    COMMAND_BUFFER = 0,
    RENDER_PASS = 1,
    COMMAND = 2,

    const Self = @This();
    pub const QUERY_SCOPE_COMMAND_BUFFER = Self.COMMAND_BUFFER;
    pub const QUERY_SCOPE_RENDER_PASS = Self.RENDER_PASS;
    pub const QUERY_SCOPE_COMMAND = Self.COMMAND;
};

pub const PerformanceCounterStorageKHR = extern enum {
    INT32 = 0,
    INT64 = 1,
    UINT32 = 2,
    UINT64 = 3,
    FLOAT32 = 4,
    FLOAT64 = 5,
};

pub const PerformanceCounterDescriptionFlagsKHR = Flags;
pub const PerformanceCounterDescriptionFlagBitsKHR = struct {
    pub const PERFORMANCE_IMPACTING: PerformanceCounterDescriptionFlagsKHR = 0x00000001;
    pub const CONCURRENTLY_IMPACTED: PerformanceCounterDescriptionFlagsKHR = 0x00000002;
};

pub const AcquireProfilingLockFlagsKHR = Flags;
pub const AcquireProfilingLockFlagBitsKHR = struct {
};

pub const PhysicalDevicePerformanceQueryFeaturesKHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
    pNext: ?*c_void = null,
    performanceCounterQueryPools: Bool32,
    performanceCounterMultipleQueryPools: Bool32,
};

pub const PhysicalDevicePerformanceQueryPropertiesKHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
    pNext: ?*c_void = null,
    allowCommandBufferQueryCopies: Bool32,
};

pub const PerformanceCounterKHR = extern struct {
    sType: StructureType = .PERFORMANCE_COUNTER_KHR,
    pNext: ?*const c_void = null,
    unit: PerformanceCounterUnitKHR,
    scope: PerformanceCounterScopeKHR,
    storage: PerformanceCounterStorageKHR,
    uuid: [UUID_SIZE]u8,
};

pub const PerformanceCounterDescriptionKHR = extern struct {
    sType: StructureType = .PERFORMANCE_COUNTER_DESCRIPTION_KHR,
    pNext: ?*const c_void = null,
    flags: PerformanceCounterDescriptionFlagsKHR = 0,
    name: [MAX_DESCRIPTION_SIZE]u8,
    category: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
};

pub const QueryPoolPerformanceCreateInfoKHR = extern struct {
    sType: StructureType = .QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
    pNext: ?*const c_void = null,
    queueFamilyIndex: u32,
    counterIndexCount: u32,
    pCounterIndices: [*]const u32,
};

pub const PerformanceCounterResultKHR = extern union {
    int32: i32,
    int64: i64,
    uint32: u32,
    uint64: u64,
    float32: f32,
    float64: f64,
};

pub const AcquireProfilingLockInfoKHR = extern struct {
    sType: StructureType = .ACQUIRE_PROFILING_LOCK_INFO_KHR,
    pNext: ?*const c_void = null,
    flags: AcquireProfilingLockFlagsKHR = 0,
    timeout: u64,
};

pub const PerformanceQuerySubmitInfoKHR = extern struct {
    sType: StructureType = .PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
    pNext: ?*const c_void = null,
    counterPassIndex: u32,
};

pub extern fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    physicalDevice: PhysicalDevice,
    queueFamilyIndex: u32,
    pCounterCount: *u32,
    pCounters: ?[*]PerformanceCounterKHR,
    pCounterDescriptions: ?[*]PerformanceCounterDescriptionKHR,
) Result;

pub extern fn vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    physicalDevice: PhysicalDevice,
    pPerformanceQueryCreateInfo: *const QueryPoolPerformanceCreateInfoKHR,
    pNumPasses: *u32,
) void;

pub extern fn vkAcquireProfilingLockKHR(
    device: Device,
    pInfo: *const AcquireProfilingLockInfoKHR,
) Result;

pub extern fn vkReleaseProfilingLockKHR(device: Device) void;

pub const EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRResult = struct {
    result: Result,
    counters: []PerformanceCounterKHR,
    counterDescriptions: []PerformanceCounterDescriptionKHR,
};
pub inline fn EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice: PhysicalDevice, queueFamilyIndex: u32, counters: []PerformanceCounterKHR, counterDescriptions: []PerformanceCounterDescriptionKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRResult {
    var returnValues: EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHRResult = undefined;
    var counterCount: u32 = @intCast(u32, counters.len);
    assert(counterDescriptions.len >= counters.len);
    const result = vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, &counterCount, counters.ptr, counterDescriptions.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.counters = counters[0..counterCount];
    returnValues.counterDescriptions = counterDescriptions[0..counterCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersCountKHR(physicalDevice: PhysicalDevice, queueFamilyIndex: u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INITIALIZATION_FAILED,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_counterCount: u32 = undefined;
    const result = vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, &out_counterCount, null, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INITIALIZATION_FAILED => error.VK_INITIALIZATION_FAILED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_counterCount;
}

pub inline fn GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice: PhysicalDevice, performanceQueryCreateInfo: QueryPoolPerformanceCreateInfoKHR) u32 {
    var out_numPasses: u32 = undefined;
    vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, &performanceQueryCreateInfo, &out_numPasses);
    return out_numPasses;
}

pub inline fn AcquireProfilingLockKHR(device: Device, info: AcquireProfilingLockInfoKHR) error{VK_TIMEOUT,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkAcquireProfilingLockKHR(device, &info);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .TIMEOUT => error.VK_TIMEOUT,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const ReleaseProfilingLockKHR = vkReleaseProfilingLockKHR;


pub const KHR_maintenance2 = 1;
pub const KHR_MAINTENANCE2_SPEC_VERSION = 1;
pub const KHR_MAINTENANCE2_EXTENSION_NAME = c"VK_KHR_maintenance2";

pub const PointClippingBehaviorKHR = PointClippingBehavior;
pub const TessellationDomainOriginKHR = TessellationDomainOrigin;

pub const PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
pub const RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
pub const InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
pub const ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
pub const PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;


pub const KHR_get_surface_capabilities2 = 1;
pub const KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1;
pub const KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = c"VK_KHR_get_surface_capabilities2";

pub const PhysicalDeviceSurfaceInfo2KHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    pNext: ?*const c_void = null,
    surface: SurfaceKHR,
};

pub const SurfaceCapabilities2KHR = extern struct {
    sType: StructureType = .SURFACE_CAPABILITIES_2_KHR,
    pNext: ?*c_void = null,
    surfaceCapabilities: SurfaceCapabilitiesKHR,
};

pub const SurfaceFormat2KHR = extern struct {
    sType: StructureType = .SURFACE_FORMAT_2_KHR,
    pNext: ?*c_void = null,
    surfaceFormat: SurfaceFormatKHR,
};

pub extern fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    physicalDevice: PhysicalDevice,
    pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR,
    pSurfaceCapabilities: *SurfaceCapabilities2KHR,
) Result;

pub extern fn vkGetPhysicalDeviceSurfaceFormats2KHR(
    physicalDevice: PhysicalDevice,
    pSurfaceInfo: *const PhysicalDeviceSurfaceInfo2KHR,
    pSurfaceFormatCount: *u32,
    pSurfaceFormats: ?[*]SurfaceFormat2KHR,
) Result;

pub inline fn GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice: PhysicalDevice, surfaceInfo: PhysicalDeviceSurfaceInfo2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!SurfaceCapabilities2KHR {
    var out_surfaceCapabilities: SurfaceCapabilities2KHR = undefined;
    const result = vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, &surfaceInfo, &out_surfaceCapabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surfaceCapabilities;
}

pub const GetPhysicalDeviceSurfaceFormats2KHRResult = struct {
    result: Result,
    surfaceFormats: []SurfaceFormat2KHR,
};
pub inline fn GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice: PhysicalDevice, surfaceInfo: PhysicalDeviceSurfaceInfo2KHR, surfaceFormats: []SurfaceFormat2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceSurfaceFormats2KHRResult {
    var returnValues: GetPhysicalDeviceSurfaceFormats2KHRResult = undefined;
    var surfaceFormatCount: u32 = @intCast(u32, surfaceFormats.len);
    const result = vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, &surfaceInfo, &surfaceFormatCount, surfaceFormats.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.surfaceFormats = surfaceFormats[0..surfaceFormatCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceSurfaceFormats2CountKHR(physicalDevice: PhysicalDevice, surfaceInfo: PhysicalDeviceSurfaceInfo2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_surfaceFormatCount: u32 = undefined;
    const result = vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, &surfaceInfo, &out_surfaceFormatCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surfaceFormatCount;
}


pub const KHR_variable_pointers = 1;
pub const KHR_VARIABLE_POINTERS_SPEC_VERSION = 1;
pub const KHR_VARIABLE_POINTERS_EXTENSION_NAME = c"VK_KHR_variable_pointers";

pub const PhysicalDeviceVariablePointerFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
pub const PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;


pub const KHR_get_display_properties2 = 1;
pub const KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1;
pub const KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = c"VK_KHR_get_display_properties2";

pub const DisplayProperties2KHR = extern struct {
    sType: StructureType = .DISPLAY_PROPERTIES_2_KHR,
    pNext: ?*c_void = null,
    displayProperties: DisplayPropertiesKHR,
};

pub const DisplayPlaneProperties2KHR = extern struct {
    sType: StructureType = .DISPLAY_PLANE_PROPERTIES_2_KHR,
    pNext: ?*c_void = null,
    displayPlaneProperties: DisplayPlanePropertiesKHR,
};

pub const DisplayModeProperties2KHR = extern struct {
    sType: StructureType = .DISPLAY_MODE_PROPERTIES_2_KHR,
    pNext: ?*c_void = null,
    displayModeProperties: DisplayModePropertiesKHR,
};

pub const DisplayPlaneInfo2KHR = extern struct {
    sType: StructureType = .DISPLAY_PLANE_INFO_2_KHR,
    pNext: ?*const c_void = null,
    mode: DisplayModeKHR,
    planeIndex: u32,
};

pub const DisplayPlaneCapabilities2KHR = extern struct {
    sType: StructureType = .DISPLAY_PLANE_CAPABILITIES_2_KHR,
    pNext: ?*c_void = null,
    capabilities: DisplayPlaneCapabilitiesKHR,
};

pub extern fn vkGetPhysicalDeviceDisplayProperties2KHR(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayProperties2KHR,
) Result;

pub extern fn vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayPlaneProperties2KHR,
) Result;

pub extern fn vkGetDisplayModeProperties2KHR(
    physicalDevice: PhysicalDevice,
    display: DisplayKHR,
    pPropertyCount: *u32,
    pProperties: ?[*]DisplayModeProperties2KHR,
) Result;

pub extern fn vkGetDisplayPlaneCapabilities2KHR(
    physicalDevice: PhysicalDevice,
    pDisplayPlaneInfo: *const DisplayPlaneInfo2KHR,
    pCapabilities: *DisplayPlaneCapabilities2KHR,
) Result;

pub const GetPhysicalDeviceDisplayProperties2KHRResult = struct {
    result: Result,
    properties: []DisplayProperties2KHR,
};
pub inline fn GetPhysicalDeviceDisplayProperties2KHR(physicalDevice: PhysicalDevice, properties: []DisplayProperties2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceDisplayProperties2KHRResult {
    var returnValues: GetPhysicalDeviceDisplayProperties2KHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceDisplayProperties2CountKHR(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const GetPhysicalDeviceDisplayPlaneProperties2KHRResult = struct {
    result: Result,
    properties: []DisplayPlaneProperties2KHR,
};
pub inline fn GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice: PhysicalDevice, properties: []DisplayPlaneProperties2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceDisplayPlaneProperties2KHRResult {
    var returnValues: GetPhysicalDeviceDisplayPlaneProperties2KHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceDisplayPlaneProperties2CountKHR(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub const GetDisplayModeProperties2KHRResult = struct {
    result: Result,
    properties: []DisplayModeProperties2KHR,
};
pub inline fn GetDisplayModeProperties2KHR(physicalDevice: PhysicalDevice, display: DisplayKHR, properties: []DisplayModeProperties2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetDisplayModeProperties2KHRResult {
    var returnValues: GetDisplayModeProperties2KHRResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetDisplayModeProperties2KHR(physicalDevice, display, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetDisplayModeProperties2CountKHR(physicalDevice: PhysicalDevice, display: DisplayKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetDisplayModeProperties2KHR(physicalDevice, display, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}

pub inline fn GetDisplayPlaneCapabilities2KHR(physicalDevice: PhysicalDevice, displayPlaneInfo: DisplayPlaneInfo2KHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!DisplayPlaneCapabilities2KHR {
    var out_capabilities: DisplayPlaneCapabilities2KHR = undefined;
    const result = vkGetDisplayPlaneCapabilities2KHR(physicalDevice, &displayPlaneInfo, &out_capabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_capabilities;
}


pub const KHR_dedicated_allocation = 1;
pub const KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3;
pub const KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = c"VK_KHR_dedicated_allocation";

pub const MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
pub const MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;


pub const KHR_storage_buffer_storage_class = 1;
pub const KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1;
pub const KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = c"VK_KHR_storage_buffer_storage_class";


pub const KHR_relaxed_block_layout = 1;
pub const KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1;
pub const KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = c"VK_KHR_relaxed_block_layout";


pub const KHR_get_memory_requirements2 = 1;
pub const KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1;
pub const KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = c"VK_KHR_get_memory_requirements2";

pub const BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
pub const ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
pub const ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
pub const SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;

pub extern fn vkGetImageMemoryRequirements2KHR(
    device: Device,
    pInfo: *const ImageMemoryRequirementsInfo2,
    pMemoryRequirements: *MemoryRequirements2,
) void;

pub extern fn vkGetBufferMemoryRequirements2KHR(
    device: Device,
    pInfo: *const BufferMemoryRequirementsInfo2,
    pMemoryRequirements: *MemoryRequirements2,
) void;

pub extern fn vkGetImageSparseMemoryRequirements2KHR(
    device: Device,
    pInfo: *const ImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount: *u32,
    pSparseMemoryRequirements: ?[*]SparseImageMemoryRequirements2,
) void;

pub inline fn GetImageMemoryRequirements2KHR(device: Device, info: ImageMemoryRequirementsInfo2) MemoryRequirements2 {
    var out_memoryRequirements: MemoryRequirements2 = undefined;
    vkGetImageMemoryRequirements2KHR(device, &info, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetBufferMemoryRequirements2KHR(device: Device, info: BufferMemoryRequirementsInfo2) MemoryRequirements2 {
    var out_memoryRequirements: MemoryRequirements2 = undefined;
    vkGetBufferMemoryRequirements2KHR(device, &info, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn GetImageSparseMemoryRequirements2KHR(device: Device, info: ImageSparseMemoryRequirementsInfo2, sparseMemoryRequirements: []SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
    var out_sparseMemoryRequirements: []SparseImageMemoryRequirements2 = undefined;
    var sparseMemoryRequirementCount: u32 = @intCast(u32, sparseMemoryRequirements.len);
    vkGetImageSparseMemoryRequirements2KHR(device, &info, &sparseMemoryRequirementCount, sparseMemoryRequirements.ptr);
    out_sparseMemoryRequirements = sparseMemoryRequirements[0..sparseMemoryRequirementCount];
    return out_sparseMemoryRequirements;
}
pub inline fn GetImageSparseMemoryRequirements2CountKHR(device: Device, info: ImageSparseMemoryRequirementsInfo2) u32 {
    var out_sparseMemoryRequirementCount: u32 = undefined;
    vkGetImageSparseMemoryRequirements2KHR(device, &info, &out_sparseMemoryRequirementCount, null);
    return out_sparseMemoryRequirementCount;
}


pub const KHR_image_format_list = 1;
pub const KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1;
pub const KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = c"VK_KHR_image_format_list";

pub const ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;


pub const KHR_sampler_ycbcr_conversion = 1;
pub const SamplerYcbcrConversionKHR = SamplerYcbcrConversion;

pub const KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14;
pub const KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = c"VK_KHR_sampler_ycbcr_conversion";

pub const SamplerYcbcrModelConversionKHR = SamplerYcbcrModelConversion;
pub const SamplerYcbcrRangeKHR = SamplerYcbcrRange;
pub const ChromaLocationKHR = ChromaLocation;

pub const SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
pub const SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
pub const BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
pub const ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
pub const PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
pub const SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;

pub extern fn vkCreateSamplerYcbcrConversionKHR(
    device: Device,
    pCreateInfo: *const SamplerYcbcrConversionCreateInfo,
    pAllocator: ?*const AllocationCallbacks,
    pYcbcrConversion: *SamplerYcbcrConversion,
) Result;

pub extern fn vkDestroySamplerYcbcrConversionKHR(
    device: Device,
    ycbcrConversion: ?SamplerYcbcrConversion,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub inline fn CreateSamplerYcbcrConversionKHR(device: Device, createInfo: SamplerYcbcrConversionCreateInfo, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!SamplerYcbcrConversion {
    var out_ycbcrConversion: SamplerYcbcrConversion = undefined;
    const result = vkCreateSamplerYcbcrConversionKHR(device, &createInfo, pAllocator, &out_ycbcrConversion);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_ycbcrConversion;
}

pub const DestroySamplerYcbcrConversionKHR = vkDestroySamplerYcbcrConversionKHR;


pub const KHR_bind_memory2 = 1;
pub const KHR_BIND_MEMORY_2_SPEC_VERSION = 1;
pub const KHR_BIND_MEMORY_2_EXTENSION_NAME = c"VK_KHR_bind_memory2";

pub const BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
pub const BindImageMemoryInfoKHR = BindImageMemoryInfo;

pub extern fn vkBindBufferMemory2KHR(
    device: Device,
    bindInfoCount: u32,
    pBindInfos: [*]const BindBufferMemoryInfo,
) Result;

pub extern fn vkBindImageMemory2KHR(
    device: Device,
    bindInfoCount: u32,
    pBindInfos: [*]const BindImageMemoryInfo,
) Result;

pub inline fn BindBufferMemory2KHR(device: Device, bindInfos: []const BindBufferMemoryInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindBufferMemory2KHR(device, @intCast(u32, bindInfos.len), bindInfos.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => error.VK_INVALID_OPAQUE_CAPTURE_ADDRESS,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn BindImageMemory2KHR(device: Device, bindInfos: []const BindImageMemoryInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindImageMemory2KHR(device, @intCast(u32, bindInfos.len), bindInfos.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}


pub const KHR_maintenance3 = 1;
pub const KHR_MAINTENANCE3_SPEC_VERSION = 1;
pub const KHR_MAINTENANCE3_EXTENSION_NAME = c"VK_KHR_maintenance3";

pub const PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
pub const DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;

pub extern fn vkGetDescriptorSetLayoutSupportKHR(
    device: Device,
    pCreateInfo: *const DescriptorSetLayoutCreateInfo,
    pSupport: *DescriptorSetLayoutSupport,
) void;

pub inline fn GetDescriptorSetLayoutSupportKHR(device: Device, createInfo: DescriptorSetLayoutCreateInfo) DescriptorSetLayoutSupport {
    var out_support: DescriptorSetLayoutSupport = undefined;
    vkGetDescriptorSetLayoutSupportKHR(device, &createInfo, &out_support);
    return out_support;
}


pub const KHR_draw_indirect_count = 1;
pub const KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;
pub const KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = c"VK_KHR_draw_indirect_count";

pub extern fn vkCmdDrawIndirectCountKHR(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDrawIndexedIndirectCountKHR(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub const CmdDrawIndirectCountKHR = vkCmdDrawIndirectCountKHR;
pub const CmdDrawIndexedIndirectCountKHR = vkCmdDrawIndexedIndirectCountKHR;


pub const KHR_shader_subgroup_extended_types = 1;
pub const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1;
pub const KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = c"VK_KHR_shader_subgroup_extended_types";

pub const PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;


pub const KHR_8bit_storage = 1;
pub const KHR_8BIT_STORAGE_SPEC_VERSION = 1;
pub const KHR_8BIT_STORAGE_EXTENSION_NAME = c"VK_KHR_8bit_storage";

pub const PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;


pub const KHR_shader_atomic_int64 = 1;
pub const KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1;
pub const KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = c"VK_KHR_shader_atomic_int64";

pub const PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;


pub const KHR_shader_clock = 1;
pub const KHR_SHADER_CLOCK_SPEC_VERSION = 1;
pub const KHR_SHADER_CLOCK_EXTENSION_NAME = c"VK_KHR_shader_clock";

pub const PhysicalDeviceShaderClockFeaturesKHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
    pNext: ?*c_void = null,
    shaderSubgroupClock: Bool32,
    shaderDeviceClock: Bool32,
};


pub const KHR_driver_properties = 1;
pub const KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1;
pub const KHR_DRIVER_PROPERTIES_EXTENSION_NAME = c"VK_KHR_driver_properties";
pub const MAX_DRIVER_NAME_SIZE_KHR = MAX_DRIVER_NAME_SIZE;
pub const MAX_DRIVER_INFO_SIZE_KHR = MAX_DRIVER_INFO_SIZE;

pub const DriverIdKHR = DriverId;

pub const ConformanceVersionKHR = ConformanceVersion;
pub const PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;


pub const KHR_shader_float_controls = 1;
pub const KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4;
pub const KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = c"VK_KHR_shader_float_controls";

pub const ShaderFloatControlsIndependenceKHR = ShaderFloatControlsIndependence;

pub const PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;


pub const KHR_depth_stencil_resolve = 1;
pub const KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1;
pub const KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = c"VK_KHR_depth_stencil_resolve";

pub const ResolveModeFlagBitsKHR = ResolveModeFlagBits;
pub const ResolveModeFlagsKHR = ResolveModeFlags;

pub const SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
pub const PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;


pub const KHR_swapchain_mutable_format = 1;
pub const KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1;
pub const KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = c"VK_KHR_swapchain_mutable_format";


pub const KHR_timeline_semaphore = 1;
pub const KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2;
pub const KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = c"VK_KHR_timeline_semaphore";

pub const SemaphoreTypeKHR = SemaphoreType;

pub const SemaphoreWaitFlagBitsKHR = SemaphoreWaitFlagBits;
pub const SemaphoreWaitFlagsKHR = SemaphoreWaitFlags;

pub const PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
pub const PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
pub const SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
pub const TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
pub const SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
pub const SemaphoreSignalInfoKHR = SemaphoreSignalInfo;

pub extern fn vkGetSemaphoreCounterValueKHR(
    device: Device,
    semaphore: Semaphore,
    pValue: *u64,
) Result;

pub extern fn vkWaitSemaphoresKHR(
    device: Device,
    pWaitInfo: *const SemaphoreWaitInfo,
    timeout: u64,
) Result;

pub extern fn vkSignalSemaphoreKHR(
    device: Device,
    pSignalInfo: *const SemaphoreSignalInfo,
) Result;

pub inline fn GetSemaphoreCounterValueKHR(device: Device, semaphore: Semaphore) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!u64 {
    var out_value: u64 = undefined;
    const result = vkGetSemaphoreCounterValueKHR(device, semaphore, &out_value);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_value;
}

pub inline fn WaitSemaphoresKHR(device: Device, waitInfo: SemaphoreWaitInfo, timeout: u64) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_DEVICE_LOST,VK_UNDOCUMENTED_ERROR}!Result {
    const result = vkWaitSemaphoresKHR(device, &waitInfo, timeout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return result;
}

pub inline fn SignalSemaphoreKHR(device: Device, signalInfo: SemaphoreSignalInfo) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkSignalSemaphoreKHR(device, &signalInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}


pub const KHR_vulkan_memory_model = 1;
pub const KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3;
pub const KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = c"VK_KHR_vulkan_memory_model";

pub const PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;


pub const KHR_spirv_1_4 = 1;
pub const KHR_SPIRV_1_4_SPEC_VERSION = 1;
pub const KHR_SPIRV_1_4_EXTENSION_NAME = c"VK_KHR_spirv_1_4";


pub const KHR_surface_protected_capabilities = 1;
pub const KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1;
pub const KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = c"VK_KHR_surface_protected_capabilities";

pub const SurfaceProtectedCapabilitiesKHR = extern struct {
    sType: StructureType = .SURFACE_PROTECTED_CAPABILITIES_KHR,
    pNext: ?*const c_void = null,
    supportsProtected: Bool32,
};


pub const KHR_separate_depth_stencil_layouts = 1;
pub const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1;
pub const KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = c"VK_KHR_separate_depth_stencil_layouts";

pub const PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub const AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
pub const AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;


pub const KHR_uniform_buffer_standard_layout = 1;
pub const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1;
pub const KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = c"VK_KHR_uniform_buffer_standard_layout";

pub const PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;


pub const KHR_buffer_device_address = 1;
pub const KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1;
pub const KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = c"VK_KHR_buffer_device_address";

pub const PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
pub const BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
pub const BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
pub const MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
pub const DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;

pub extern fn vkGetBufferDeviceAddressKHR(
    device: Device,
    pInfo: *const BufferDeviceAddressInfo,
) DeviceAddress;

pub extern fn vkGetBufferOpaqueCaptureAddressKHR(
    device: Device,
    pInfo: *const BufferDeviceAddressInfo,
) u64;

pub extern fn vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    device: Device,
    pInfo: *const DeviceMemoryOpaqueCaptureAddressInfo,
) u64;

pub inline fn GetBufferDeviceAddressKHR(device: Device, info: BufferDeviceAddressInfo) DeviceAddress {
    const result = vkGetBufferDeviceAddressKHR(device, &info);
    return result;
}

pub inline fn GetBufferOpaqueCaptureAddressKHR(device: Device, info: BufferDeviceAddressInfo) u64 {
    const result = vkGetBufferOpaqueCaptureAddressKHR(device, &info);
    return result;
}

pub inline fn GetDeviceMemoryOpaqueCaptureAddressKHR(device: Device, info: DeviceMemoryOpaqueCaptureAddressInfo) u64 {
    const result = vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, &info);
    return result;
}


pub const KHR_pipeline_executable_properties = 1;
pub const KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1;
pub const KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = c"VK_KHR_pipeline_executable_properties";

pub const PipelineExecutableStatisticFormatKHR = extern enum {
    BOOL32 = 0,
    INT64 = 1,
    UINT64 = 2,
    FLOAT64 = 3,
};

pub const PhysicalDevicePipelineExecutablePropertiesFeaturesKHR = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
    pNext: ?*c_void = null,
    pipelineExecutableInfo: Bool32,
};

pub const PipelineInfoKHR = extern struct {
    sType: StructureType = .PIPELINE_INFO_KHR,
    pNext: ?*const c_void = null,
    pipeline: Pipeline,
};

pub const PipelineExecutablePropertiesKHR = extern struct {
    sType: StructureType = .PIPELINE_EXECUTABLE_PROPERTIES_KHR,
    pNext: ?*c_void = null,
    stages: ShaderStageFlags,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    subgroupSize: u32,
};

pub const PipelineExecutableInfoKHR = extern struct {
    sType: StructureType = .PIPELINE_EXECUTABLE_INFO_KHR,
    pNext: ?*const c_void = null,
    pipeline: Pipeline,
    executableIndex: u32,
};

pub const PipelineExecutableStatisticValueKHR = extern union {
    b32: Bool32,
    i64: i64,
    u64: u64,
    f64: f64,
};

pub const PipelineExecutableStatisticKHR = extern struct {
    sType: StructureType = .PIPELINE_EXECUTABLE_STATISTIC_KHR,
    pNext: ?*c_void = null,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    format: PipelineExecutableStatisticFormatKHR,
    value: PipelineExecutableStatisticValueKHR,
};

pub const PipelineExecutableInternalRepresentationKHR = extern struct {
    sType: StructureType = .PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
    pNext: ?*c_void = null,
    name: [MAX_DESCRIPTION_SIZE]u8,
    description: [MAX_DESCRIPTION_SIZE]u8,
    isText: Bool32,
    dataSize: usize = 0,
    pData: ?*c_void = null,
};

pub extern fn vkGetPipelineExecutablePropertiesKHR(
    device: Device,
    pPipelineInfo: *const PipelineInfoKHR,
    pExecutableCount: *u32,
    pProperties: ?[*]PipelineExecutablePropertiesKHR,
) Result;

pub extern fn vkGetPipelineExecutableStatisticsKHR(
    device: Device,
    pExecutableInfo: *const PipelineExecutableInfoKHR,
    pStatisticCount: *u32,
    pStatistics: ?[*]PipelineExecutableStatisticKHR,
) Result;

pub extern fn vkGetPipelineExecutableInternalRepresentationsKHR(
    device: Device,
    pExecutableInfo: *const PipelineExecutableInfoKHR,
    pInternalRepresentationCount: *u32,
    pInternalRepresentations: ?[*]PipelineExecutableInternalRepresentationKHR,
) Result;

pub const GetPipelineExecutablePropertiesKHRResult = struct {
    result: Result,
    properties: []PipelineExecutablePropertiesKHR,
};
pub inline fn GetPipelineExecutablePropertiesKHR(device: Device, pipelineInfo: PipelineInfoKHR, properties: []PipelineExecutablePropertiesKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPipelineExecutablePropertiesKHRResult {
    var returnValues: GetPipelineExecutablePropertiesKHRResult = undefined;
    var executableCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPipelineExecutablePropertiesKHR(device, &pipelineInfo, &executableCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..executableCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPipelineExecutablePropertiesCountKHR(device: Device, pipelineInfo: PipelineInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_executableCount: u32 = undefined;
    const result = vkGetPipelineExecutablePropertiesKHR(device, &pipelineInfo, &out_executableCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_executableCount;
}

pub const GetPipelineExecutableStatisticsKHRResult = struct {
    result: Result,
    statistics: []PipelineExecutableStatisticKHR,
};
pub inline fn GetPipelineExecutableStatisticsKHR(device: Device, executableInfo: PipelineExecutableInfoKHR, statistics: []PipelineExecutableStatisticKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPipelineExecutableStatisticsKHRResult {
    var returnValues: GetPipelineExecutableStatisticsKHRResult = undefined;
    var statisticCount: u32 = @intCast(u32, statistics.len);
    const result = vkGetPipelineExecutableStatisticsKHR(device, &executableInfo, &statisticCount, statistics.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.statistics = statistics[0..statisticCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPipelineExecutableStatisticsCountKHR(device: Device, executableInfo: PipelineExecutableInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_statisticCount: u32 = undefined;
    const result = vkGetPipelineExecutableStatisticsKHR(device, &executableInfo, &out_statisticCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_statisticCount;
}

pub const GetPipelineExecutableInternalRepresentationsKHRResult = struct {
    result: Result,
    internalRepresentations: []PipelineExecutableInternalRepresentationKHR,
};
pub inline fn GetPipelineExecutableInternalRepresentationsKHR(device: Device, executableInfo: PipelineExecutableInfoKHR, internalRepresentations: []PipelineExecutableInternalRepresentationKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPipelineExecutableInternalRepresentationsKHRResult {
    var returnValues: GetPipelineExecutableInternalRepresentationsKHRResult = undefined;
    var internalRepresentationCount: u32 = @intCast(u32, internalRepresentations.len);
    const result = vkGetPipelineExecutableInternalRepresentationsKHR(device, &executableInfo, &internalRepresentationCount, internalRepresentations.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.internalRepresentations = internalRepresentations[0..internalRepresentationCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPipelineExecutableInternalRepresentationsCountKHR(device: Device, executableInfo: PipelineExecutableInfoKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_internalRepresentationCount: u32 = undefined;
    const result = vkGetPipelineExecutableInternalRepresentationsKHR(device, &executableInfo, &out_internalRepresentationCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_internalRepresentationCount;
}


pub const EXT_debug_report = 1;
pub const DebugReportCallbackEXT = *@OpaqueType();

pub const EXT_DEBUG_REPORT_SPEC_VERSION = 9;
pub const EXT_DEBUG_REPORT_EXTENSION_NAME = c"VK_EXT_debug_report";

pub const DebugReportObjectTypeEXT = extern enum {
    UNKNOWN = 0,
    INSTANCE = 1,
    PHYSICAL_DEVICE = 2,
    DEVICE = 3,
    QUEUE = 4,
    SEMAPHORE = 5,
    COMMAND_BUFFER = 6,
    FENCE = 7,
    DEVICE_MEMORY = 8,
    BUFFER = 9,
    IMAGE = 10,
    EVENT = 11,
    QUERY_POOL = 12,
    BUFFER_VIEW = 13,
    IMAGE_VIEW = 14,
    SHADER_MODULE = 15,
    PIPELINE_CACHE = 16,
    PIPELINE_LAYOUT = 17,
    RENDER_PASS = 18,
    PIPELINE = 19,
    DESCRIPTOR_SET_LAYOUT = 20,
    SAMPLER = 21,
    DESCRIPTOR_POOL = 22,
    DESCRIPTOR_SET = 23,
    FRAMEBUFFER = 24,
    COMMAND_POOL = 25,
    SURFACE_KHR = 26,
    SWAPCHAIN_KHR = 27,
    DEBUG_REPORT_CALLBACK_EXT = 28,
    DISPLAY_KHR = 29,
    DISPLAY_MODE_KHR = 30,
    OBJECT_TABLE_NVX = 31,
    INDIRECT_COMMANDS_LAYOUT_NVX = 32,
    VALIDATION_CACHE_EXT = 33,
    SAMPLER_YCBCR_CONVERSION = 1000156000,
    DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    ACCELERATION_STRUCTURE_NV = 1000165000,

    const Self = @This();
    pub const DEBUG_REPORT = Self.DEBUG_REPORT_CALLBACK_EXT;
    pub const VALIDATION_CACHE = Self.VALIDATION_CACHE_EXT;
    pub const DESCRIPTOR_UPDATE_TEMPLATE_KHR = Self.DESCRIPTOR_UPDATE_TEMPLATE;
    pub const SAMPLER_YCBCR_CONVERSION_KHR = Self.SAMPLER_YCBCR_CONVERSION;
};

pub const DebugReportFlagsEXT = Flags;
pub const DebugReportFlagBitsEXT = struct {
    pub const INFORMATION_BIT: DebugReportFlagsEXT = 0x00000001;
    pub const WARNING_BIT: DebugReportFlagsEXT = 0x00000002;
    pub const PERFORMANCE_WARNING_BIT: DebugReportFlagsEXT = 0x00000004;
    pub const ERROR_BIT: DebugReportFlagsEXT = 0x00000008;
    pub const DEBUG_BIT: DebugReportFlagsEXT = 0x00000010;
};

pub const PFN_DebugReportCallbackEXT = extern fn (
    DebugReportFlagsEXT,
    DebugReportObjectTypeEXT,
    u64,
    usize,
    i32,
    ?CString,
    ?CString,
    ?*c_void,
) Bool32;

pub const DebugReportCallbackCreateInfoEXT = extern struct {
    sType: StructureType = .DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: DebugReportFlagsEXT = 0,
    pfnCallback: PFN_DebugReportCallbackEXT,
    pUserData: ?*c_void = null,
};

pub extern fn vkCreateDebugReportCallbackEXT(
    instance: Instance,
    pCreateInfo: *const DebugReportCallbackCreateInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pCallback: *DebugReportCallbackEXT,
) Result;

pub extern fn vkDestroyDebugReportCallbackEXT(
    instance: Instance,
    callback: DebugReportCallbackEXT,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkDebugReportMessageEXT(
    instance: Instance,
    flags: DebugReportFlagsEXT,
    objectType: DebugReportObjectTypeEXT,
    object: u64,
    location: usize,
    messageCode: i32,
    pLayerPrefix: CString,
    pMessage: CString,
) void;

pub inline fn CreateDebugReportCallbackEXT(instance: Instance, createInfo: DebugReportCallbackCreateInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!DebugReportCallbackEXT {
    var out_callback: DebugReportCallbackEXT = undefined;
    const result = vkCreateDebugReportCallbackEXT(instance, &createInfo, pAllocator, &out_callback);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_callback;
}

pub const DestroyDebugReportCallbackEXT = vkDestroyDebugReportCallbackEXT;
pub const DebugReportMessageEXT = vkDebugReportMessageEXT;


pub const NV_glsl_shader = 1;
pub const NV_GLSL_SHADER_SPEC_VERSION = 1;
pub const NV_GLSL_SHADER_EXTENSION_NAME = c"VK_NV_glsl_shader";


pub const EXT_depth_range_unrestricted = 1;
pub const EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1;
pub const EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = c"VK_EXT_depth_range_unrestricted";


pub const IMG_filter_cubic = 1;
pub const IMG_FILTER_CUBIC_SPEC_VERSION = 1;
pub const IMG_FILTER_CUBIC_EXTENSION_NAME = c"VK_IMG_filter_cubic";


pub const AMD_rasterization_order = 1;
pub const AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1;
pub const AMD_RASTERIZATION_ORDER_EXTENSION_NAME = c"VK_AMD_rasterization_order";

pub const RasterizationOrderAMD = extern enum {
    STRICT = 0,
    RELAXED = 1,
};

pub const PipelineRasterizationStateRasterizationOrderAMD = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    pNext: ?*const c_void = null,
    rasterizationOrder: RasterizationOrderAMD,
};


pub const AMD_shader_trinary_minmax = 1;
pub const AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1;
pub const AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = c"VK_AMD_shader_trinary_minmax";


pub const AMD_shader_explicit_vertex_parameter = 1;
pub const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1;
pub const AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = c"VK_AMD_shader_explicit_vertex_parameter";


pub const EXT_debug_marker = 1;
pub const EXT_DEBUG_MARKER_SPEC_VERSION = 4;
pub const EXT_DEBUG_MARKER_EXTENSION_NAME = c"VK_EXT_debug_marker";

pub const DebugMarkerObjectNameInfoEXT = extern struct {
    sType: StructureType = .DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    pNext: ?*const c_void = null,
    objectType: DebugReportObjectTypeEXT,
    object: u64,
    pObjectName: CString,
};

pub const DebugMarkerObjectTagInfoEXT = extern struct {
    sType: StructureType = .DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    pNext: ?*const c_void = null,
    objectType: DebugReportObjectTypeEXT,
    object: u64,
    tagName: u64,
    tagSize: usize,
    pTag: ?*const c_void,
};

pub const DebugMarkerMarkerInfoEXT = extern struct {
    sType: StructureType = .DEBUG_MARKER_MARKER_INFO_EXT,
    pNext: ?*const c_void = null,
    pMarkerName: CString,
    color: [4]f32 = 0,
};

pub extern fn vkDebugMarkerSetObjectTagEXT(
    device: Device,
    pTagInfo: *const DebugMarkerObjectTagInfoEXT,
) Result;

pub extern fn vkDebugMarkerSetObjectNameEXT(
    device: Device,
    pNameInfo: *const DebugMarkerObjectNameInfoEXT,
) Result;

pub extern fn vkCmdDebugMarkerBeginEXT(
    commandBuffer: CommandBuffer,
    pMarkerInfo: *const DebugMarkerMarkerInfoEXT,
) void;

pub extern fn vkCmdDebugMarkerEndEXT(commandBuffer: CommandBuffer) void;

pub extern fn vkCmdDebugMarkerInsertEXT(
    commandBuffer: CommandBuffer,
    pMarkerInfo: *const DebugMarkerMarkerInfoEXT,
) void;

pub inline fn DebugMarkerSetObjectTagEXT(device: Device, tagInfo: DebugMarkerObjectTagInfoEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkDebugMarkerSetObjectTagEXT(device, &tagInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn DebugMarkerSetObjectNameEXT(device: Device, nameInfo: DebugMarkerObjectNameInfoEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkDebugMarkerSetObjectNameEXT(device, &nameInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CmdDebugMarkerBeginEXT(commandBuffer: CommandBuffer, markerInfo: DebugMarkerMarkerInfoEXT) void {
    vkCmdDebugMarkerBeginEXT(commandBuffer, &markerInfo);
}

pub const CmdDebugMarkerEndEXT = vkCmdDebugMarkerEndEXT;

pub inline fn CmdDebugMarkerInsertEXT(commandBuffer: CommandBuffer, markerInfo: DebugMarkerMarkerInfoEXT) void {
    vkCmdDebugMarkerInsertEXT(commandBuffer, &markerInfo);
}


pub const AMD_gcn_shader = 1;
pub const AMD_GCN_SHADER_SPEC_VERSION = 1;
pub const AMD_GCN_SHADER_EXTENSION_NAME = c"VK_AMD_gcn_shader";


pub const NV_dedicated_allocation = 1;
pub const NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1;
pub const NV_DEDICATED_ALLOCATION_EXTENSION_NAME = c"VK_NV_dedicated_allocation";

pub const DedicatedAllocationImageCreateInfoNV = extern struct {
    sType: StructureType = .DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    dedicatedAllocation: Bool32,
};

pub const DedicatedAllocationBufferCreateInfoNV = extern struct {
    sType: StructureType = .DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    dedicatedAllocation: Bool32,
};

pub const DedicatedAllocationMemoryAllocateInfoNV = extern struct {
    sType: StructureType = .DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    pNext: ?*const c_void = null,
    image: ?Image = null,
    buffer: ?Buffer = null,
};


pub const EXT_transform_feedback = 1;
pub const EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1;
pub const EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = c"VK_EXT_transform_feedback";

pub const PipelineRasterizationStateStreamCreateFlagsEXT = Flags;

pub const PhysicalDeviceTransformFeedbackFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
    pNext: ?*c_void = null,
    transformFeedback: Bool32,
    geometryStreams: Bool32,
};

pub const PhysicalDeviceTransformFeedbackPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    maxTransformFeedbackStreams: u32,
    maxTransformFeedbackBuffers: u32,
    maxTransformFeedbackBufferSize: DeviceSize,
    maxTransformFeedbackStreamDataSize: u32,
    maxTransformFeedbackBufferDataSize: u32,
    maxTransformFeedbackBufferDataStride: u32,
    transformFeedbackQueries: Bool32,
    transformFeedbackStreamsLinesTriangles: Bool32,
    transformFeedbackRasterizationStreamSelect: Bool32,
    transformFeedbackDraw: Bool32,
};

pub const PipelineRasterizationStateStreamCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: PipelineRasterizationStateStreamCreateFlagsEXT = 0,
    rasterizationStream: u32,
};

pub extern fn vkCmdBindTransformFeedbackBuffersEXT(
    commandBuffer: CommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    pBuffers: [*]const Buffer,
    pOffsets: [*]const DeviceSize,
    pSizes: ?[*]const DeviceSize,
) void;

pub extern fn vkCmdBeginTransformFeedbackEXT(
    commandBuffer: CommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: u32,
    pCounterBuffers: [*]const Buffer,
    pCounterBufferOffsets: ?[*]const DeviceSize,
) void;

pub extern fn vkCmdEndTransformFeedbackEXT(
    commandBuffer: CommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: u32,
    pCounterBuffers: [*]const Buffer,
    pCounterBufferOffsets: ?[*]const DeviceSize,
) void;

pub extern fn vkCmdBeginQueryIndexedEXT(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    query: u32,
    flags: QueryControlFlags,
    index: u32,
) void;

pub extern fn vkCmdEndQueryIndexedEXT(
    commandBuffer: CommandBuffer,
    queryPool: QueryPool,
    query: u32,
    index: u32,
) void;

pub extern fn vkCmdDrawIndirectByteCountEXT(
    commandBuffer: CommandBuffer,
    instanceCount: u32,
    firstInstance: u32,
    counterBuffer: Buffer,
    counterBufferOffset: DeviceSize,
    counterOffset: u32,
    vertexStride: u32,
) void;

pub inline fn CmdBindTransformFeedbackBuffersEXT(commandBuffer: CommandBuffer, firstBinding: u32, buffers: []const Buffer, offsets: []const DeviceSize, sizes: []const DeviceSize) void {
    assert(offsets.len >= buffers.len);
    assert(sizes.len >= buffers.len);
    vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, @intCast(u32, buffers.len), buffers.ptr, offsets.ptr, sizes.ptr);
}

pub inline fn CmdBeginTransformFeedbackEXT(commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBuffers: []const Buffer, counterBufferOffsets: []const DeviceSize) void {
    assert(counterBufferOffsets.len >= counterBuffers.len);
    vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, @intCast(u32, counterBuffers.len), counterBuffers.ptr, counterBufferOffsets.ptr);
}

pub inline fn CmdEndTransformFeedbackEXT(commandBuffer: CommandBuffer, firstCounterBuffer: u32, counterBuffers: []const Buffer, counterBufferOffsets: []const DeviceSize) void {
    assert(counterBufferOffsets.len >= counterBuffers.len);
    vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, @intCast(u32, counterBuffers.len), counterBuffers.ptr, counterBufferOffsets.ptr);
}

pub const CmdBeginQueryIndexedEXT = vkCmdBeginQueryIndexedEXT;
pub const CmdEndQueryIndexedEXT = vkCmdEndQueryIndexedEXT;
pub const CmdDrawIndirectByteCountEXT = vkCmdDrawIndirectByteCountEXT;


pub const NVX_image_view_handle = 1;
pub const NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 1;
pub const NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = c"VK_NVX_image_view_handle";

pub const ImageViewHandleInfoNVX = extern struct {
    sType: StructureType = .IMAGE_VIEW_HANDLE_INFO_NVX,
    pNext: ?*const c_void = null,
    imageView: ImageView,
    descriptorType: DescriptorType,
    sampler: ?Sampler = null,
};

pub extern fn vkGetImageViewHandleNVX(
    device: Device,
    pInfo: *const ImageViewHandleInfoNVX,
) u32;

pub inline fn GetImageViewHandleNVX(device: Device, info: ImageViewHandleInfoNVX) u32 {
    const result = vkGetImageViewHandleNVX(device, &info);
    return result;
}


pub const AMD_draw_indirect_count = 1;
pub const AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2;
pub const AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = c"VK_AMD_draw_indirect_count";

pub extern fn vkCmdDrawIndirectCountAMD(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDrawIndexedIndirectCountAMD(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub const CmdDrawIndirectCountAMD = vkCmdDrawIndirectCountAMD;
pub const CmdDrawIndexedIndirectCountAMD = vkCmdDrawIndexedIndirectCountAMD;


pub const AMD_negative_viewport_height = 1;
pub const AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1;
pub const AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = c"VK_AMD_negative_viewport_height";


pub const AMD_gpu_shader_half_float = 1;
pub const AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2;
pub const AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = c"VK_AMD_gpu_shader_half_float";


pub const AMD_shader_ballot = 1;
pub const AMD_SHADER_BALLOT_SPEC_VERSION = 1;
pub const AMD_SHADER_BALLOT_EXTENSION_NAME = c"VK_AMD_shader_ballot";


pub const AMD_texture_gather_bias_lod = 1;
pub const AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1;
pub const AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = c"VK_AMD_texture_gather_bias_lod";

pub const TextureLODGatherFormatPropertiesAMD = extern struct {
    sType: StructureType = .TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    pNext: ?*c_void = null,
    supportsTextureGatherLODBiasAMD: Bool32,
};


pub const AMD_shader_info = 1;
pub const AMD_SHADER_INFO_SPEC_VERSION = 1;
pub const AMD_SHADER_INFO_EXTENSION_NAME = c"VK_AMD_shader_info";

pub const ShaderInfoTypeAMD = extern enum {
    STATISTICS = 0,
    BINARY = 1,
    DISASSEMBLY = 2,
};

pub const ShaderResourceUsageAMD = extern struct {
    numUsedVgprs: u32,
    numUsedSgprs: u32,
    ldsSizePerLocalWorkGroup: u32,
    ldsUsageSizeInBytes: usize,
    scratchMemUsageInBytes: usize,
};

pub const ShaderStatisticsInfoAMD = extern struct {
    shaderStageMask: ShaderStageFlags,
    resourceUsage: ShaderResourceUsageAMD,
    numPhysicalVgprs: u32,
    numPhysicalSgprs: u32,
    numAvailableVgprs: u32,
    numAvailableSgprs: u32,
    computeWorkGroupSize: [3]u32,
};

pub extern fn vkGetShaderInfoAMD(
    device: Device,
    pipeline: Pipeline,
    shaderStage: ShaderStageFlags,
    infoType: ShaderInfoTypeAMD,
    pInfoSize: *usize,
    pInfo: ?*c_void,
) Result;

pub const GetShaderInfoAMDResult = struct {
    result: Result,
    info: []u8,
};
pub inline fn GetShaderInfoAMD(device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlags, infoType: ShaderInfoTypeAMD, info: []u8) error{VK_FEATURE_NOT_PRESENT,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!GetShaderInfoAMDResult {
    var returnValues: GetShaderInfoAMDResult = undefined;
    var infoSize: usize = @intCast(usize, info.len);
    const result = vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, &infoSize, info.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_FEATURE_NOT_PRESENT => error.VK_FEATURE_NOT_PRESENT,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.info = info[0..infoSize];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetShaderInfoCountAMD(device: Device, pipeline: Pipeline, shaderStage: ShaderStageFlags, infoType: ShaderInfoTypeAMD) error{VK_FEATURE_NOT_PRESENT,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!usize {
    var out_infoSize: usize = undefined;
    const result = vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, &out_infoSize, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_FEATURE_NOT_PRESENT => error.VK_FEATURE_NOT_PRESENT,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_infoSize;
}


pub const AMD_shader_image_load_store_lod = 1;
pub const AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1;
pub const AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = c"VK_AMD_shader_image_load_store_lod";


pub const NV_corner_sampled_image = 1;
pub const NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2;
pub const NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = c"VK_NV_corner_sampled_image";

pub const PhysicalDeviceCornerSampledImageFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
    pNext: ?*c_void = null,
    cornerSampledImage: Bool32,
};


pub const IMG_format_pvrtc = 1;
pub const IMG_FORMAT_PVRTC_SPEC_VERSION = 1;
pub const IMG_FORMAT_PVRTC_EXTENSION_NAME = c"VK_IMG_format_pvrtc";


pub const NV_external_memory_capabilities = 1;
pub const NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
pub const NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = c"VK_NV_external_memory_capabilities";

pub const ExternalMemoryHandleTypeFlagsNV = Flags;
pub const ExternalMemoryHandleTypeFlagBitsNV = struct {
    pub const OPAQUE_WIN32_BIT: ExternalMemoryHandleTypeFlagsNV = 0x00000001;
    pub const OPAQUE_WIN32_KMT_BIT: ExternalMemoryHandleTypeFlagsNV = 0x00000002;
    pub const D3D11_IMAGE_BIT: ExternalMemoryHandleTypeFlagsNV = 0x00000004;
    pub const D3D11_IMAGE_KMT_BIT: ExternalMemoryHandleTypeFlagsNV = 0x00000008;
};

pub const ExternalMemoryFeatureFlagsNV = Flags;
pub const ExternalMemoryFeatureFlagBitsNV = struct {
    pub const DEDICATED_ONLY_BIT: ExternalMemoryFeatureFlagsNV = 0x00000001;
    pub const EXPORTABLE_BIT: ExternalMemoryFeatureFlagsNV = 0x00000002;
    pub const IMPORTABLE_BIT: ExternalMemoryFeatureFlagsNV = 0x00000004;
};

pub const ExternalImageFormatPropertiesNV = extern struct {
    imageFormatProperties: ImageFormatProperties,
    externalMemoryFeatures: ExternalMemoryFeatureFlagsNV = 0,
    exportFromImportedHandleTypes: ExternalMemoryHandleTypeFlagsNV = 0,
    compatibleHandleTypes: ExternalMemoryHandleTypeFlagsNV = 0,
};

pub extern fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    physicalDevice: PhysicalDevice,
    format: Format,
    inType: ImageType,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    flags: ImageCreateFlags,
    externalHandleType: ExternalMemoryHandleTypeFlagsNV,
    pExternalImageFormatProperties: *ExternalImageFormatPropertiesNV,
) Result;

pub inline fn GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice: PhysicalDevice, format: Format, inType: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, externalHandleType: ExternalMemoryHandleTypeFlagsNV) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_FORMAT_NOT_SUPPORTED,VK_UNDOCUMENTED_ERROR}!ExternalImageFormatPropertiesNV {
    var out_externalImageFormatProperties: ExternalImageFormatPropertiesNV = undefined;
    const result = vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, inType, tiling, usage, flags, externalHandleType, &out_externalImageFormatProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_FORMAT_NOT_SUPPORTED => error.VK_FORMAT_NOT_SUPPORTED,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_externalImageFormatProperties;
}


pub const NV_external_memory = 1;
pub const NV_EXTERNAL_MEMORY_SPEC_VERSION = 1;
pub const NV_EXTERNAL_MEMORY_EXTENSION_NAME = c"VK_NV_external_memory";

pub const ExternalMemoryImageCreateInfoNV = extern struct {
    sType: StructureType = .EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    handleTypes: ExternalMemoryHandleTypeFlagsNV = 0,
};

pub const ExportMemoryAllocateInfoNV = extern struct {
    sType: StructureType = .EXPORT_MEMORY_ALLOCATE_INFO_NV,
    pNext: ?*const c_void = null,
    handleTypes: ExternalMemoryHandleTypeFlagsNV = 0,
};


pub const EXT_validation_flags = 1;
pub const EXT_VALIDATION_FLAGS_SPEC_VERSION = 2;
pub const EXT_VALIDATION_FLAGS_EXTENSION_NAME = c"VK_EXT_validation_flags";

pub const ValidationCheckEXT = extern enum {
    ALL = 0,
    SHADERS = 1,
};

pub const ValidationFlagsEXT = extern struct {
    sType: StructureType = .VALIDATION_FLAGS_EXT,
    pNext: ?*const c_void = null,
    disabledValidationCheckCount: u32,
    pDisabledValidationChecks: [*]const ValidationCheckEXT,
};


pub const EXT_shader_subgroup_ballot = 1;
pub const EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1;
pub const EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = c"VK_EXT_shader_subgroup_ballot";


pub const EXT_shader_subgroup_vote = 1;
pub const EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1;
pub const EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = c"VK_EXT_shader_subgroup_vote";


pub const EXT_texture_compression_astc_hdr = 1;
pub const EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1;
pub const EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = c"VK_EXT_texture_compression_astc_hdr";

pub const PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
    pNext: ?*c_void = null,
    textureCompressionASTC_HDR: Bool32,
};


pub const EXT_astc_decode_mode = 1;
pub const EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1;
pub const EXT_ASTC_DECODE_MODE_EXTENSION_NAME = c"VK_EXT_astc_decode_mode";

pub const ImageViewASTCDecodeModeEXT = extern struct {
    sType: StructureType = .IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
    pNext: ?*const c_void = null,
    decodeMode: Format,
};

pub const PhysicalDeviceASTCDecodeFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
    pNext: ?*c_void = null,
    decodeModeSharedExponent: Bool32,
};


pub const EXT_conditional_rendering = 1;
pub const EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2;
pub const EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = c"VK_EXT_conditional_rendering";

pub const ConditionalRenderingFlagsEXT = Flags;
pub const ConditionalRenderingFlagBitsEXT = struct {
    pub const INVERTED_BIT: ConditionalRenderingFlagsEXT = 0x00000001;
};

pub const ConditionalRenderingBeginInfoEXT = extern struct {
    sType: StructureType = .CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
    pNext: ?*const c_void = null,
    buffer: Buffer,
    offset: DeviceSize,
    flags: ConditionalRenderingFlagsEXT = 0,
};

pub const PhysicalDeviceConditionalRenderingFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
    pNext: ?*c_void = null,
    conditionalRendering: Bool32,
    inheritedConditionalRendering: Bool32,
};

pub const CommandBufferInheritanceConditionalRenderingInfoEXT = extern struct {
    sType: StructureType = .COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
    pNext: ?*const c_void = null,
    conditionalRenderingEnable: Bool32,
};

pub extern fn vkCmdBeginConditionalRenderingEXT(
    commandBuffer: CommandBuffer,
    pConditionalRenderingBegin: *const ConditionalRenderingBeginInfoEXT,
) void;

pub extern fn vkCmdEndConditionalRenderingEXT(commandBuffer: CommandBuffer) void;

pub inline fn CmdBeginConditionalRenderingEXT(commandBuffer: CommandBuffer, conditionalRenderingBegin: ConditionalRenderingBeginInfoEXT) void {
    vkCmdBeginConditionalRenderingEXT(commandBuffer, &conditionalRenderingBegin);
}

pub const CmdEndConditionalRenderingEXT = vkCmdEndConditionalRenderingEXT;


pub const NVX_device_generated_commands = 1;
pub const ObjectTableNVX = *@OpaqueType();
pub const IndirectCommandsLayoutNVX = *@OpaqueType();

pub const NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3;
pub const NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = c"VK_NVX_device_generated_commands";

pub const IndirectCommandsTokenTypeNVX = extern enum {
    PIPELINE = 0,
    DESCRIPTOR_SET = 1,
    INDEX_BUFFER = 2,
    VERTEX_BUFFER = 3,
    PUSH_CONSTANT = 4,
    DRAW_INDEXED = 5,
    DRAW = 6,
    DISPATCH = 7,
};

pub const ObjectEntryTypeNVX = extern enum {
    DESCRIPTOR_SET = 0,
    PIPELINE = 1,
    INDEX_BUFFER = 2,
    VERTEX_BUFFER = 3,
    PUSH_CONSTANT = 4,
};

pub const IndirectCommandsLayoutUsageFlagsNVX = Flags;
pub const IndirectCommandsLayoutUsageFlagBitsNVX = struct {
    pub const UNORDERED_SEQUENCES_BIT: IndirectCommandsLayoutUsageFlagsNVX = 0x00000001;
    pub const SPARSE_SEQUENCES_BIT: IndirectCommandsLayoutUsageFlagsNVX = 0x00000002;
    pub const EMPTY_EXECUTIONS_BIT: IndirectCommandsLayoutUsageFlagsNVX = 0x00000004;
    pub const INDEXED_SEQUENCES_BIT: IndirectCommandsLayoutUsageFlagsNVX = 0x00000008;
};

pub const ObjectEntryUsageFlagsNVX = Flags;
pub const ObjectEntryUsageFlagBitsNVX = struct {
    pub const GRAPHICS_BIT: ObjectEntryUsageFlagsNVX = 0x00000001;
    pub const COMPUTE_BIT: ObjectEntryUsageFlagsNVX = 0x00000002;
};

pub const DeviceGeneratedCommandsFeaturesNVX = extern struct {
    sType: StructureType = .DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
    pNext: ?*const c_void = null,
    computeBindingPointSupport: Bool32,
};

pub const DeviceGeneratedCommandsLimitsNVX = extern struct {
    sType: StructureType = .DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
    pNext: ?*const c_void = null,
    maxIndirectCommandsLayoutTokenCount: u32,
    maxObjectEntryCounts: u32,
    minSequenceCountBufferOffsetAlignment: u32,
    minSequenceIndexBufferOffsetAlignment: u32,
    minCommandsTokenBufferOffsetAlignment: u32,
};

pub const IndirectCommandsTokenNVX = extern struct {
    tokenType: IndirectCommandsTokenTypeNVX,
    buffer: Buffer,
    offset: DeviceSize,
};

pub const IndirectCommandsLayoutTokenNVX = extern struct {
    tokenType: IndirectCommandsTokenTypeNVX,
    bindingUnit: u32,
    dynamicCount: u32,
    divisor: u32,
};

pub const IndirectCommandsLayoutCreateInfoNVX = extern struct {
    sType: StructureType = .INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
    pNext: ?*const c_void = null,
    pipelineBindPoint: PipelineBindPoint,
    flags: IndirectCommandsLayoutUsageFlagsNVX,
    tokenCount: u32,
    pTokens: [*]const IndirectCommandsLayoutTokenNVX,
};

pub const CmdProcessCommandsInfoNVX = extern struct {
    sType: StructureType = .CMD_PROCESS_COMMANDS_INFO_NVX,
    pNext: ?*const c_void = null,
    objectTable: ObjectTableNVX,
    indirectCommandsLayout: IndirectCommandsLayoutNVX,
    indirectCommandsTokenCount: u32,
    pIndirectCommandsTokens: [*]const IndirectCommandsTokenNVX,
    maxSequencesCount: u32,
    targetCommandBuffer: ?CommandBuffer = null,
    sequencesCountBuffer: ?Buffer = null,
    sequencesCountOffset: DeviceSize = 0,
    sequencesIndexBuffer: ?Buffer = null,
    sequencesIndexOffset: DeviceSize = 0,
};

pub const CmdReserveSpaceForCommandsInfoNVX = extern struct {
    sType: StructureType = .CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
    pNext: ?*const c_void = null,
    objectTable: ObjectTableNVX,
    indirectCommandsLayout: IndirectCommandsLayoutNVX,
    maxSequencesCount: u32,
};

pub const ObjectTableCreateInfoNVX = extern struct {
    sType: StructureType = .OBJECT_TABLE_CREATE_INFO_NVX,
    pNext: ?*const c_void = null,
    objectCount: u32,
    pObjectEntryTypes: [*]const ObjectEntryTypeNVX,
    pObjectEntryCounts: [*]const u32,
    pObjectEntryUsageFlags: [*]const ObjectEntryUsageFlagsNVX,
    maxUniformBuffersPerDescriptor: u32,
    maxStorageBuffersPerDescriptor: u32,
    maxStorageImagesPerDescriptor: u32,
    maxSampledImagesPerDescriptor: u32,
    maxPipelineLayouts: u32,
};

pub const ObjectTableEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
};

pub const ObjectTablePipelineEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
    pipeline: Pipeline,
};

pub const ObjectTableDescriptorSetEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
    pipelineLayout: PipelineLayout,
    descriptorSet: DescriptorSet,
};

pub const ObjectTableVertexBufferEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
    buffer: Buffer,
};

pub const ObjectTableIndexBufferEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
    buffer: Buffer,
    indexType: IndexType,
};

pub const ObjectTablePushConstantEntryNVX = extern struct {
    inType: ObjectEntryTypeNVX,
    flags: ObjectEntryUsageFlagsNVX,
    pipelineLayout: PipelineLayout,
    stageFlags: ShaderStageFlags,
};

pub extern fn vkCmdProcessCommandsNVX(
    commandBuffer: CommandBuffer,
    pProcessCommandsInfo: *const CmdProcessCommandsInfoNVX,
) void;

pub extern fn vkCmdReserveSpaceForCommandsNVX(
    commandBuffer: CommandBuffer,
    pReserveSpaceInfo: *const CmdReserveSpaceForCommandsInfoNVX,
) void;

pub extern fn vkCreateIndirectCommandsLayoutNVX(
    device: Device,
    pCreateInfo: *const IndirectCommandsLayoutCreateInfoNVX,
    pAllocator: ?*const AllocationCallbacks,
    pIndirectCommandsLayout: *IndirectCommandsLayoutNVX,
) Result;

pub extern fn vkDestroyIndirectCommandsLayoutNVX(
    device: Device,
    indirectCommandsLayout: IndirectCommandsLayoutNVX,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkCreateObjectTableNVX(
    device: Device,
    pCreateInfo: *const ObjectTableCreateInfoNVX,
    pAllocator: ?*const AllocationCallbacks,
    pObjectTable: *ObjectTableNVX,
) Result;

pub extern fn vkDestroyObjectTableNVX(
    device: Device,
    objectTable: ObjectTableNVX,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkRegisterObjectsNVX(
    device: Device,
    objectTable: ObjectTableNVX,
    objectCount: u32,
    ppObjectTableEntries: [*]const*const ObjectTableEntryNVX,
    pObjectIndices: [*]const u32,
) Result;

pub extern fn vkUnregisterObjectsNVX(
    device: Device,
    objectTable: ObjectTableNVX,
    objectCount: u32,
    pObjectEntryTypes: [*]const ObjectEntryTypeNVX,
    pObjectIndices: [*]const u32,
) Result;

pub extern fn vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    physicalDevice: PhysicalDevice,
    pFeatures: *DeviceGeneratedCommandsFeaturesNVX,
    pLimits: *DeviceGeneratedCommandsLimitsNVX,
) void;

pub inline fn CmdProcessCommandsNVX(commandBuffer: CommandBuffer, processCommandsInfo: CmdProcessCommandsInfoNVX) void {
    vkCmdProcessCommandsNVX(commandBuffer, &processCommandsInfo);
}

pub inline fn CmdReserveSpaceForCommandsNVX(commandBuffer: CommandBuffer, reserveSpaceInfo: CmdReserveSpaceForCommandsInfoNVX) void {
    vkCmdReserveSpaceForCommandsNVX(commandBuffer, &reserveSpaceInfo);
}

pub inline fn CreateIndirectCommandsLayoutNVX(device: Device, createInfo: IndirectCommandsLayoutCreateInfoNVX, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!IndirectCommandsLayoutNVX {
    var out_indirectCommandsLayout: IndirectCommandsLayoutNVX = undefined;
    const result = vkCreateIndirectCommandsLayoutNVX(device, &createInfo, pAllocator, &out_indirectCommandsLayout);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_indirectCommandsLayout;
}

pub const DestroyIndirectCommandsLayoutNVX = vkDestroyIndirectCommandsLayoutNVX;

pub inline fn CreateObjectTableNVX(device: Device, createInfo: ObjectTableCreateInfoNVX, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!ObjectTableNVX {
    var out_objectTable: ObjectTableNVX = undefined;
    const result = vkCreateObjectTableNVX(device, &createInfo, pAllocator, &out_objectTable);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_objectTable;
}

pub const DestroyObjectTableNVX = vkDestroyObjectTableNVX;

pub inline fn RegisterObjectsNVX(device: Device, objectTable: ObjectTableNVX, pObjectTableEntries: []const*const ObjectTableEntryNVX, objectIndices: []const u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    assert(objectIndices.len >= pObjectTableEntries.len);
    const result = vkRegisterObjectsNVX(device, objectTable, @intCast(u32, pObjectTableEntries.len), pObjectTableEntries.ptr, objectIndices.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn UnregisterObjectsNVX(device: Device, objectTable: ObjectTableNVX, objectEntryTypes: []const ObjectEntryTypeNVX, objectIndices: []const u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    assert(objectIndices.len >= objectEntryTypes.len);
    const result = vkUnregisterObjectsNVX(device, objectTable, @intCast(u32, objectEntryTypes.len), objectEntryTypes.ptr, objectIndices.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const GetPhysicalDeviceGeneratedCommandsPropertiesNVXResult = struct {
    features: DeviceGeneratedCommandsFeaturesNVX,
    limits: DeviceGeneratedCommandsLimitsNVX,
};
pub inline fn GetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice: PhysicalDevice) GetPhysicalDeviceGeneratedCommandsPropertiesNVXResult {
    var returnValues: GetPhysicalDeviceGeneratedCommandsPropertiesNVXResult = undefined;
    vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, &returnValues.features, &returnValues.limits);
    return returnValues;
}


pub const NV_clip_space_w_scaling = 1;
pub const NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1;
pub const NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = c"VK_NV_clip_space_w_scaling";

pub const ViewportWScalingNV = extern struct {
    xcoeff: f32,
    ycoeff: f32,
};

pub const PipelineViewportWScalingStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    viewportWScalingEnable: Bool32,
    viewportCount: u32,
    pViewportWScalings: ?[*]const ViewportWScalingNV = null,
};

pub extern fn vkCmdSetViewportWScalingNV(
    commandBuffer: CommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    pViewportWScalings: [*]const ViewportWScalingNV,
) void;

pub inline fn CmdSetViewportWScalingNV(commandBuffer: CommandBuffer, firstViewport: u32, viewportWScalings: []const ViewportWScalingNV) void {
    vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, @intCast(u32, viewportWScalings.len), viewportWScalings.ptr);
}


pub const EXT_direct_mode_display = 1;
pub const EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1;
pub const EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = c"VK_EXT_direct_mode_display";

pub extern fn vkReleaseDisplayEXT(
    physicalDevice: PhysicalDevice,
    display: DisplayKHR,
) Result;

pub inline fn ReleaseDisplayEXT(physicalDevice: PhysicalDevice, display: DisplayKHR) error{VK_UNDOCUMENTED_ERROR}!void {
    const result = vkReleaseDisplayEXT(physicalDevice, display);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
}


pub const EXT_display_surface_counter = 1;
pub const EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1;
pub const EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = c"VK_EXT_display_surface_counter";

pub const SurfaceCounterFlagsEXT = Flags;
pub const SurfaceCounterFlagBitsEXT = struct {
    pub const VBLANK: SurfaceCounterFlagsEXT = 0x00000001;
};

pub const SurfaceCapabilities2EXT = extern struct {
    sType: StructureType = .SURFACE_CAPABILITIES_2_EXT,
    pNext: ?*c_void = null,
    minImageCount: u32,
    maxImageCount: u32,
    currentExtent: Extent2D,
    minImageExtent: Extent2D,
    maxImageExtent: Extent2D,
    maxImageArrayLayers: u32,
    supportedTransforms: SurfaceTransformFlagsKHR = 0,
    currentTransform: SurfaceTransformFlagsKHR,
    supportedCompositeAlpha: CompositeAlphaFlagsKHR = 0,
    supportedUsageFlags: ImageUsageFlags = 0,
    supportedSurfaceCounters: SurfaceCounterFlagsEXT = 0,
};

pub extern fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    physicalDevice: PhysicalDevice,
    surface: SurfaceKHR,
    pSurfaceCapabilities: *SurfaceCapabilities2EXT,
) Result;

pub inline fn GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice: PhysicalDevice, surface: SurfaceKHR) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!SurfaceCapabilities2EXT {
    var out_surfaceCapabilities: SurfaceCapabilities2EXT = undefined;
    const result = vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, &out_surfaceCapabilities);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surfaceCapabilities;
}


pub const EXT_display_control = 1;
pub const EXT_DISPLAY_CONTROL_SPEC_VERSION = 1;
pub const EXT_DISPLAY_CONTROL_EXTENSION_NAME = c"VK_EXT_display_control";

pub const DisplayPowerStateEXT = extern enum {
    OFF = 0,
    SUSPEND = 1,
    ON = 2,
};

pub const DeviceEventTypeEXT = extern enum {
    DISPLAY_HOTPLUG = 0,
};

pub const DisplayEventTypeEXT = extern enum {
    FIRST_PIXEL_OUT = 0,
};

pub const DisplayPowerInfoEXT = extern struct {
    sType: StructureType = .DISPLAY_POWER_INFO_EXT,
    pNext: ?*const c_void = null,
    powerState: DisplayPowerStateEXT,
};

pub const DeviceEventInfoEXT = extern struct {
    sType: StructureType = .DEVICE_EVENT_INFO_EXT,
    pNext: ?*const c_void = null,
    deviceEvent: DeviceEventTypeEXT,
};

pub const DisplayEventInfoEXT = extern struct {
    sType: StructureType = .DISPLAY_EVENT_INFO_EXT,
    pNext: ?*const c_void = null,
    displayEvent: DisplayEventTypeEXT,
};

pub const SwapchainCounterCreateInfoEXT = extern struct {
    sType: StructureType = .SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    surfaceCounters: SurfaceCounterFlagsEXT = 0,
};

pub extern fn vkDisplayPowerControlEXT(
    device: Device,
    display: DisplayKHR,
    pDisplayPowerInfo: *const DisplayPowerInfoEXT,
) Result;

pub extern fn vkRegisterDeviceEventEXT(
    device: Device,
    pDeviceEventInfo: *const DeviceEventInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pFence: *Fence,
) Result;

pub extern fn vkRegisterDisplayEventEXT(
    device: Device,
    display: DisplayKHR,
    pDisplayEventInfo: *const DisplayEventInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pFence: *Fence,
) Result;

pub extern fn vkGetSwapchainCounterEXT(
    device: Device,
    swapchain: SwapchainKHR,
    counter: SurfaceCounterFlagsEXT,
    pCounterValue: *u64,
) Result;

pub inline fn DisplayPowerControlEXT(device: Device, display: DisplayKHR, displayPowerInfo: DisplayPowerInfoEXT) error{VK_UNDOCUMENTED_ERROR}!void {
    const result = vkDisplayPowerControlEXT(device, display, &displayPowerInfo);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
}

pub inline fn RegisterDeviceEventEXT(device: Device, deviceEventInfo: DeviceEventInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_UNDOCUMENTED_ERROR}!Fence {
    var out_fence: Fence = undefined;
    const result = vkRegisterDeviceEventEXT(device, &deviceEventInfo, pAllocator, &out_fence);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    return out_fence;
}

pub inline fn RegisterDisplayEventEXT(device: Device, display: DisplayKHR, displayEventInfo: DisplayEventInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_UNDOCUMENTED_ERROR}!Fence {
    var out_fence: Fence = undefined;
    const result = vkRegisterDisplayEventEXT(device, display, &displayEventInfo, pAllocator, &out_fence);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    return out_fence;
}

pub inline fn GetSwapchainCounterEXT(device: Device, swapchain: SwapchainKHR, counter: SurfaceCounterFlagsEXT) error{VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_UNDOCUMENTED_ERROR}!u64 {
    var out_counterValue: u64 = undefined;
    const result = vkGetSwapchainCounterEXT(device, swapchain, counter, &out_counterValue);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_counterValue;
}


pub const GOOGLE_display_timing = 1;
pub const GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1;
pub const GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = c"VK_GOOGLE_display_timing";

pub const RefreshCycleDurationGOOGLE = extern struct {
    refreshDuration: u64,
};

pub const PastPresentationTimingGOOGLE = extern struct {
    presentID: u32,
    desiredPresentTime: u64,
    actualPresentTime: u64,
    earliestPresentTime: u64,
    presentMargin: u64,
};

pub const PresentTimeGOOGLE = extern struct {
    presentID: u32,
    desiredPresentTime: u64,
};

pub const PresentTimesInfoGOOGLE = extern struct {
    sType: StructureType = .PRESENT_TIMES_INFO_GOOGLE,
    pNext: ?*const c_void = null,
    swapchainCount: u32,
    pTimes: ?[*]const PresentTimeGOOGLE = null,
};

pub extern fn vkGetRefreshCycleDurationGOOGLE(
    device: Device,
    swapchain: SwapchainKHR,
    pDisplayTimingProperties: *RefreshCycleDurationGOOGLE,
) Result;

pub extern fn vkGetPastPresentationTimingGOOGLE(
    device: Device,
    swapchain: SwapchainKHR,
    pPresentationTimingCount: *u32,
    pPresentationTimings: ?[*]PastPresentationTimingGOOGLE,
) Result;

pub inline fn GetRefreshCycleDurationGOOGLE(device: Device, swapchain: SwapchainKHR) error{VK_DEVICE_LOST,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!RefreshCycleDurationGOOGLE {
    var out_displayTimingProperties: RefreshCycleDurationGOOGLE = undefined;
    const result = vkGetRefreshCycleDurationGOOGLE(device, swapchain, &out_displayTimingProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_displayTimingProperties;
}

pub const GetPastPresentationTimingGOOGLEResult = struct {
    result: Result,
    presentationTimings: []PastPresentationTimingGOOGLE,
};
pub inline fn GetPastPresentationTimingGOOGLE(device: Device, swapchain: SwapchainKHR, presentationTimings: []PastPresentationTimingGOOGLE) error{VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!GetPastPresentationTimingGOOGLEResult {
    var returnValues: GetPastPresentationTimingGOOGLEResult = undefined;
    var presentationTimingCount: u32 = @intCast(u32, presentationTimings.len);
    const result = vkGetPastPresentationTimingGOOGLE(device, swapchain, &presentationTimingCount, presentationTimings.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.presentationTimings = presentationTimings[0..presentationTimingCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPastPresentationTimingCountGOOGLE(device: Device, swapchain: SwapchainKHR) error{VK_DEVICE_LOST,VK_OUT_OF_DATE_KHR,VK_SURFACE_LOST_KHR,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_presentationTimingCount: u32 = undefined;
    const result = vkGetPastPresentationTimingGOOGLE(device, swapchain, &out_presentationTimingCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_DEVICE_LOST => error.VK_DEVICE_LOST,
            .ERROR_OUT_OF_DATE_KHR => error.VK_OUT_OF_DATE_KHR,
            .ERROR_SURFACE_LOST_KHR => error.VK_SURFACE_LOST_KHR,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_presentationTimingCount;
}


pub const NV_sample_mask_override_coverage = 1;
pub const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1;
pub const NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = c"VK_NV_sample_mask_override_coverage";


pub const NV_geometry_shader_passthrough = 1;
pub const NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1;
pub const NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = c"VK_NV_geometry_shader_passthrough";


pub const NV_viewport_array2 = 1;
pub const NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1;
pub const NV_VIEWPORT_ARRAY2_EXTENSION_NAME = c"VK_NV_viewport_array2";


pub const NVX_multiview_per_view_attributes = 1;
pub const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1;
pub const NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = c"VK_NVX_multiview_per_view_attributes";

pub const PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    pNext: ?*c_void = null,
    perViewPositionAllComponents: Bool32,
};


pub const NV_viewport_swizzle = 1;
pub const NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1;
pub const NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = c"VK_NV_viewport_swizzle";

pub const ViewportCoordinateSwizzleNV = extern enum {
    POSITIVE_X = 0,
    NEGATIVE_X = 1,
    POSITIVE_Y = 2,
    NEGATIVE_Y = 3,
    POSITIVE_Z = 4,
    NEGATIVE_Z = 5,
    POSITIVE_W = 6,
    NEGATIVE_W = 7,
};

pub const PipelineViewportSwizzleStateCreateFlagsNV = Flags;

pub const ViewportSwizzleNV = extern struct {
    x: ViewportCoordinateSwizzleNV,
    y: ViewportCoordinateSwizzleNV,
    z: ViewportCoordinateSwizzleNV,
    w: ViewportCoordinateSwizzleNV,
};

pub const PipelineViewportSwizzleStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    flags: PipelineViewportSwizzleStateCreateFlagsNV = 0,
    viewportCount: u32,
    pViewportSwizzles: [*]const ViewportSwizzleNV,
};


pub const EXT_discard_rectangles = 1;
pub const EXT_DISCARD_RECTANGLES_SPEC_VERSION = 1;
pub const EXT_DISCARD_RECTANGLES_EXTENSION_NAME = c"VK_EXT_discard_rectangles";

pub const DiscardRectangleModeEXT = extern enum {
    INCLUSIVE = 0,
    EXCLUSIVE = 1,
};

pub const PipelineDiscardRectangleStateCreateFlagsEXT = Flags;

pub const PhysicalDeviceDiscardRectanglePropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    maxDiscardRectangles: u32,
};

pub const PipelineDiscardRectangleStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: PipelineDiscardRectangleStateCreateFlagsEXT = 0,
    discardRectangleMode: DiscardRectangleModeEXT,
    discardRectangleCount: u32 = 0,
    pDiscardRectangles: ?[*]const Rect2D = null,
};

pub extern fn vkCmdSetDiscardRectangleEXT(
    commandBuffer: CommandBuffer,
    firstDiscardRectangle: u32,
    discardRectangleCount: u32,
    pDiscardRectangles: [*]const Rect2D,
) void;

pub inline fn CmdSetDiscardRectangleEXT(commandBuffer: CommandBuffer, firstDiscardRectangle: u32, discardRectangles: []const Rect2D) void {
    vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, @intCast(u32, discardRectangles.len), discardRectangles.ptr);
}


pub const EXT_conservative_rasterization = 1;
pub const EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1;
pub const EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = c"VK_EXT_conservative_rasterization";

pub const ConservativeRasterizationModeEXT = extern enum {
    DISABLED = 0,
    OVERESTIMATE = 1,
    UNDERESTIMATE = 2,
};

pub const PipelineRasterizationConservativeStateCreateFlagsEXT = Flags;

pub const PhysicalDeviceConservativeRasterizationPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    primitiveOverestimationSize: f32,
    maxExtraPrimitiveOverestimationSize: f32,
    extraPrimitiveOverestimationSizeGranularity: f32,
    primitiveUnderestimation: Bool32,
    conservativePointAndLineRasterization: Bool32,
    degenerateTrianglesRasterized: Bool32,
    degenerateLinesRasterized: Bool32,
    fullyCoveredFragmentShaderInputVariable: Bool32,
    conservativeRasterizationPostDepthCoverage: Bool32,
};

pub const PipelineRasterizationConservativeStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: PipelineRasterizationConservativeStateCreateFlagsEXT = 0,
    conservativeRasterizationMode: ConservativeRasterizationModeEXT,
    extraPrimitiveOverestimationSize: f32,
};


pub const EXT_depth_clip_enable = 1;
pub const EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1;
pub const EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = c"VK_EXT_depth_clip_enable";

pub const PipelineRasterizationDepthClipStateCreateFlagsEXT = Flags;

pub const PhysicalDeviceDepthClipEnableFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
    pNext: ?*c_void = null,
    depthClipEnable: Bool32,
};

pub const PipelineRasterizationDepthClipStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: PipelineRasterizationDepthClipStateCreateFlagsEXT = 0,
    depthClipEnable: Bool32,
};


pub const EXT_swapchain_colorspace = 1;
pub const EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 4;
pub const EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = c"VK_EXT_swapchain_colorspace";


pub const EXT_hdr_metadata = 1;
pub const EXT_HDR_METADATA_SPEC_VERSION = 2;
pub const EXT_HDR_METADATA_EXTENSION_NAME = c"VK_EXT_hdr_metadata";

pub const XYColorEXT = extern struct {
    x: f32,
    y: f32,
};

pub const HdrMetadataEXT = extern struct {
    sType: StructureType = .HDR_METADATA_EXT,
    pNext: ?*const c_void = null,
    displayPrimaryRed: XYColorEXT,
    displayPrimaryGreen: XYColorEXT,
    displayPrimaryBlue: XYColorEXT,
    whitePoint: XYColorEXT,
    maxLuminance: f32,
    minLuminance: f32,
    maxContentLightLevel: f32,
    maxFrameAverageLightLevel: f32,
};

pub extern fn vkSetHdrMetadataEXT(
    device: Device,
    swapchainCount: u32,
    pSwapchains: [*]const SwapchainKHR,
    pMetadata: [*]const HdrMetadataEXT,
) void;

pub inline fn SetHdrMetadataEXT(device: Device, swapchains: []const SwapchainKHR, metadata: []const HdrMetadataEXT) void {
    assert(metadata.len >= swapchains.len);
    vkSetHdrMetadataEXT(device, @intCast(u32, swapchains.len), swapchains.ptr, metadata.ptr);
}


pub const EXT_external_memory_dma_buf = 1;
pub const EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1;
pub const EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = c"VK_EXT_external_memory_dma_buf";


pub const EXT_queue_family_foreign = 1;
pub const EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1;
pub const EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = c"VK_EXT_queue_family_foreign";
pub const QUEUE_FAMILY_FOREIGN_EXT = (~u32(0)-2);


pub const EXT_debug_utils = 1;
pub const DebugUtilsMessengerEXT = *@OpaqueType();

pub const EXT_DEBUG_UTILS_SPEC_VERSION = 1;
pub const EXT_DEBUG_UTILS_EXTENSION_NAME = c"VK_EXT_debug_utils";

pub const DebugUtilsMessengerCallbackDataFlagsEXT = Flags;
pub const DebugUtilsMessengerCreateFlagsEXT = Flags;

pub const DebugUtilsMessageSeverityFlagsEXT = Flags;
pub const DebugUtilsMessageSeverityFlagBitsEXT = struct {
    pub const VERBOSE_BIT: DebugUtilsMessageSeverityFlagsEXT = 0x00000001;
    pub const INFO_BIT: DebugUtilsMessageSeverityFlagsEXT = 0x00000010;
    pub const WARNING_BIT: DebugUtilsMessageSeverityFlagsEXT = 0x00000100;
    pub const ERROR_BIT: DebugUtilsMessageSeverityFlagsEXT = 0x00001000;
};

pub const DebugUtilsMessageTypeFlagsEXT = Flags;
pub const DebugUtilsMessageTypeFlagBitsEXT = struct {
    pub const GENERAL_BIT: DebugUtilsMessageTypeFlagsEXT = 0x00000001;
    pub const VALIDATION_BIT: DebugUtilsMessageTypeFlagsEXT = 0x00000002;
    pub const PERFORMANCE_BIT: DebugUtilsMessageTypeFlagsEXT = 0x00000004;
};

pub const DebugUtilsObjectNameInfoEXT = extern struct {
    sType: StructureType = .DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    pNext: ?*const c_void = null,
    objectType: ObjectType,
    objectHandle: u64,
    pObjectName: ?CString = null,
};

pub const DebugUtilsObjectTagInfoEXT = extern struct {
    sType: StructureType = .DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    pNext: ?*const c_void = null,
    objectType: ObjectType,
    objectHandle: u64,
    tagName: u64,
    tagSize: usize,
    pTag: ?*const c_void,
};

pub const DebugUtilsLabelEXT = extern struct {
    sType: StructureType = .DEBUG_UTILS_LABEL_EXT,
    pNext: ?*const c_void = null,
    pLabelName: CString,
    color: [4]f32 = 0,
};

pub const DebugUtilsMessengerCallbackDataEXT = extern struct {
    sType: StructureType = .DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    pNext: ?*const c_void = null,
    flags: DebugUtilsMessengerCallbackDataFlagsEXT = 0,
    pMessageIdName: ?CString = null,
    messageIdNumber: i32 = 0,
    pMessage: CString,
    queueLabelCount: u32 = 0,
    pQueueLabels: [*]const DebugUtilsLabelEXT = undefined,
    cmdBufLabelCount: u32 = 0,
    pCmdBufLabels: [*]const DebugUtilsLabelEXT = undefined,
    objectCount: u32 = 0,
    pObjects: [*]const DebugUtilsObjectNameInfoEXT = undefined,
};

pub const PFN_DebugUtilsMessengerCallbackEXT = extern fn (
    DebugUtilsMessageSeverityFlagsEXT,
    DebugUtilsMessageTypeFlagsEXT,
    ?[*]const DebugUtilsMessengerCallbackDataEXT,
    ?*c_void,
) Bool32;

pub const DebugUtilsMessengerCreateInfoEXT = extern struct {
    sType: StructureType = .DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: DebugUtilsMessengerCreateFlagsEXT = 0,
    messageSeverity: DebugUtilsMessageSeverityFlagsEXT,
    messageType: DebugUtilsMessageTypeFlagsEXT,
    pfnUserCallback: PFN_DebugUtilsMessengerCallbackEXT,
    pUserData: ?*c_void = null,
};

pub extern fn vkSetDebugUtilsObjectNameEXT(
    device: Device,
    pNameInfo: *const DebugUtilsObjectNameInfoEXT,
) Result;

pub extern fn vkSetDebugUtilsObjectTagEXT(
    device: Device,
    pTagInfo: *const DebugUtilsObjectTagInfoEXT,
) Result;

pub extern fn vkQueueBeginDebugUtilsLabelEXT(
    queue: Queue,
    pLabelInfo: *const DebugUtilsLabelEXT,
) void;

pub extern fn vkQueueEndDebugUtilsLabelEXT(queue: Queue) void;

pub extern fn vkQueueInsertDebugUtilsLabelEXT(
    queue: Queue,
    pLabelInfo: *const DebugUtilsLabelEXT,
) void;

pub extern fn vkCmdBeginDebugUtilsLabelEXT(
    commandBuffer: CommandBuffer,
    pLabelInfo: *const DebugUtilsLabelEXT,
) void;

pub extern fn vkCmdEndDebugUtilsLabelEXT(commandBuffer: CommandBuffer) void;

pub extern fn vkCmdInsertDebugUtilsLabelEXT(
    commandBuffer: CommandBuffer,
    pLabelInfo: *const DebugUtilsLabelEXT,
) void;

pub extern fn vkCreateDebugUtilsMessengerEXT(
    instance: Instance,
    pCreateInfo: *const DebugUtilsMessengerCreateInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pMessenger: *DebugUtilsMessengerEXT,
) Result;

pub extern fn vkDestroyDebugUtilsMessengerEXT(
    instance: Instance,
    messenger: DebugUtilsMessengerEXT,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkSubmitDebugUtilsMessageEXT(
    instance: Instance,
    messageSeverity: DebugUtilsMessageSeverityFlagsEXT,
    messageTypes: DebugUtilsMessageTypeFlagsEXT,
    pCallbackData: *const DebugUtilsMessengerCallbackDataEXT,
) void;

pub inline fn SetDebugUtilsObjectNameEXT(device: Device, nameInfo: DebugUtilsObjectNameInfoEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkSetDebugUtilsObjectNameEXT(device, &nameInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn SetDebugUtilsObjectTagEXT(device: Device, tagInfo: DebugUtilsObjectTagInfoEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkSetDebugUtilsObjectTagEXT(device, &tagInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn QueueBeginDebugUtilsLabelEXT(queue: Queue, labelInfo: DebugUtilsLabelEXT) void {
    vkQueueBeginDebugUtilsLabelEXT(queue, &labelInfo);
}

pub const QueueEndDebugUtilsLabelEXT = vkQueueEndDebugUtilsLabelEXT;

pub inline fn QueueInsertDebugUtilsLabelEXT(queue: Queue, labelInfo: DebugUtilsLabelEXT) void {
    vkQueueInsertDebugUtilsLabelEXT(queue, &labelInfo);
}

pub inline fn CmdBeginDebugUtilsLabelEXT(commandBuffer: CommandBuffer, labelInfo: DebugUtilsLabelEXT) void {
    vkCmdBeginDebugUtilsLabelEXT(commandBuffer, &labelInfo);
}

pub const CmdEndDebugUtilsLabelEXT = vkCmdEndDebugUtilsLabelEXT;

pub inline fn CmdInsertDebugUtilsLabelEXT(commandBuffer: CommandBuffer, labelInfo: DebugUtilsLabelEXT) void {
    vkCmdInsertDebugUtilsLabelEXT(commandBuffer, &labelInfo);
}

pub inline fn CreateDebugUtilsMessengerEXT(instance: Instance, createInfo: DebugUtilsMessengerCreateInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!DebugUtilsMessengerEXT {
    var out_messenger: DebugUtilsMessengerEXT = undefined;
    const result = vkCreateDebugUtilsMessengerEXT(instance, &createInfo, pAllocator, &out_messenger);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_messenger;
}

pub const DestroyDebugUtilsMessengerEXT = vkDestroyDebugUtilsMessengerEXT;

pub inline fn SubmitDebugUtilsMessageEXT(instance: Instance, messageSeverity: DebugUtilsMessageSeverityFlagsEXT, messageTypes: DebugUtilsMessageTypeFlagsEXT, callbackData: DebugUtilsMessengerCallbackDataEXT) void {
    vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, &callbackData);
}


pub const EXT_sampler_filter_minmax = 1;
pub const EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2;
pub const EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = c"VK_EXT_sampler_filter_minmax";

pub const SamplerReductionModeEXT = SamplerReductionMode;

pub const SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
pub const PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;


pub const AMD_gpu_shader_int16 = 1;
pub const AMD_GPU_SHADER_INT16_SPEC_VERSION = 2;
pub const AMD_GPU_SHADER_INT16_EXTENSION_NAME = c"VK_AMD_gpu_shader_int16";


pub const AMD_mixed_attachment_samples = 1;
pub const AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1;
pub const AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = c"VK_AMD_mixed_attachment_samples";


pub const AMD_shader_fragment_mask = 1;
pub const AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1;
pub const AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = c"VK_AMD_shader_fragment_mask";


pub const EXT_inline_uniform_block = 1;
pub const EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1;
pub const EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = c"VK_EXT_inline_uniform_block";

pub const PhysicalDeviceInlineUniformBlockFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
    pNext: ?*c_void = null,
    inlineUniformBlock: Bool32,
    descriptorBindingInlineUniformBlockUpdateAfterBind: Bool32,
};

pub const PhysicalDeviceInlineUniformBlockPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    maxInlineUniformBlockSize: u32,
    maxPerStageDescriptorInlineUniformBlocks: u32,
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
    maxDescriptorSetInlineUniformBlocks: u32,
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
};

pub const WriteDescriptorSetInlineUniformBlockEXT = extern struct {
    sType: StructureType = .WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
    pNext: ?*const c_void = null,
    dataSize: u32,
    pData: ?*const c_void,
};

pub const DescriptorPoolInlineUniformBlockCreateInfoEXT = extern struct {
    sType: StructureType = .DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    maxInlineUniformBlockBindings: u32,
};


pub const EXT_shader_stencil_export = 1;
pub const EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1;
pub const EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = c"VK_EXT_shader_stencil_export";


pub const EXT_sample_locations = 1;
pub const EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1;
pub const EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = c"VK_EXT_sample_locations";

pub const SampleLocationEXT = extern struct {
    x: f32,
    y: f32,
};

pub const SampleLocationsInfoEXT = extern struct {
    sType: StructureType = .SAMPLE_LOCATIONS_INFO_EXT,
    pNext: ?*const c_void = null,
    sampleLocationsPerPixel: SampleCountFlags = 0,
    sampleLocationGridSize: Extent2D,
    sampleLocationsCount: u32 = 0,
    pSampleLocations: [*]const SampleLocationEXT = undefined,
};

pub const AttachmentSampleLocationsEXT = extern struct {
    attachmentIndex: u32,
    sampleLocationsInfo: SampleLocationsInfoEXT,
};

pub const SubpassSampleLocationsEXT = extern struct {
    subpassIndex: u32,
    sampleLocationsInfo: SampleLocationsInfoEXT,
};

pub const RenderPassSampleLocationsBeginInfoEXT = extern struct {
    sType: StructureType = .RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    pNext: ?*const c_void = null,
    attachmentInitialSampleLocationsCount: u32 = 0,
    pAttachmentInitialSampleLocations: [*]const AttachmentSampleLocationsEXT = undefined,
    postSubpassSampleLocationsCount: u32 = 0,
    pPostSubpassSampleLocations: [*]const SubpassSampleLocationsEXT = undefined,
};

pub const PipelineSampleLocationsStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    sampleLocationsEnable: Bool32,
    sampleLocationsInfo: SampleLocationsInfoEXT,
};

pub const PhysicalDeviceSampleLocationsPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    sampleLocationSampleCounts: SampleCountFlags,
    maxSampleLocationGridSize: Extent2D,
    sampleLocationCoordinateRange: [2]f32,
    sampleLocationSubPixelBits: u32,
    variableSampleLocations: Bool32,
};

pub const MultisamplePropertiesEXT = extern struct {
    sType: StructureType = .MULTISAMPLE_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    maxSampleLocationGridSize: Extent2D,
};

pub extern fn vkCmdSetSampleLocationsEXT(
    commandBuffer: CommandBuffer,
    pSampleLocationsInfo: *const SampleLocationsInfoEXT,
) void;

pub extern fn vkGetPhysicalDeviceMultisamplePropertiesEXT(
    physicalDevice: PhysicalDevice,
    samples: SampleCountFlags,
    pMultisampleProperties: *MultisamplePropertiesEXT,
) void;

pub inline fn CmdSetSampleLocationsEXT(commandBuffer: CommandBuffer, sampleLocationsInfo: SampleLocationsInfoEXT) void {
    vkCmdSetSampleLocationsEXT(commandBuffer, &sampleLocationsInfo);
}

pub inline fn GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice: PhysicalDevice, samples: SampleCountFlags) MultisamplePropertiesEXT {
    var out_multisampleProperties: MultisamplePropertiesEXT = undefined;
    vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, &out_multisampleProperties);
    return out_multisampleProperties;
}


pub const EXT_blend_operation_advanced = 1;
pub const EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2;
pub const EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = c"VK_EXT_blend_operation_advanced";

pub const BlendOverlapEXT = extern enum {
    UNCORRELATED = 0,
    DISJOINT = 1,
    CONJOINT = 2,
};

pub const PhysicalDeviceBlendOperationAdvancedFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    pNext: ?*c_void = null,
    advancedBlendCoherentOperations: Bool32,
};

pub const PhysicalDeviceBlendOperationAdvancedPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    advancedBlendMaxColorAttachments: u32,
    advancedBlendIndependentBlend: Bool32,
    advancedBlendNonPremultipliedSrcColor: Bool32,
    advancedBlendNonPremultipliedDstColor: Bool32,
    advancedBlendCorrelatedOverlap: Bool32,
    advancedBlendAllOperations: Bool32,
};

pub const PipelineColorBlendAdvancedStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    srcPremultiplied: Bool32,
    dstPremultiplied: Bool32,
    blendOverlap: BlendOverlapEXT,
};


pub const NV_fragment_coverage_to_color = 1;
pub const NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1;
pub const NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = c"VK_NV_fragment_coverage_to_color";

pub const PipelineCoverageToColorStateCreateFlagsNV = Flags;

pub const PipelineCoverageToColorStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    flags: PipelineCoverageToColorStateCreateFlagsNV = 0,
    coverageToColorEnable: Bool32,
    coverageToColorLocation: u32 = 0,
};


pub const NV_framebuffer_mixed_samples = 1;
pub const NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1;
pub const NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = c"VK_NV_framebuffer_mixed_samples";

pub const CoverageModulationModeNV = extern enum {
    NONE = 0,
    RGB = 1,
    ALPHA = 2,
    RGBA = 3,
};

pub const PipelineCoverageModulationStateCreateFlagsNV = Flags;

pub const PipelineCoverageModulationStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    flags: PipelineCoverageModulationStateCreateFlagsNV = 0,
    coverageModulationMode: CoverageModulationModeNV,
    coverageModulationTableEnable: Bool32,
    coverageModulationTableCount: u32 = 0,
    pCoverageModulationTable: ?[*]const f32 = null,
};


pub const NV_fill_rectangle = 1;
pub const NV_FILL_RECTANGLE_SPEC_VERSION = 1;
pub const NV_FILL_RECTANGLE_EXTENSION_NAME = c"VK_NV_fill_rectangle";


pub const NV_shader_sm_builtins = 1;
pub const NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1;
pub const NV_SHADER_SM_BUILTINS_EXTENSION_NAME = c"VK_NV_shader_sm_builtins";

pub const PhysicalDeviceShaderSMBuiltinsPropertiesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
    pNext: ?*c_void = null,
    shaderSMCount: u32,
    shaderWarpsPerSM: u32,
};

pub const PhysicalDeviceShaderSMBuiltinsFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
    pNext: ?*c_void = null,
    shaderSMBuiltins: Bool32,
};


pub const EXT_post_depth_coverage = 1;
pub const EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1;
pub const EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = c"VK_EXT_post_depth_coverage";


pub const EXT_image_drm_format_modifier = 1;
pub const EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 1;
pub const EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = c"VK_EXT_image_drm_format_modifier";

pub const DrmFormatModifierPropertiesEXT = extern struct {
    drmFormatModifier: u64,
    drmFormatModifierPlaneCount: u32,
    drmFormatModifierTilingFeatures: FormatFeatureFlags,
};

pub const DrmFormatModifierPropertiesListEXT = extern struct {
    sType: StructureType = .DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
    pNext: ?*c_void = null,
    drmFormatModifierCount: u32 = 0,
    pDrmFormatModifierProperties: [*]DrmFormatModifierPropertiesEXT = undefined,
};

pub const PhysicalDeviceImageDrmFormatModifierInfoEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
    pNext: ?*const c_void = null,
    drmFormatModifier: u64,
    sharingMode: SharingMode,
    queueFamilyIndexCount: u32 = 0,
    pQueueFamilyIndices: [*]const u32 = undefined,
};

pub const ImageDrmFormatModifierListCreateInfoEXT = extern struct {
    sType: StructureType = .IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    drmFormatModifierCount: u32,
    pDrmFormatModifiers: [*]const u64,
};

pub const ImageDrmFormatModifierExplicitCreateInfoEXT = extern struct {
    sType: StructureType = .IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    drmFormatModifier: u64,
    drmFormatModifierPlaneCount: u32,
    pPlaneLayouts: [*]const SubresourceLayout,
};

pub const ImageDrmFormatModifierPropertiesEXT = extern struct {
    sType: StructureType = .IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    drmFormatModifier: u64,
};

pub extern fn vkGetImageDrmFormatModifierPropertiesEXT(
    device: Device,
    image: Image,
    pProperties: *ImageDrmFormatModifierPropertiesEXT,
) Result;

pub inline fn GetImageDrmFormatModifierPropertiesEXT(device: Device, image: Image) error{VK_UNDOCUMENTED_ERROR}!ImageDrmFormatModifierPropertiesEXT {
    var out_properties: ImageDrmFormatModifierPropertiesEXT = undefined;
    const result = vkGetImageDrmFormatModifierPropertiesEXT(device, image, &out_properties);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    return out_properties;
}


pub const EXT_validation_cache = 1;
pub const ValidationCacheEXT = *@OpaqueType();

pub const EXT_VALIDATION_CACHE_SPEC_VERSION = 1;
pub const EXT_VALIDATION_CACHE_EXTENSION_NAME = c"VK_EXT_validation_cache";

pub const ValidationCacheHeaderVersionEXT = extern enum {
    ONE = 1,
};

pub const ValidationCacheCreateFlagsEXT = Flags;

pub const ValidationCacheCreateInfoEXT = extern struct {
    sType: StructureType = .VALIDATION_CACHE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: ValidationCacheCreateFlagsEXT = 0,
    initialDataSize: usize = 0,
    pInitialData: ?*const c_void = undefined,
};

pub const ShaderModuleValidationCacheCreateInfoEXT = extern struct {
    sType: StructureType = .SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    validationCache: ValidationCacheEXT,
};

pub extern fn vkCreateValidationCacheEXT(
    device: Device,
    pCreateInfo: *const ValidationCacheCreateInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pValidationCache: *ValidationCacheEXT,
) Result;

pub extern fn vkDestroyValidationCacheEXT(
    device: Device,
    validationCache: ?ValidationCacheEXT,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkMergeValidationCachesEXT(
    device: Device,
    dstCache: ValidationCacheEXT,
    srcCacheCount: u32,
    pSrcCaches: [*]const ValidationCacheEXT,
) Result;

pub extern fn vkGetValidationCacheDataEXT(
    device: Device,
    validationCache: ValidationCacheEXT,
    pDataSize: *usize,
    pData: ?*c_void,
) Result;

pub inline fn CreateValidationCacheEXT(device: Device, createInfo: ValidationCacheCreateInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!ValidationCacheEXT {
    var out_validationCache: ValidationCacheEXT = undefined;
    const result = vkCreateValidationCacheEXT(device, &createInfo, pAllocator, &out_validationCache);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_validationCache;
}

pub const DestroyValidationCacheEXT = vkDestroyValidationCacheEXT;

pub inline fn MergeValidationCachesEXT(device: Device, dstCache: ValidationCacheEXT, srcCaches: []const ValidationCacheEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkMergeValidationCachesEXT(device, dstCache, @intCast(u32, srcCaches.len), srcCaches.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const GetValidationCacheDataEXTResult = struct {
    result: Result,
    data: []u8,
};
pub inline fn GetValidationCacheDataEXT(device: Device, validationCache: ValidationCacheEXT, data: []u8) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetValidationCacheDataEXTResult {
    var returnValues: GetValidationCacheDataEXTResult = undefined;
    var dataSize: usize = @intCast(usize, data.len);
    const result = vkGetValidationCacheDataEXT(device, validationCache, &dataSize, data.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.data = data[0..dataSize];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetValidationCacheDataCountEXT(device: Device, validationCache: ValidationCacheEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!usize {
    var out_dataSize: usize = undefined;
    const result = vkGetValidationCacheDataEXT(device, validationCache, &out_dataSize, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_dataSize;
}


pub const EXT_descriptor_indexing = 1;
pub const EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2;
pub const EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = c"VK_EXT_descriptor_indexing";

pub const DescriptorBindingFlagBitsEXT = DescriptorBindingFlagBits;
pub const DescriptorBindingFlagsEXT = DescriptorBindingFlags;

pub const DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
pub const PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
pub const PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
pub const DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
pub const DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;


pub const EXT_shader_viewport_index_layer = 1;
pub const EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1;
pub const EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = c"VK_EXT_shader_viewport_index_layer";


pub const NV_shading_rate_image = 1;
pub const NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3;
pub const NV_SHADING_RATE_IMAGE_EXTENSION_NAME = c"VK_NV_shading_rate_image";

pub const ShadingRatePaletteEntryNV = extern enum {
    NO_INVOCATIONS = 0,
    T_16_INVOCATIONS_PER_PIXEL = 1,
    T_8_INVOCATIONS_PER_PIXEL = 2,
    T_4_INVOCATIONS_PER_PIXEL = 3,
    T_2_INVOCATIONS_PER_PIXEL = 4,
    T_1_INVOCATION_PER_PIXEL = 5,
    T_1_INVOCATION_PER_2X1_PIXELS = 6,
    T_1_INVOCATION_PER_1X2_PIXELS = 7,
    T_1_INVOCATION_PER_2X2_PIXELS = 8,
    T_1_INVOCATION_PER_4X2_PIXELS = 9,
    T_1_INVOCATION_PER_2X4_PIXELS = 10,
    T_1_INVOCATION_PER_4X4_PIXELS = 11,
};

pub const CoarseSampleOrderTypeNV = extern enum {
    DEFAULT = 0,
    CUSTOM = 1,
    PIXEL_MAJOR = 2,
    SAMPLE_MAJOR = 3,
};

pub const ShadingRatePaletteNV = extern struct {
    shadingRatePaletteEntryCount: u32,
    pShadingRatePaletteEntries: [*]const ShadingRatePaletteEntryNV,
};

pub const PipelineViewportShadingRateImageStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    shadingRateImageEnable: Bool32,
    viewportCount: u32 = 0,
    pShadingRatePalettes: ?[*]const ShadingRatePaletteNV = null,
};

pub const PhysicalDeviceShadingRateImageFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
    pNext: ?*c_void = null,
    shadingRateImage: Bool32,
    shadingRateCoarseSampleOrder: Bool32,
};

pub const PhysicalDeviceShadingRateImagePropertiesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
    pNext: ?*c_void = null,
    shadingRateTexelSize: Extent2D,
    shadingRatePaletteSize: u32,
    shadingRateMaxCoarseSamples: u32,
};

pub const CoarseSampleLocationNV = extern struct {
    pixelX: u32,
    pixelY: u32,
    sample: u32,
};

pub const CoarseSampleOrderCustomNV = extern struct {
    shadingRate: ShadingRatePaletteEntryNV,
    sampleCount: u32,
    sampleLocationCount: u32,
    pSampleLocations: [*]const CoarseSampleLocationNV,
};

pub const PipelineViewportCoarseSampleOrderStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    sampleOrderType: CoarseSampleOrderTypeNV,
    customSampleOrderCount: u32 = 0,
    pCustomSampleOrders: [*]const CoarseSampleOrderCustomNV = undefined,
};

pub extern fn vkCmdBindShadingRateImageNV(
    commandBuffer: CommandBuffer,
    imageView: ?ImageView,
    imageLayout: ImageLayout,
) void;

pub extern fn vkCmdSetViewportShadingRatePaletteNV(
    commandBuffer: CommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    pShadingRatePalettes: [*]const ShadingRatePaletteNV,
) void;

pub extern fn vkCmdSetCoarseSampleOrderNV(
    commandBuffer: CommandBuffer,
    sampleOrderType: CoarseSampleOrderTypeNV,
    customSampleOrderCount: u32,
    pCustomSampleOrders: [*]const CoarseSampleOrderCustomNV,
) void;

pub const CmdBindShadingRateImageNV = vkCmdBindShadingRateImageNV;

pub inline fn CmdSetViewportShadingRatePaletteNV(commandBuffer: CommandBuffer, firstViewport: u32, shadingRatePalettes: []const ShadingRatePaletteNV) void {
    vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, @intCast(u32, shadingRatePalettes.len), shadingRatePalettes.ptr);
}

pub inline fn CmdSetCoarseSampleOrderNV(commandBuffer: CommandBuffer, sampleOrderType: CoarseSampleOrderTypeNV, customSampleOrders: []const CoarseSampleOrderCustomNV) void {
    vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, @intCast(u32, customSampleOrders.len), customSampleOrders.ptr);
}


pub const NV_ray_tracing = 1;
pub const AccelerationStructureNV = *@OpaqueType();

pub const NV_RAY_TRACING_SPEC_VERSION = 3;
pub const NV_RAY_TRACING_EXTENSION_NAME = c"VK_NV_ray_tracing";
pub const SHADER_UNUSED_NV = (~u32(0));

pub const AccelerationStructureTypeNV = extern enum {
    TOP_LEVEL = 0,
    BOTTOM_LEVEL = 1,
};

pub const RayTracingShaderGroupTypeNV = extern enum {
    GENERAL = 0,
    TRIANGLES_HIT_GROUP = 1,
    PROCEDURAL_HIT_GROUP = 2,
};

pub const GeometryTypeNV = extern enum {
    TRIANGLES = 0,
    AABBS = 1,
};

pub const CopyAccelerationStructureModeNV = extern enum {
    CLONE = 0,
    COMPACT = 1,
};

pub const AccelerationStructureMemoryRequirementsTypeNV = extern enum {
    OBJECT = 0,
    BUILD_SCRATCH = 1,
    UPDATE_SCRATCH = 2,
};

pub const GeometryFlagsNV = Flags;
pub const GeometryFlagBitsNV = struct {
    pub const OPAQUE_BIT: GeometryFlagsNV = 0x00000001;
    pub const NO_DUPLICATE_ANY_HIT_INVOCATION_BIT: GeometryFlagsNV = 0x00000002;
};

pub const GeometryInstanceFlagsNV = Flags;
pub const GeometryInstanceFlagBitsNV = struct {
    pub const TRIANGLE_CULL_DISABLE_BIT: GeometryInstanceFlagsNV = 0x00000001;
    pub const TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT: GeometryInstanceFlagsNV = 0x00000002;
    pub const FORCE_OPAQUE_BIT: GeometryInstanceFlagsNV = 0x00000004;
    pub const FORCE_NO_OPAQUE_BIT: GeometryInstanceFlagsNV = 0x00000008;
};

pub const BuildAccelerationStructureFlagsNV = Flags;
pub const BuildAccelerationStructureFlagBitsNV = struct {
    pub const ALLOW_UPDATE_BIT: BuildAccelerationStructureFlagsNV = 0x00000001;
    pub const ALLOW_COMPACTION_BIT: BuildAccelerationStructureFlagsNV = 0x00000002;
    pub const PREFER_FAST_TRACE_BIT: BuildAccelerationStructureFlagsNV = 0x00000004;
    pub const PREFER_FAST_BUILD_BIT: BuildAccelerationStructureFlagsNV = 0x00000008;
    pub const LOW_MEMORY_BIT: BuildAccelerationStructureFlagsNV = 0x00000010;
};

pub const RayTracingShaderGroupCreateInfoNV = extern struct {
    sType: StructureType = .RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    inType: RayTracingShaderGroupTypeNV,
    generalShader: u32,
    closestHitShader: u32,
    anyHitShader: u32,
    intersectionShader: u32,
};

pub const RayTracingPipelineCreateInfoNV = extern struct {
    sType: StructureType = .RAY_TRACING_PIPELINE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    flags: PipelineCreateFlags = 0,
    stageCount: u32,
    pStages: [*]const PipelineShaderStageCreateInfo,
    groupCount: u32,
    pGroups: [*]const RayTracingShaderGroupCreateInfoNV,
    maxRecursionDepth: u32,
    layout: PipelineLayout,
    basePipelineHandle: ?Pipeline = null,
    basePipelineIndex: i32,
};

pub const GeometryTrianglesNV = extern struct {
    sType: StructureType = .GEOMETRY_TRIANGLES_NV,
    pNext: ?*const c_void = null,
    vertexData: ?Buffer = null,
    vertexOffset: DeviceSize,
    vertexCount: u32,
    vertexStride: DeviceSize,
    vertexFormat: Format,
    indexData: ?Buffer = null,
    indexOffset: DeviceSize,
    indexCount: u32,
    indexType: IndexType,
    transformData: ?Buffer = null,
    transformOffset: DeviceSize,
};

pub const GeometryAABBNV = extern struct {
    sType: StructureType = .GEOMETRY_AABB_NV,
    pNext: ?*const c_void = null,
    aabbData: ?Buffer = null,
    numAABBs: u32,
    stride: u32,
    offset: DeviceSize,
};

pub const GeometryDataNV = extern struct {
    triangles: GeometryTrianglesNV,
    aabbs: GeometryAABBNV,
};

pub const GeometryNV = extern struct {
    sType: StructureType = .GEOMETRY_NV,
    pNext: ?*const c_void = null,
    geometryType: GeometryTypeNV,
    geometry: GeometryDataNV,
    flags: GeometryFlagsNV = 0,
};

pub const AccelerationStructureInfoNV = extern struct {
    sType: StructureType = .ACCELERATION_STRUCTURE_INFO_NV,
    pNext: ?*const c_void = null,
    inType: AccelerationStructureTypeNV,
    flags: BuildAccelerationStructureFlagsNV = 0,
    instanceCount: u32 = 0,
    geometryCount: u32 = 0,
    pGeometries: [*]const GeometryNV = undefined,
};

pub const AccelerationStructureCreateInfoNV = extern struct {
    sType: StructureType = .ACCELERATION_STRUCTURE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    compactedSize: DeviceSize,
    info: AccelerationStructureInfoNV,
};

pub const BindAccelerationStructureMemoryInfoNV = extern struct {
    sType: StructureType = .BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
    pNext: ?*const c_void = null,
    accelerationStructure: AccelerationStructureNV,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
    deviceIndexCount: u32 = 0,
    pDeviceIndices: [*]const u32 = undefined,
};

pub const WriteDescriptorSetAccelerationStructureNV = extern struct {
    sType: StructureType = .WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
    pNext: ?*const c_void = null,
    accelerationStructureCount: u32,
    pAccelerationStructures: [*]const AccelerationStructureNV,
};

pub const AccelerationStructureMemoryRequirementsInfoNV = extern struct {
    sType: StructureType = .ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
    pNext: ?*const c_void = null,
    inType: AccelerationStructureMemoryRequirementsTypeNV,
    accelerationStructure: AccelerationStructureNV,
};

pub const PhysicalDeviceRayTracingPropertiesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
    pNext: ?*c_void = null,
    shaderGroupHandleSize: u32,
    maxRecursionDepth: u32,
    maxShaderGroupStride: u32,
    shaderGroupBaseAlignment: u32,
    maxGeometryCount: u64,
    maxInstanceCount: u64,
    maxTriangleCount: u64,
    maxDescriptorSetAccelerationStructures: u32,
};

pub extern fn vkCreateAccelerationStructureNV(
    device: Device,
    pCreateInfo: *const AccelerationStructureCreateInfoNV,
    pAllocator: ?*const AllocationCallbacks,
    pAccelerationStructure: *AccelerationStructureNV,
) Result;

pub extern fn vkDestroyAccelerationStructureNV(
    device: Device,
    accelerationStructure: AccelerationStructureNV,
    pAllocator: ?*const AllocationCallbacks,
) void;

pub extern fn vkGetAccelerationStructureMemoryRequirementsNV(
    device: Device,
    pInfo: *const AccelerationStructureMemoryRequirementsInfoNV,
    pMemoryRequirements: *MemoryRequirements2KHR,
) void;

pub extern fn vkBindAccelerationStructureMemoryNV(
    device: Device,
    bindInfoCount: u32,
    pBindInfos: [*]const BindAccelerationStructureMemoryInfoNV,
) Result;

pub extern fn vkCmdBuildAccelerationStructureNV(
    commandBuffer: CommandBuffer,
    pInfo: *const AccelerationStructureInfoNV,
    instanceData: ?Buffer,
    instanceOffset: DeviceSize,
    update: Bool32,
    dst: AccelerationStructureNV,
    src: ?AccelerationStructureNV,
    scratch: Buffer,
    scratchOffset: DeviceSize,
) void;

pub extern fn vkCmdCopyAccelerationStructureNV(
    commandBuffer: CommandBuffer,
    dst: AccelerationStructureNV,
    src: AccelerationStructureNV,
    mode: CopyAccelerationStructureModeNV,
) void;

pub extern fn vkCmdTraceRaysNV(
    commandBuffer: CommandBuffer,
    raygenShaderBindingTableBuffer: Buffer,
    raygenShaderBindingOffset: DeviceSize,
    missShaderBindingTableBuffer: ?Buffer,
    missShaderBindingOffset: DeviceSize,
    missShaderBindingStride: DeviceSize,
    hitShaderBindingTableBuffer: ?Buffer,
    hitShaderBindingOffset: DeviceSize,
    hitShaderBindingStride: DeviceSize,
    callableShaderBindingTableBuffer: ?Buffer,
    callableShaderBindingOffset: DeviceSize,
    callableShaderBindingStride: DeviceSize,
    width: u32,
    height: u32,
    depth: u32,
) void;

pub extern fn vkCreateRayTracingPipelinesNV(
    device: Device,
    pipelineCache: ?PipelineCache,
    createInfoCount: u32,
    pCreateInfos: [*]const RayTracingPipelineCreateInfoNV,
    pAllocator: ?*const AllocationCallbacks,
    pPipelines: [*]Pipeline,
) Result;

pub extern fn vkGetRayTracingShaderGroupHandlesNV(
    device: Device,
    pipeline: Pipeline,
    firstGroup: u32,
    groupCount: u32,
    dataSize: usize,
    pData: ?*c_void,
) Result;

pub extern fn vkGetAccelerationStructureHandleNV(
    device: Device,
    accelerationStructure: AccelerationStructureNV,
    dataSize: usize,
    pData: ?*c_void,
) Result;

pub extern fn vkCmdWriteAccelerationStructuresPropertiesNV(
    commandBuffer: CommandBuffer,
    accelerationStructureCount: u32,
    pAccelerationStructures: [*]const AccelerationStructureNV,
    queryType: QueryType,
    queryPool: QueryPool,
    firstQuery: u32,
) void;

pub extern fn vkCompileDeferredNV(
    device: Device,
    pipeline: Pipeline,
    shader: u32,
) Result;

pub inline fn CreateAccelerationStructureNV(device: Device, createInfo: AccelerationStructureCreateInfoNV, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!AccelerationStructureNV {
    var out_accelerationStructure: AccelerationStructureNV = undefined;
    const result = vkCreateAccelerationStructureNV(device, &createInfo, pAllocator, &out_accelerationStructure);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_accelerationStructure;
}

pub const DestroyAccelerationStructureNV = vkDestroyAccelerationStructureNV;

pub inline fn GetAccelerationStructureMemoryRequirementsNV(device: Device, info: AccelerationStructureMemoryRequirementsInfoNV) MemoryRequirements2KHR {
    var out_memoryRequirements: MemoryRequirements2KHR = undefined;
    vkGetAccelerationStructureMemoryRequirementsNV(device, &info, &out_memoryRequirements);
    return out_memoryRequirements;
}

pub inline fn BindAccelerationStructureMemoryNV(device: Device, bindInfos: []const BindAccelerationStructureMemoryInfoNV) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkBindAccelerationStructureMemoryNV(device, @intCast(u32, bindInfos.len), bindInfos.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CmdBuildAccelerationStructureNV(commandBuffer: CommandBuffer, info: AccelerationStructureInfoNV, instanceData: ?Buffer, instanceOffset: DeviceSize, update: Bool32, dst: AccelerationStructureNV, src: ?AccelerationStructureNV, scratch: Buffer, scratchOffset: DeviceSize) void {
    vkCmdBuildAccelerationStructureNV(commandBuffer, &info, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}

pub const CmdCopyAccelerationStructureNV = vkCmdCopyAccelerationStructureNV;
pub const CmdTraceRaysNV = vkCmdTraceRaysNV;

pub inline fn CreateRayTracingPipelinesNV(device: Device, pipelineCache: ?PipelineCache, createInfos: []const RayTracingPipelineCreateInfoNV, pAllocator: ?*const AllocationCallbacks, pipelines: []Pipeline) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_INVALID_SHADER_NV,VK_UNDOCUMENTED_ERROR}!void {
    assert(pipelines.len >= createInfos.len);
    const result = vkCreateRayTracingPipelinesNV(device, pipelineCache, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, pipelines.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            .ERROR_INVALID_SHADER_NV => error.VK_INVALID_SHADER_NV,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetRayTracingShaderGroupHandlesNV(device: Device, pipeline: Pipeline, firstGroup: u32, groupCount: u32, data: []u8) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, @intCast(usize, data.len), data.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetAccelerationStructureHandleNV(device: Device, accelerationStructure: AccelerationStructureNV, data: []u8) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkGetAccelerationStructureHandleNV(device, accelerationStructure, @intCast(usize, data.len), data.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CmdWriteAccelerationStructuresPropertiesNV(commandBuffer: CommandBuffer, accelerationStructures: []const AccelerationStructureNV, queryType: QueryType, queryPool: QueryPool, firstQuery: u32) void {
    vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, @intCast(u32, accelerationStructures.len), accelerationStructures.ptr, queryType, queryPool, firstQuery);
}

pub inline fn CompileDeferredNV(device: Device, pipeline: Pipeline, shader: u32) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkCompileDeferredNV(device, pipeline, shader);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}


pub const NV_representative_fragment_test = 1;
pub const NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2;
pub const NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = c"VK_NV_representative_fragment_test";

pub const PhysicalDeviceRepresentativeFragmentTestFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
    pNext: ?*c_void = null,
    representativeFragmentTest: Bool32,
};

pub const PipelineRepresentativeFragmentTestStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    representativeFragmentTestEnable: Bool32,
};


pub const EXT_filter_cubic = 1;
pub const EXT_FILTER_CUBIC_SPEC_VERSION = 3;
pub const EXT_FILTER_CUBIC_EXTENSION_NAME = c"VK_EXT_filter_cubic";

pub const PhysicalDeviceImageViewImageFormatInfoEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
    pNext: ?*c_void = null,
    imageViewType: ImageViewType,
};

pub const FilterCubicImageViewImageFormatPropertiesEXT = extern struct {
    sType: StructureType = .FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    filterCubic: Bool32,
    filterCubicMinmax: Bool32,
};


pub const EXT_global_priority = 1;
pub const EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2;
pub const EXT_GLOBAL_PRIORITY_EXTENSION_NAME = c"VK_EXT_global_priority";

pub const QueueGlobalPriorityEXT = extern enum {
    LOW = 128,
    MEDIUM = 256,
    HIGH = 512,
    REALTIME = 1024,
};

pub const DeviceQueueGlobalPriorityCreateInfoEXT = extern struct {
    sType: StructureType = .DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    globalPriority: QueueGlobalPriorityEXT,
};


pub const EXT_external_memory_host = 1;
pub const EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1;
pub const EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = c"VK_EXT_external_memory_host";

pub const ImportMemoryHostPointerInfoEXT = extern struct {
    sType: StructureType = .IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    pNext: ?*const c_void = null,
    handleType: ExternalMemoryHandleTypeFlags,
    pHostPointer: ?*c_void,
};

pub const MemoryHostPointerPropertiesEXT = extern struct {
    sType: StructureType = .MEMORY_HOST_POINTER_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    memoryTypeBits: u32,
};

pub const PhysicalDeviceExternalMemoryHostPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    minImportedHostPointerAlignment: DeviceSize,
};

pub extern fn vkGetMemoryHostPointerPropertiesEXT(
    device: Device,
    handleType: ExternalMemoryHandleTypeFlags,
    pHostPointer: ?*const c_void,
    pMemoryHostPointerProperties: *MemoryHostPointerPropertiesEXT,
) Result;

pub inline fn GetMemoryHostPointerPropertiesEXT(device: Device, handleType: ExternalMemoryHandleTypeFlags, pHostPointer: ?*const c_void) error{VK_INVALID_EXTERNAL_HANDLE,VK_UNDOCUMENTED_ERROR}!MemoryHostPointerPropertiesEXT {
    var out_memoryHostPointerProperties: MemoryHostPointerPropertiesEXT = undefined;
    const result = vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, &out_memoryHostPointerProperties);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_INVALID_EXTERNAL_HANDLE => error.VK_INVALID_EXTERNAL_HANDLE,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_memoryHostPointerProperties;
}


pub const AMD_buffer_marker = 1;
pub const AMD_BUFFER_MARKER_SPEC_VERSION = 1;
pub const AMD_BUFFER_MARKER_EXTENSION_NAME = c"VK_AMD_buffer_marker";

pub extern fn vkCmdWriteBufferMarkerAMD(
    commandBuffer: CommandBuffer,
    pipelineStage: PipelineStageFlags,
    dstBuffer: Buffer,
    dstOffset: DeviceSize,
    marker: u32,
) void;

pub const CmdWriteBufferMarkerAMD = vkCmdWriteBufferMarkerAMD;


pub const AMD_pipeline_compiler_control = 1;
pub const AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1;
pub const AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = c"VK_AMD_pipeline_compiler_control";

pub const PipelineCompilerControlFlagsAMD = Flags;
pub const PipelineCompilerControlFlagBitsAMD = struct {
};

pub const PipelineCompilerControlCreateInfoAMD = extern struct {
    sType: StructureType = .PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
    pNext: ?*const c_void = null,
    compilerControlFlags: PipelineCompilerControlFlagsAMD = 0,
};


pub const EXT_calibrated_timestamps = 1;
pub const EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 1;
pub const EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = c"VK_EXT_calibrated_timestamps";

pub const TimeDomainEXT = extern enum {
    DEVICE = 0,
    CLOCK_MONOTONIC = 1,
    CLOCK_MONOTONIC_RAW = 2,
    QUERY_PERFORMANCE_COUNTER = 3,
};

pub const CalibratedTimestampInfoEXT = extern struct {
    sType: StructureType = .CALIBRATED_TIMESTAMP_INFO_EXT,
    pNext: ?*const c_void = null,
    timeDomain: TimeDomainEXT,
};

pub extern fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    physicalDevice: PhysicalDevice,
    pTimeDomainCount: *u32,
    pTimeDomains: ?[*]TimeDomainEXT,
) Result;

pub extern fn vkGetCalibratedTimestampsEXT(
    device: Device,
    timestampCount: u32,
    pTimestampInfos: [*]const CalibratedTimestampInfoEXT,
    pTimestamps: [*]u64,
    pMaxDeviation: *u64,
) Result;

pub const GetPhysicalDeviceCalibrateableTimeDomainsEXTResult = struct {
    result: Result,
    timeDomains: []TimeDomainEXT,
};
pub inline fn GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice: PhysicalDevice, timeDomains: []TimeDomainEXT) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceCalibrateableTimeDomainsEXTResult {
    var returnValues: GetPhysicalDeviceCalibrateableTimeDomainsEXTResult = undefined;
    var timeDomainCount: u32 = @intCast(u32, timeDomains.len);
    const result = vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, &timeDomainCount, timeDomains.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.timeDomains = timeDomains[0..timeDomainCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceCalibrateableTimeDomainsCountEXT(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_timeDomainCount: u32 = undefined;
    const result = vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, &out_timeDomainCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_timeDomainCount;
}

pub inline fn GetCalibratedTimestampsEXT(device: Device, timestampInfos: []const CalibratedTimestampInfoEXT, timestamps: []u64) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u64 {
    var out_maxDeviation: u64 = undefined;
    assert(timestamps.len >= timestampInfos.len);
    const result = vkGetCalibratedTimestampsEXT(device, @intCast(u32, timestampInfos.len), timestampInfos.ptr, timestamps.ptr, &out_maxDeviation);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_maxDeviation;
}


pub const AMD_shader_core_properties = 1;
pub const AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2;
pub const AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = c"VK_AMD_shader_core_properties";

pub const PhysicalDeviceShaderCorePropertiesAMD = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    pNext: ?*c_void = null,
    shaderEngineCount: u32,
    shaderArraysPerEngineCount: u32,
    computeUnitsPerShaderArray: u32,
    simdPerComputeUnit: u32,
    wavefrontsPerSimd: u32,
    wavefrontSize: u32,
    sgprsPerSimd: u32,
    minSgprAllocation: u32,
    maxSgprAllocation: u32,
    sgprAllocationGranularity: u32,
    vgprsPerSimd: u32,
    minVgprAllocation: u32,
    maxVgprAllocation: u32,
    vgprAllocationGranularity: u32,
};


pub const AMD_memory_overallocation_behavior = 1;
pub const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1;
pub const AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = c"VK_AMD_memory_overallocation_behavior";

pub const MemoryOverallocationBehaviorAMD = extern enum {
    DEFAULT = 0,
    ALLOWED = 1,
    DISALLOWED = 2,
};

pub const DeviceMemoryOverallocationCreateInfoAMD = extern struct {
    sType: StructureType = .DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
    pNext: ?*const c_void = null,
    overallocationBehavior: MemoryOverallocationBehaviorAMD,
};


pub const EXT_vertex_attribute_divisor = 1;
pub const EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3;
pub const EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = c"VK_EXT_vertex_attribute_divisor";

pub const PhysicalDeviceVertexAttributeDivisorPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    maxVertexAttribDivisor: u32,
};

pub const VertexInputBindingDivisorDescriptionEXT = extern struct {
    binding: u32,
    divisor: u32,
};

pub const PipelineVertexInputDivisorStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    vertexBindingDivisorCount: u32,
    pVertexBindingDivisors: [*]const VertexInputBindingDivisorDescriptionEXT,
};

pub const PhysicalDeviceVertexAttributeDivisorFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
    pNext: ?*c_void = null,
    vertexAttributeInstanceRateDivisor: Bool32,
    vertexAttributeInstanceRateZeroDivisor: Bool32,
};


pub const EXT_pipeline_creation_feedback = 1;
pub const EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1;
pub const EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = c"VK_EXT_pipeline_creation_feedback";

pub const PipelineCreationFeedbackFlagsEXT = Flags;
pub const PipelineCreationFeedbackFlagBitsEXT = struct {
    pub const VALID_BIT: PipelineCreationFeedbackFlagsEXT = 0x00000001;
    pub const APPLICATION_PIPELINE_CACHE_HIT_BIT: PipelineCreationFeedbackFlagsEXT = 0x00000002;
    pub const BASE_PIPELINE_ACCELERATION_BIT: PipelineCreationFeedbackFlagsEXT = 0x00000004;
};

pub const PipelineCreationFeedbackEXT = extern struct {
    flags: PipelineCreationFeedbackFlagsEXT,
    duration: u64,
};

pub const PipelineCreationFeedbackCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    pPipelineCreationFeedback: *PipelineCreationFeedbackEXT,
    pipelineStageCreationFeedbackCount: u32,
    pPipelineStageCreationFeedbacks: [*]PipelineCreationFeedbackEXT,
};


pub const NV_shader_subgroup_partitioned = 1;
pub const NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1;
pub const NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = c"VK_NV_shader_subgroup_partitioned";


pub const NV_compute_shader_derivatives = 1;
pub const NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1;
pub const NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = c"VK_NV_compute_shader_derivatives";

pub const PhysicalDeviceComputeShaderDerivativesFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
    pNext: ?*c_void = null,
    computeDerivativeGroupQuads: Bool32,
    computeDerivativeGroupLinear: Bool32,
};


pub const NV_mesh_shader = 1;
pub const NV_MESH_SHADER_SPEC_VERSION = 1;
pub const NV_MESH_SHADER_EXTENSION_NAME = c"VK_NV_mesh_shader";

pub const PhysicalDeviceMeshShaderFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
    pNext: ?*c_void = null,
    taskShader: Bool32,
    meshShader: Bool32,
};

pub const PhysicalDeviceMeshShaderPropertiesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
    pNext: ?*c_void = null,
    maxDrawMeshTasksCount: u32,
    maxTaskWorkGroupInvocations: u32,
    maxTaskWorkGroupSize: [3]u32,
    maxTaskTotalMemorySize: u32,
    maxTaskOutputCount: u32,
    maxMeshWorkGroupInvocations: u32,
    maxMeshWorkGroupSize: [3]u32,
    maxMeshTotalMemorySize: u32,
    maxMeshOutputVertices: u32,
    maxMeshOutputPrimitives: u32,
    maxMeshMultiviewViewCount: u32,
    meshOutputPerVertexGranularity: u32,
    meshOutputPerPrimitiveGranularity: u32,
};

pub const DrawMeshTasksIndirectCommandNV = extern struct {
    taskCount: u32,
    firstTask: u32,
};

pub extern fn vkCmdDrawMeshTasksNV(
    commandBuffer: CommandBuffer,
    taskCount: u32,
    firstTask: u32,
) void;

pub extern fn vkCmdDrawMeshTasksIndirectNV(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    drawCount: u32,
    stride: u32,
) void;

pub extern fn vkCmdDrawMeshTasksIndirectCountNV(
    commandBuffer: CommandBuffer,
    buffer: Buffer,
    offset: DeviceSize,
    countBuffer: Buffer,
    countBufferOffset: DeviceSize,
    maxDrawCount: u32,
    stride: u32,
) void;

pub const CmdDrawMeshTasksNV = vkCmdDrawMeshTasksNV;
pub const CmdDrawMeshTasksIndirectNV = vkCmdDrawMeshTasksIndirectNV;
pub const CmdDrawMeshTasksIndirectCountNV = vkCmdDrawMeshTasksIndirectCountNV;


pub const NV_fragment_shader_barycentric = 1;
pub const NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1;
pub const NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = c"VK_NV_fragment_shader_barycentric";

pub const PhysicalDeviceFragmentShaderBarycentricFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
    pNext: ?*c_void = null,
    fragmentShaderBarycentric: Bool32,
};


pub const NV_shader_image_footprint = 1;
pub const NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2;
pub const NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = c"VK_NV_shader_image_footprint";

pub const PhysicalDeviceShaderImageFootprintFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
    pNext: ?*c_void = null,
    imageFootprint: Bool32,
};


pub const NV_scissor_exclusive = 1;
pub const NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 1;
pub const NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = c"VK_NV_scissor_exclusive";

pub const PipelineViewportExclusiveScissorStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    exclusiveScissorCount: u32 = 0,
    pExclusiveScissors: ?[*]const Rect2D = null,
};

pub const PhysicalDeviceExclusiveScissorFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
    pNext: ?*c_void = null,
    exclusiveScissor: Bool32,
};

pub extern fn vkCmdSetExclusiveScissorNV(
    commandBuffer: CommandBuffer,
    firstExclusiveScissor: u32,
    exclusiveScissorCount: u32,
    pExclusiveScissors: [*]const Rect2D,
) void;

pub inline fn CmdSetExclusiveScissorNV(commandBuffer: CommandBuffer, firstExclusiveScissor: u32, exclusiveScissors: []const Rect2D) void {
    vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, @intCast(u32, exclusiveScissors.len), exclusiveScissors.ptr);
}


pub const NV_device_diagnostic_checkpoints = 1;
pub const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2;
pub const NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = c"VK_NV_device_diagnostic_checkpoints";

pub const QueueFamilyCheckpointPropertiesNV = extern struct {
    sType: StructureType = .QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
    pNext: ?*c_void = null,
    checkpointExecutionStageMask: PipelineStageFlags,
};

pub const CheckpointDataNV = extern struct {
    sType: StructureType = .CHECKPOINT_DATA_NV,
    pNext: ?*c_void = null,
    stage: PipelineStageFlags,
    pCheckpointMarker: ?*c_void,
};

pub extern fn vkCmdSetCheckpointNV(
    commandBuffer: CommandBuffer,
    pCheckpointMarker: ?*const c_void,
) void;

pub extern fn vkGetQueueCheckpointDataNV(
    queue: Queue,
    pCheckpointDataCount: *u32,
    pCheckpointData: ?[*]CheckpointDataNV,
) void;

pub const CmdSetCheckpointNV = vkCmdSetCheckpointNV;

pub inline fn GetQueueCheckpointDataNV(queue: Queue, checkpointData: []CheckpointDataNV) []CheckpointDataNV {
    var out_checkpointData: []CheckpointDataNV = undefined;
    var checkpointDataCount: u32 = @intCast(u32, checkpointData.len);
    vkGetQueueCheckpointDataNV(queue, &checkpointDataCount, checkpointData.ptr);
    out_checkpointData = checkpointData[0..checkpointDataCount];
    return out_checkpointData;
}
pub inline fn GetQueueCheckpointDataCountNV(queue: Queue) u32 {
    var out_checkpointDataCount: u32 = undefined;
    vkGetQueueCheckpointDataNV(queue, &out_checkpointDataCount, null);
    return out_checkpointDataCount;
}


pub const INTEL_shader_integer_functions2 = 1;
pub const INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1;
pub const INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = c"VK_INTEL_shader_integer_functions2";

pub const PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
    pNext: ?*c_void = null,
    shaderIntegerFunctions2: Bool32,
};


pub const INTEL_performance_query = 1;
pub const PerformanceConfigurationINTEL = *@OpaqueType();

pub const INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 1;
pub const INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = c"VK_INTEL_performance_query";

pub const PerformanceConfigurationTypeINTEL = extern enum {
    COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED = 0,
};

pub const QueryPoolSamplingModeINTEL = extern enum {
    MANUAL = 0,
};

pub const PerformanceOverrideTypeINTEL = extern enum {
    NULL_HARDWARE = 0,
    FLUSH_GPU_CACHES = 1,
};

pub const PerformanceParameterTypeINTEL = extern enum {
    HW_COUNTERS_SUPPORTED = 0,
    STREAM_MARKER_VALID_BITS = 1,
};

pub const PerformanceValueTypeINTEL = extern enum {
    UINT32 = 0,
    UINT64 = 1,
    FLOAT = 2,
    BOOL = 3,
    STRING = 4,
};

pub const PerformanceValueDataINTEL = extern union {
    value32: u32,
    value64: u64,
    valueFloat: f32,
    valueBool: Bool32,
    valueString: *const u8,
};

pub const PerformanceValueINTEL = extern struct {
    inType: PerformanceValueTypeINTEL,
    data: PerformanceValueDataINTEL,
};

pub const InitializePerformanceApiInfoINTEL = extern struct {
    sType: StructureType = .INITIALIZE_PERFORMANCE_API_INFO_INTEL,
    pNext: ?*const c_void = null,
    pUserData: ?*c_void,
};

pub const QueryPoolCreateInfoINTEL = extern struct {
    sType: StructureType = .QUERY_POOL_CREATE_INFO_INTEL,
    pNext: ?*const c_void = null,
    performanceCountersSampling: QueryPoolSamplingModeINTEL,
};

pub const PerformanceMarkerInfoINTEL = extern struct {
    sType: StructureType = .PERFORMANCE_MARKER_INFO_INTEL,
    pNext: ?*const c_void = null,
    marker: u64,
};

pub const PerformanceStreamMarkerInfoINTEL = extern struct {
    sType: StructureType = .PERFORMANCE_STREAM_MARKER_INFO_INTEL,
    pNext: ?*const c_void = null,
    marker: u32,
};

pub const PerformanceOverrideInfoINTEL = extern struct {
    sType: StructureType = .PERFORMANCE_OVERRIDE_INFO_INTEL,
    pNext: ?*const c_void = null,
    inType: PerformanceOverrideTypeINTEL,
    enable: Bool32,
    parameter: u64,
};

pub const PerformanceConfigurationAcquireInfoINTEL = extern struct {
    sType: StructureType = .PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
    pNext: ?*const c_void = null,
    inType: PerformanceConfigurationTypeINTEL,
};

pub extern fn vkInitializePerformanceApiINTEL(
    device: Device,
    pInitializeInfo: *const InitializePerformanceApiInfoINTEL,
) Result;

pub extern fn vkUninitializePerformanceApiINTEL(device: Device) void;

pub extern fn vkCmdSetPerformanceMarkerINTEL(
    commandBuffer: CommandBuffer,
    pMarkerInfo: *const PerformanceMarkerInfoINTEL,
) Result;

pub extern fn vkCmdSetPerformanceStreamMarkerINTEL(
    commandBuffer: CommandBuffer,
    pMarkerInfo: *const PerformanceStreamMarkerInfoINTEL,
) Result;

pub extern fn vkCmdSetPerformanceOverrideINTEL(
    commandBuffer: CommandBuffer,
    pOverrideInfo: *const PerformanceOverrideInfoINTEL,
) Result;

pub extern fn vkAcquirePerformanceConfigurationINTEL(
    device: Device,
    pAcquireInfo: *const PerformanceConfigurationAcquireInfoINTEL,
    pConfiguration: *PerformanceConfigurationINTEL,
) Result;

pub extern fn vkReleasePerformanceConfigurationINTEL(
    device: Device,
    configuration: PerformanceConfigurationINTEL,
) Result;

pub extern fn vkQueueSetPerformanceConfigurationINTEL(
    queue: Queue,
    configuration: PerformanceConfigurationINTEL,
) Result;

pub extern fn vkGetPerformanceParameterINTEL(
    device: Device,
    parameter: PerformanceParameterTypeINTEL,
    pValue: *PerformanceValueINTEL,
) Result;

pub inline fn InitializePerformanceApiINTEL(device: Device, initializeInfo: InitializePerformanceApiInfoINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkInitializePerformanceApiINTEL(device, &initializeInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub const UninitializePerformanceApiINTEL = vkUninitializePerformanceApiINTEL;

pub inline fn CmdSetPerformanceMarkerINTEL(commandBuffer: CommandBuffer, markerInfo: PerformanceMarkerInfoINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkCmdSetPerformanceMarkerINTEL(commandBuffer, &markerInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CmdSetPerformanceStreamMarkerINTEL(commandBuffer: CommandBuffer, markerInfo: PerformanceStreamMarkerInfoINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, &markerInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn CmdSetPerformanceOverrideINTEL(commandBuffer: CommandBuffer, overrideInfo: PerformanceOverrideInfoINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkCmdSetPerformanceOverrideINTEL(commandBuffer, &overrideInfo);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn AcquirePerformanceConfigurationINTEL(device: Device, acquireInfo: PerformanceConfigurationAcquireInfoINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!PerformanceConfigurationINTEL {
    var out_configuration: PerformanceConfigurationINTEL = undefined;
    const result = vkAcquirePerformanceConfigurationINTEL(device, &acquireInfo, &out_configuration);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_configuration;
}

pub inline fn ReleasePerformanceConfigurationINTEL(device: Device, configuration: PerformanceConfigurationINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkReleasePerformanceConfigurationINTEL(device, configuration);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn QueueSetPerformanceConfigurationINTEL(queue: Queue, configuration: PerformanceConfigurationINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!void {
    const result = vkQueueSetPerformanceConfigurationINTEL(queue, configuration);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
}

pub inline fn GetPerformanceParameterINTEL(device: Device, parameter: PerformanceParameterTypeINTEL) error{VK_TOO_MANY_OBJECTS,VK_OUT_OF_HOST_MEMORY,VK_UNDOCUMENTED_ERROR}!PerformanceValueINTEL {
    var out_value: PerformanceValueINTEL = undefined;
    const result = vkGetPerformanceParameterINTEL(device, parameter, &out_value);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_TOO_MANY_OBJECTS => error.VK_TOO_MANY_OBJECTS,
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_value;
}


pub const EXT_pci_bus_info = 1;
pub const EXT_PCI_BUS_INFO_SPEC_VERSION = 2;
pub const EXT_PCI_BUS_INFO_EXTENSION_NAME = c"VK_EXT_pci_bus_info";

pub const PhysicalDevicePCIBusInfoPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    pciDomain: u32,
    pciBus: u32,
    pciDevice: u32,
    pciFunction: u32,
};


pub const AMD_display_native_hdr = 1;
pub const AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1;
pub const AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = c"VK_AMD_display_native_hdr";

pub const DisplayNativeHdrSurfaceCapabilitiesAMD = extern struct {
    sType: StructureType = .DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
    pNext: ?*c_void = null,
    localDimmingSupport: Bool32,
};

pub const SwapchainDisplayNativeHdrCreateInfoAMD = extern struct {
    sType: StructureType = .SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
    pNext: ?*const c_void = null,
    localDimmingEnable: Bool32,
};

pub extern fn vkSetLocalDimmingAMD(
    device: Device,
    swapChain: SwapchainKHR,
    localDimmingEnable: Bool32,
) void;

pub const SetLocalDimmingAMD = vkSetLocalDimmingAMD;


pub const EXT_fragment_density_map = 1;
pub const EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 1;
pub const EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = c"VK_EXT_fragment_density_map";

pub const PhysicalDeviceFragmentDensityMapFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
    pNext: ?*c_void = null,
    fragmentDensityMap: Bool32,
    fragmentDensityMapDynamic: Bool32,
    fragmentDensityMapNonSubsampledImages: Bool32,
};

pub const PhysicalDeviceFragmentDensityMapPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    minFragmentDensityTexelSize: Extent2D,
    maxFragmentDensityTexelSize: Extent2D,
    fragmentDensityInvocations: Bool32,
};

pub const RenderPassFragmentDensityMapCreateInfoEXT = extern struct {
    sType: StructureType = .RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    fragmentDensityMapAttachment: AttachmentReference,
};


pub const EXT_scalar_block_layout = 1;
pub const EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1;
pub const EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = c"VK_EXT_scalar_block_layout";

pub const PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;


pub const GOOGLE_hlsl_functionality1 = 1;
pub const GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = 1;
pub const GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = c"VK_GOOGLE_hlsl_functionality1";


pub const GOOGLE_decorate_string = 1;
pub const GOOGLE_DECORATE_STRING_SPEC_VERSION = 1;
pub const GOOGLE_DECORATE_STRING_EXTENSION_NAME = c"VK_GOOGLE_decorate_string";


pub const EXT_subgroup_size_control = 1;
pub const EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2;
pub const EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = c"VK_EXT_subgroup_size_control";

pub const PhysicalDeviceSubgroupSizeControlFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
    pNext: ?*c_void = null,
    subgroupSizeControl: Bool32,
    computeFullSubgroups: Bool32,
};

pub const PhysicalDeviceSubgroupSizeControlPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    minSubgroupSize: u32,
    maxSubgroupSize: u32,
    maxComputeWorkgroupSubgroups: u32,
    requiredSubgroupSizeStages: ShaderStageFlags,
};

pub const PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
    pNext: ?*c_void = null,
    requiredSubgroupSize: u32,
};


pub const AMD_shader_core_properties2 = 1;
pub const AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1;
pub const AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = c"VK_AMD_shader_core_properties2";

pub const ShaderCorePropertiesFlagsAMD = Flags;
pub const ShaderCorePropertiesFlagBitsAMD = struct {
};

pub const PhysicalDeviceShaderCoreProperties2AMD = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
    pNext: ?*c_void = null,
    shaderCoreFeatures: ShaderCorePropertiesFlagsAMD,
    activeComputeUnitCount: u32,
};


pub const AMD_device_coherent_memory = 1;
pub const AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1;
pub const AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = c"VK_AMD_device_coherent_memory";

pub const PhysicalDeviceCoherentMemoryFeaturesAMD = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
    pNext: ?*c_void = null,
    deviceCoherentMemory: Bool32,
};


pub const EXT_memory_budget = 1;
pub const EXT_MEMORY_BUDGET_SPEC_VERSION = 1;
pub const EXT_MEMORY_BUDGET_EXTENSION_NAME = c"VK_EXT_memory_budget";

pub const PhysicalDeviceMemoryBudgetPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    heapBudget: [MAX_MEMORY_HEAPS]DeviceSize,
    heapUsage: [MAX_MEMORY_HEAPS]DeviceSize,
};


pub const EXT_memory_priority = 1;
pub const EXT_MEMORY_PRIORITY_SPEC_VERSION = 1;
pub const EXT_MEMORY_PRIORITY_EXTENSION_NAME = c"VK_EXT_memory_priority";

pub const PhysicalDeviceMemoryPriorityFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
    pNext: ?*c_void = null,
    memoryPriority: Bool32,
};

pub const MemoryPriorityAllocateInfoEXT = extern struct {
    sType: StructureType = .MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
    pNext: ?*const c_void = null,
    priority: f32,
};


pub const NV_dedicated_allocation_image_aliasing = 1;
pub const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1;
pub const NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = c"VK_NV_dedicated_allocation_image_aliasing";

pub const PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
    pNext: ?*c_void = null,
    dedicatedAllocationImageAliasing: Bool32,
};


pub const EXT_buffer_device_address = 1;
pub const EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2;
pub const EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = c"VK_EXT_buffer_device_address";

pub const PhysicalDeviceBufferDeviceAddressFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    pNext: ?*c_void = null,
    bufferDeviceAddress: Bool32,
    bufferDeviceAddressCaptureReplay: Bool32,
    bufferDeviceAddressMultiDevice: Bool32,
};

pub const PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub const BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;

pub const BufferDeviceAddressCreateInfoEXT = extern struct {
    sType: StructureType = .BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    deviceAddress: DeviceAddress,
};

pub extern fn vkGetBufferDeviceAddressEXT(
    device: Device,
    pInfo: *const BufferDeviceAddressInfo,
) DeviceAddress;

pub inline fn GetBufferDeviceAddressEXT(device: Device, info: BufferDeviceAddressInfo) DeviceAddress {
    const result = vkGetBufferDeviceAddressEXT(device, &info);
    return result;
}


pub const EXT_tooling_info = 1;
pub const EXT_TOOLING_INFO_SPEC_VERSION = 1;
pub const EXT_TOOLING_INFO_EXTENSION_NAME = c"VK_EXT_tooling_info";

pub const ToolPurposeFlagsEXT = Flags;
pub const ToolPurposeFlagBitsEXT = struct {
    pub const VALIDATION_BIT: ToolPurposeFlagsEXT = 0x00000001;
    pub const PROFILING_BIT: ToolPurposeFlagsEXT = 0x00000002;
    pub const TRACING_BIT: ToolPurposeFlagsEXT = 0x00000004;
    pub const ADDITIONAL_FEATURES_BIT: ToolPurposeFlagsEXT = 0x00000008;
    pub const MODIFYING_FEATURES_BIT: ToolPurposeFlagsEXT = 0x00000010;
    pub const DEBUG_REPORTING_BIT: ToolPurposeFlagsEXT = 0x00000020;
    pub const DEBUG_MARKERS_BIT: ToolPurposeFlagsEXT = 0x00000040;
};

pub const PhysicalDeviceToolPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    name: [MAX_EXTENSION_NAME_SIZE]u8,
    version: [MAX_EXTENSION_NAME_SIZE]u8,
    purposes: ToolPurposeFlagsEXT,
    description: [MAX_DESCRIPTION_SIZE]u8,
    layer: [MAX_EXTENSION_NAME_SIZE]u8,
};

pub extern fn vkGetPhysicalDeviceToolPropertiesEXT(
    physicalDevice: PhysicalDevice,
    pToolCount: *u32,
    pToolProperties: ?[*]PhysicalDeviceToolPropertiesEXT,
) Result;

pub const GetPhysicalDeviceToolPropertiesEXTResult = struct {
    result: Result,
    toolProperties: []PhysicalDeviceToolPropertiesEXT,
};
pub inline fn GetPhysicalDeviceToolPropertiesEXT(physicalDevice: PhysicalDevice, toolProperties: []PhysicalDeviceToolPropertiesEXT) error{VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceToolPropertiesEXTResult {
    var returnValues: GetPhysicalDeviceToolPropertiesEXTResult = undefined;
    var toolCount: u32 = @intCast(u32, toolProperties.len);
    const result = vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &toolCount, toolProperties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    returnValues.toolProperties = toolProperties[0..toolCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceToolPropertiesCountEXT(physicalDevice: PhysicalDevice) error{VK_UNDOCUMENTED_ERROR}!u32 {
    var out_toolCount: u32 = undefined;
    const result = vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &out_toolCount, null);
    if (@bitCast(c_int, result) < 0) {
        return error.VK_UNDOCUMENTED_ERROR;
    }
    return out_toolCount;
}


pub const EXT_separate_stencil_usage = 1;
pub const EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1;
pub const EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = c"VK_EXT_separate_stencil_usage";

pub const ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;


pub const EXT_validation_features = 1;
pub const EXT_VALIDATION_FEATURES_SPEC_VERSION = 2;
pub const EXT_VALIDATION_FEATURES_EXTENSION_NAME = c"VK_EXT_validation_features";

pub const ValidationFeatureEnableEXT = extern enum {
    GPU_ASSISTED = 0,
    GPU_ASSISTED_RESERVE_BINDING_SLOT = 1,
    BEST_PRACTICES = 2,
};

pub const ValidationFeatureDisableEXT = extern enum {
    ALL = 0,
    SHADERS = 1,
    THREAD_SAFETY = 2,
    API_PARAMETERS = 3,
    OBJECT_LIFETIMES = 4,
    CORE_CHECKS = 5,
    UNIQUE_HANDLES = 6,
};

pub const ValidationFeaturesEXT = extern struct {
    sType: StructureType = .VALIDATION_FEATURES_EXT,
    pNext: ?*const c_void = null,
    enabledValidationFeatureCount: u32 = 0,
    pEnabledValidationFeatures: [*]const ValidationFeatureEnableEXT = undefined,
    disabledValidationFeatureCount: u32 = 0,
    pDisabledValidationFeatures: [*]const ValidationFeatureDisableEXT = undefined,
};


pub const NV_cooperative_matrix = 1;
pub const NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1;
pub const NV_COOPERATIVE_MATRIX_EXTENSION_NAME = c"VK_NV_cooperative_matrix";

pub const ComponentTypeNV = extern enum {
    FLOAT16 = 0,
    FLOAT32 = 1,
    FLOAT64 = 2,
    SINT8 = 3,
    SINT16 = 4,
    SINT32 = 5,
    SINT64 = 6,
    UINT8 = 7,
    UINT16 = 8,
    UINT32 = 9,
    UINT64 = 10,
};

pub const ScopeNV = extern enum {
    DEVICE = 1,
    WORKGROUP = 2,
    SUBGROUP = 3,
    QUEUE_FAMILY = 5,
};

pub const CooperativeMatrixPropertiesNV = extern struct {
    sType: StructureType = .COOPERATIVE_MATRIX_PROPERTIES_NV,
    pNext: ?*c_void = null,
    MSize: u32,
    NSize: u32,
    KSize: u32,
    AType: ComponentTypeNV,
    BType: ComponentTypeNV,
    CType: ComponentTypeNV,
    DType: ComponentTypeNV,
    scope: ScopeNV,
};

pub const PhysicalDeviceCooperativeMatrixFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
    pNext: ?*c_void = null,
    cooperativeMatrix: Bool32,
    cooperativeMatrixRobustBufferAccess: Bool32,
};

pub const PhysicalDeviceCooperativeMatrixPropertiesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
    pNext: ?*c_void = null,
    cooperativeMatrixSupportedStages: ShaderStageFlags,
};

pub extern fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    physicalDevice: PhysicalDevice,
    pPropertyCount: *u32,
    pProperties: ?[*]CooperativeMatrixPropertiesNV,
) Result;

pub const GetPhysicalDeviceCooperativeMatrixPropertiesNVResult = struct {
    result: Result,
    properties: []CooperativeMatrixPropertiesNV,
};
pub inline fn GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice: PhysicalDevice, properties: []CooperativeMatrixPropertiesNV) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceCooperativeMatrixPropertiesNVResult {
    var returnValues: GetPhysicalDeviceCooperativeMatrixPropertiesNVResult = undefined;
    var propertyCount: u32 = @intCast(u32, properties.len);
    const result = vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, &propertyCount, properties.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.properties = properties[0..propertyCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceCooperativeMatrixPropertiesCountNV(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_propertyCount: u32 = undefined;
    const result = vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, &out_propertyCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_propertyCount;
}


pub const NV_coverage_reduction_mode = 1;
pub const NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1;
pub const NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = c"VK_NV_coverage_reduction_mode";

pub const CoverageReductionModeNV = extern enum {
    MERGE = 0,
    TRUNCATE = 1,
};

pub const PipelineCoverageReductionStateCreateFlagsNV = Flags;

pub const PhysicalDeviceCoverageReductionModeFeaturesNV = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
    pNext: ?*c_void = null,
    coverageReductionMode: Bool32,
};

pub const PipelineCoverageReductionStateCreateInfoNV = extern struct {
    sType: StructureType = .PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
    pNext: ?*const c_void = null,
    flags: PipelineCoverageReductionStateCreateFlagsNV = 0,
    coverageReductionMode: CoverageReductionModeNV,
};

pub const FramebufferMixedSamplesCombinationNV = extern struct {
    sType: StructureType = .FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
    pNext: ?*c_void = null,
    coverageReductionMode: CoverageReductionModeNV,
    rasterizationSamples: SampleCountFlags,
    depthStencilSamples: SampleCountFlags,
    colorSamples: SampleCountFlags,
};

pub extern fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    physicalDevice: PhysicalDevice,
    pCombinationCount: *u32,
    pCombinations: ?[*]FramebufferMixedSamplesCombinationNV,
) Result;

pub const GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVResult = struct {
    result: Result,
    combinations: []FramebufferMixedSamplesCombinationNV,
};
pub inline fn GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice: PhysicalDevice, combinations: []FramebufferMixedSamplesCombinationNV) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVResult {
    var returnValues: GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNVResult = undefined;
    var combinationCount: u32 = @intCast(u32, combinations.len);
    const result = vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, &combinationCount, combinations.ptr);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    returnValues.combinations = combinations[0..combinationCount];
    returnValues.result = result;
    return returnValues;
}
pub inline fn GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsCountNV(physicalDevice: PhysicalDevice) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!u32 {
    var out_combinationCount: u32 = undefined;
    const result = vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, &out_combinationCount, null);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_combinationCount;
}


pub const EXT_fragment_shader_interlock = 1;
pub const EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1;
pub const EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = c"VK_EXT_fragment_shader_interlock";

pub const PhysicalDeviceFragmentShaderInterlockFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
    pNext: ?*c_void = null,
    fragmentShaderSampleInterlock: Bool32,
    fragmentShaderPixelInterlock: Bool32,
    fragmentShaderShadingRateInterlock: Bool32,
};


pub const EXT_ycbcr_image_arrays = 1;
pub const EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1;
pub const EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = c"VK_EXT_ycbcr_image_arrays";

pub const PhysicalDeviceYcbcrImageArraysFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
    pNext: ?*c_void = null,
    ycbcrImageArrays: Bool32,
};


pub const EXT_headless_surface = 1;
pub const EXT_HEADLESS_SURFACE_SPEC_VERSION = 1;
pub const EXT_HEADLESS_SURFACE_EXTENSION_NAME = c"VK_EXT_headless_surface";

pub const HeadlessSurfaceCreateFlagsEXT = Flags;

pub const HeadlessSurfaceCreateInfoEXT = extern struct {
    sType: StructureType = .HEADLESS_SURFACE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    flags: HeadlessSurfaceCreateFlagsEXT = 0,
};

pub extern fn vkCreateHeadlessSurfaceEXT(
    instance: Instance,
    pCreateInfo: *const HeadlessSurfaceCreateInfoEXT,
    pAllocator: ?*const AllocationCallbacks,
    pSurface: *SurfaceKHR,
) Result;

pub inline fn CreateHeadlessSurfaceEXT(instance: Instance, createInfo: HeadlessSurfaceCreateInfoEXT, pAllocator: ?*const AllocationCallbacks) error{VK_OUT_OF_HOST_MEMORY,VK_OUT_OF_DEVICE_MEMORY,VK_UNDOCUMENTED_ERROR}!SurfaceKHR {
    var out_surface: SurfaceKHR = undefined;
    const result = vkCreateHeadlessSurfaceEXT(instance, &createInfo, pAllocator, &out_surface);
    if (@bitCast(c_int, result) < 0) {
        return switch (result) {
            .ERROR_OUT_OF_HOST_MEMORY => error.VK_OUT_OF_HOST_MEMORY,
            .ERROR_OUT_OF_DEVICE_MEMORY => error.VK_OUT_OF_DEVICE_MEMORY,
            else => error.VK_UNDOCUMENTED_ERROR,
        };
    }
    return out_surface;
}


pub const EXT_line_rasterization = 1;
pub const EXT_LINE_RASTERIZATION_SPEC_VERSION = 1;
pub const EXT_LINE_RASTERIZATION_EXTENSION_NAME = c"VK_EXT_line_rasterization";

pub const LineRasterizationModeEXT = extern enum {
    DEFAULT = 0,
    RECTANGULAR = 1,
    BRESENHAM = 2,
    RECTANGULAR_SMOOTH = 3,
};

pub const PhysicalDeviceLineRasterizationFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
    pNext: ?*c_void = null,
    rectangularLines: Bool32,
    bresenhamLines: Bool32,
    smoothLines: Bool32,
    stippledRectangularLines: Bool32,
    stippledBresenhamLines: Bool32,
    stippledSmoothLines: Bool32,
};

pub const PhysicalDeviceLineRasterizationPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    lineSubPixelPrecisionBits: u32,
};

pub const PipelineRasterizationLineStateCreateInfoEXT = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
    pNext: ?*const c_void = null,
    lineRasterizationMode: LineRasterizationModeEXT,
    stippledLineEnable: Bool32,
    lineStippleFactor: u32 = 0,
    lineStipplePattern: u16 = 0,
};

pub extern fn vkCmdSetLineStippleEXT(
    commandBuffer: CommandBuffer,
    lineStippleFactor: u32,
    lineStipplePattern: u16,
) void;

pub const CmdSetLineStippleEXT = vkCmdSetLineStippleEXT;


pub const EXT_host_query_reset = 1;
pub const EXT_HOST_QUERY_RESET_SPEC_VERSION = 1;
pub const EXT_HOST_QUERY_RESET_EXTENSION_NAME = c"VK_EXT_host_query_reset";

pub const PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;

pub extern fn vkResetQueryPoolEXT(
    device: Device,
    queryPool: QueryPool,
    firstQuery: u32,
    queryCount: u32,
) void;

pub const ResetQueryPoolEXT = vkResetQueryPoolEXT;


pub const EXT_index_type_uint8 = 1;
pub const EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1;
pub const EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = c"VK_EXT_index_type_uint8";

pub const PhysicalDeviceIndexTypeUint8FeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
    pNext: ?*c_void = null,
    indexTypeUint8: Bool32,
};


pub const EXT_shader_demote_to_helper_invocation = 1;
pub const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1;
pub const EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = c"VK_EXT_shader_demote_to_helper_invocation";

pub const PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
    pNext: ?*c_void = null,
    shaderDemoteToHelperInvocation: Bool32,
};


pub const EXT_texel_buffer_alignment = 1;
pub const EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1;
pub const EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = c"VK_EXT_texel_buffer_alignment";

pub const PhysicalDeviceTexelBufferAlignmentFeaturesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
    pNext: ?*c_void = null,
    texelBufferAlignment: Bool32,
};

pub const PhysicalDeviceTexelBufferAlignmentPropertiesEXT = extern struct {
    sType: StructureType = .PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
    pNext: ?*c_void = null,
    storageTexelBufferOffsetAlignmentBytes: DeviceSize,
    storageTexelBufferOffsetSingleTexelAlignment: Bool32,
    uniformTexelBufferOffsetAlignmentBytes: DeviceSize,
    uniformTexelBufferOffsetSingleTexelAlignment: Bool32,
};


pub const GOOGLE_user_type = 1;
pub const GOOGLE_USER_TYPE_SPEC_VERSION = 1;
pub const GOOGLE_USER_TYPE_EXTENSION_NAME = c"VK_GOOGLE_user_type";


test "Compile All" { _ = @typeInfo(@This()); }
